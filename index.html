<html lang="en"><head><script>(function(firebaseConfig, initialAuthToken, appId) {
        window.__firebase_config = firebaseConfig;
        window.__initial_auth_token = initialAuthToken;
        window.__app_id = appId;
            })("\n{\n  \"apiKey\": \"AIzaSyCqyCcs2R2e7AegGjvFAwG98wlamtbHvZY\",\n  \"authDomain\": \"bard-frontend.firebaseapp.com\",\n  \"projectId\": \"bard-frontend\",\n  \"storageBucket\": \"bard-frontend.firebasestorage.app\",\n  \"messagingSenderId\": \"175205271074\",\n  \"appId\": \"1:175205271074:web:2b7bd4d34d33bf38e6ec7b\"\n}\n","eyJhbGciOiJSUzI1NiIsImtpZCI6ImQ1OTQzZDdlNWZhYTIxZjcyOTJjMzI3MGY3ZDBjNWJmNDE5MjJmOTciLCJ0eXAiOiJKV1QifQ.eyJzdWIiOiJmaXJlYmFzZS1hZG1pbnNkay1mYnN2Y0BiYXJkLWZyb250ZW5kLmlhbS5nc2VydmljZWFjY291bnQuY29tIiwiYXVkIjoiaHR0cHM6Ly9pZGVudGl0eXRvb2xraXQuZ29vZ2xlYXBpcy5jb20vZ29vZ2xlLmlkZW50aXR5LmlkZW50aXR5dG9vbGtpdC52MS5JZGVudGl0eVRvb2xraXQiLCJ1aWQiOiIwMjA4MjI3NjA1MjU3NzkzMzk0OSIsImlzcyI6ImZpcmViYXNlLWFkbWluc2RrLWZic3ZjQGJhcmQtZnJvbnRlbmQuaWFtLmdzZXJ2aWNlYWNjb3VudC5jb20iLCJjbGFpbXMiOnsiYXBwSWQiOiJjXzJiMTk3NGEzMGI3M2ZhNzBfaW5kZXguaHRtbC05NCJ9LCJleHAiOjE3NzAzNDAzMDksImlhdCI6MTc3MDMzNjcwOSwiYWxnIjoiUlMyNTYifQ.lzfQS4YlmwqJVA3NlHIWYS4DG741f2Px5kGIZab4nyosg7zfxzJJOnA_2lvb4G0aHUQ39WYpI9x3jsCUCJdk4QNjZM8a7T8rjQCCLYMMdO7b__AZUsq7Plp-WoR_a5lkfPYvIqKQzPFC1PZPdzkvTBZULB6A7NqyqIRXse9PHMqDbJekbHcmgs4a-JazGS6SjrKPJHYrEymiow-uljTglw8B_TVFNLMIKhTJJkLoSNdVpIGZ_6wv2ktacUhCAa0mesNUduX5wx36rYmlnN4E788XyGtgeDwLYZl_1OXjL0sXeWwWG_nO7b_DsqKKXN7ttJ3l7T1cbN5eFjGg6ZRxXQ","c_2b1974a30b73fa70_index.html-94")</script><script>'use strict';var h=typeof Object.defineProperties=="function"?Object.defineProperty:function(a,b,d){if(a==Array.prototype||a==Object.prototype)return a;a[b]=d.value;return a};function l(a){a=["object"==typeof globalThis&&globalThis,a,"object"==typeof window&&window,"object"==typeof self&&self,"object"==typeof global&&global];for(var b=0;b<a.length;++b){var d=a[b];if(d&&d.Math==Math)return d}throw Error("Cannot find global object");}var n=l(this);
function p(a,b){if(b)a:{var d=n;a=a.split(".");for(var c=0;c<a.length-1;c++){var e=a[c];if(!(e in d))break a;d=d[e]}a=a[a.length-1];c=d[a];b=b(c);b!=c&&b!=null&&h(d,a,{configurable:!0,writable:!0,value:b})}}function r(a){function b(c){return a.next(c)}function d(c){return a.throw(c)}return new Promise(function(c,e){function f(g){g.done?c(g.value):Promise.resolve(g.value).then(b,d).then(f,e)}f(a.next())})}function t(a){return r(a())}
p("Object.values",function(a){return a?a:function(b){var d=[],c;for(c in b)Object.prototype.hasOwnProperty.call(b,c)&&d.push(b[c]);return d}});p("Array.prototype.includes",function(a){return a?a:function(b,d){var c=this;c instanceof String&&(c=String(c));var e=c.length;d=d||0;for(d<0&&(d=Math.max(d+e,0));d<e;d++){var f=c[d];if(f===b||Object.is(f,b))return!0}return!1}});/*

 MIT License

 Copyright (c) 2017-2023 W.Y.

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.

*/
function u(a,b){const d=a.style;b.backgroundColor&&(d.backgroundColor=b.backgroundColor);b.width&&(d.width=`${b.width}px`);b.height&&(d.height=`${b.height}px`);const c=b.style;c!=null&&Object.keys(c).forEach(e=>{d[e]=c[e]})};var v=(()=>{let a=0;return()=>{a+=1;return`u${`0000${(Math.random()*1679616<<0).toString(36)}`.slice(-4)}${a}`}})();function w(a){const b=[];for(let d=0,c=a.length;d<c;d++)b.push(a[d]);return b}let x=null;function y(a={}){return x?x:a.l?x=a.l:x=w(window.getComputedStyle(document.documentElement))}function z(a,b){return(a=(a.ownerDocument.defaultView||window).getComputedStyle(a).getPropertyValue(b))?parseFloat(a.replace("px","")):0}
function A(a,b={}){var d;if(!(d=b.width)){d=z(a,"border-left-width");var c=z(a,"border-right-width");d=a.clientWidth+d+c}(b=b.height)||(b=z(a,"border-top-width"),c=z(a,"border-bottom-width"),b=a.clientHeight+b+c);return{width:d,height:b}}function B(a){return new Promise((b,d)=>{const c=new Image;c.onload=()=>{c.decode().then(()=>{requestAnimationFrame(()=>b(c))})};c.onerror=d;c.crossOrigin="anonymous";c.decoding="async";c.src=a})}
function C(a){return t(function*(){return Promise.resolve().then(()=>(new XMLSerializer).serializeToString(a)).then(encodeURIComponent).then(b=>`data:image/svg+xml;charset=utf-8,${b}`)})}
function D(a,b,d){return t(function*(){const c=document.createElementNS("http://www.w3.org/2000/svg","svg"),e=document.createElementNS("http://www.w3.org/2000/svg","foreignObject");c.setAttribute("width",`${b}`);c.setAttribute("height",`${d}`);c.setAttribute("viewBox",`0 0 ${b} ${d}`);e.setAttribute("width","100%");e.setAttribute("height","100%");e.setAttribute("x","0");e.setAttribute("y","0");e.setAttribute("externalResourcesRequired","true");c.appendChild(e);e.appendChild(a);return C(c)})}
var E=(a,b)=>{if(a instanceof b)return!0;a=Object.getPrototypeOf(a);return a===null?!1:a.constructor.name===b.name||E(a,b)};function F(a,b){return y(b).map(d=>{const c=a.getPropertyValue(d),e=a.getPropertyPriority(d);return`${d}: ${c}${e?" !important":""};`}).join(" ")}
function G(a,b,d,c){a=window.getComputedStyle(a,d);var e=a.getPropertyValue("content");if(e!==""&&e!=="none"){var f=v();try{b.className=`${b.className} ${f}`}catch(k){return}e=document.createElement("style");var g=e.appendChild;d=`.${f}:${d}`;a.cssText?(c=a.getPropertyValue("content"),c=`${a.cssText} content: '${c.replace(/'|"/g,"")}';`):c=F(a,c);g.call(e,document.createTextNode(`${d}{${c}}`));b.appendChild(e)}};function H(a){return a.search(/^(data:)/)!==-1}function I(a,b,d){return t(function*(){const c=yield fetch(a,b);if(c.status===404)throw Error(`Resource "${c.url}" not found`);const e=yield c.blob();return new Promise((f,g)=>{const k=new FileReader;k.onerror=g;k.onloadend=()=>{try{f(d({o:c,result:k.result}))}catch(m){g(m)}};k.readAsDataURL(e)})})}const J={};function K(a,b,d){let c=a.replace(/\?.*/,"");d&&(c=a);/ttf|otf|eot|woff2?/i.test(c)&&(c=c.replace(/.*\//,""));return b?`[${b}]${c}`:c}
function L(a,b,d){return t(function*(){const c=K(a,b,d.C);if(J[c]!=null)return J[c];d.u&&(a+=(/\?/.test(a)?"&":"?")+(new Date).getTime());let e;try{const f=yield I(a,d.i,({o:g,result:k})=>{b||(b=g.headers.get("Content-Type")||"");return k.split(/,/)[1]});e=`data:${b};base64,${f}`}catch(f){e=d.B||""}return J[c]=e})};const M={P:"application/font-woff",R:"application/font-woff",N:"application/font-truetype",v:"application/vnd.ms-fontobject",H:"image/png",F:"image/jpeg",D:"image/jpeg",A:"image/gif",M:"image/tiff",L:"image/svg+xml",O:"image/webp"};function N(a){return(a=/\.([^./]*?)$/g.exec(a))?a[1]:""};function O(a){return t(function*(){const b=a.toDataURL();return b==="data:,"?a.cloneNode(!1):B(b)})}function aa(a,b){return t(function*(){if(a.currentSrc){var d=document.createElement("canvas");const c=d.getContext("2d");d.width=a.clientWidth;d.height=a.clientHeight;c==null||c.drawImage(a,0,0,d.width,d.height);d=d.toDataURL();return B(d)}d=a.poster;d=yield L(d,M[N(d).toLowerCase()]||"",b);return B(d)})}
function ba(a,b){return t(function*(){try{let d;if(a==null?0:(d=a.contentDocument)==null?0:d.body)return yield P(a.contentDocument.body,b,!0)}catch(d){}return a.cloneNode(!1)})}function ca(a,b){return t(function*(){return E(a,HTMLCanvasElement)?O(a):E(a,HTMLVideoElement)?aa(a,b):E(a,HTMLIFrameElement)?ba(a,b):a.cloneNode(a.tagName!=null&&a.tagName.toUpperCase()==="SVG")})}
function da(a,b,d){return t(function*(){if(b.tagName!=null&&b.tagName.toUpperCase()==="SVG")return b;let c=[];if(a.tagName!=null&&a.tagName.toUpperCase()==="SLOT"&&a.assignedNodes)c=w(a.assignedNodes());else{let e;if(E(a,HTMLIFrameElement)&&((e=a.contentDocument)==null?0:e.body))c=w(a.contentDocument.body.childNodes);else{let f;c=w(((f=a.shadowRoot)!=null?f:a).childNodes)}}if(c.length===0||E(a,HTMLVideoElement))return b;yield c.reduce((e,f)=>e.then(()=>P(f,d)).then(g=>{g&&b.appendChild(g)}),Promise.resolve());
return b})}function ea(a,b,d){const c=b.style;if(c){var e=window.getComputedStyle(a);e.cssText?(c.cssText=e.cssText,c.transformOrigin=e.transformOrigin):y(d).forEach(f=>{let g=e.getPropertyValue(f);f==="font-size"&&g.endsWith("px")&&(g=`${Math.floor(parseFloat(g.substring(0,g.length-2)))-.1}px`);E(a,HTMLIFrameElement)&&f==="display"&&g==="inline"&&(g="block");f==="d"&&b.getAttribute("d")&&(g=`path(${b.getAttribute("d")})`);c.setProperty(f,g,e.getPropertyPriority(f))})}}
function fa(a,b){E(a,HTMLSelectElement)&&(b=Array.from(b.children).find(d=>a.value===d.getAttribute("value")))&&b.setAttribute("selected","")}
function ha(a,b){return t(function*(){var d=a.querySelectorAll?a.querySelectorAll("use"):[];if(d.length===0)return a;var c={};for(var e=0;e<d.length;e++){var f=d[e].getAttribute("xlink:href");if(f){const g=document.querySelector(f);a.querySelector(f)||!g||c[f]||(c[f]=yield P(g,b,!0))}}d=Object.values(c);if(d.length){c=document.createElementNS("http://www.w3.org/1999/xhtml","svg");c.setAttribute("xmlns","http://www.w3.org/1999/xhtml");c.style.position="absolute";c.style.width="0";c.style.height="0";
c.style.overflow="hidden";c.style.display="none";e=document.createElementNS("http://www.w3.org/1999/xhtml","defs");c.appendChild(e);for(f=0;f<d.length;f++)e.appendChild(d[f]);a.appendChild(c)}return a})}
function P(a,b,d){return t(function*(){return d||!b.filter||b.filter(a)?Promise.resolve(a).then(c=>ca(c,b)).then(c=>da(a,c,b)).then(c=>{E(c,Element)&&(ea(a,c,b),G(a,c,":before",b),G(a,c,":after",b),E(a,HTMLTextAreaElement)&&(c.textContent=a.value),E(a,HTMLInputElement)&&c.setAttribute("value",a.value),fa(a,c));return c}).then(c=>ha(c,b)):null})};const Q=/url\((['"]?)([^'"]+?)\1\)/g,ia=/url\([^)]+\)\s*format\((["']?)([^"']+)\1\)/g,ja=/src:\s*(?:url\([^)]+\)\s*format\([^)]+\)[,;]\s*)+/g;function ka(a){const b=[];a.replace(Q,(d,c,e)=>{b.push(e);return d});return b.filter(d=>!H(d))}
function la(a,b,d,c){return t(function*(){try{const e=d?(new URL(b,d||void 0)).toString():b;let f;f=yield L(e,M[N(b).toLowerCase()]||"",c);return a.replace(new RegExp(`(url\\(['"]?)(${b.replace(/([.*+?^${}()|\[\]\/\\])/g,"\\$1")})(['"]?\\))`,"g"),`$1${f}$3`)}catch(e){}return a})}function ma(a,{I:b}){return b?a.replace(ja,d=>{for(;;){const [c,,e]=ia.exec(d)||[],f=c,g=e;if(!g)return"";if(g===b)return`src: ${f};`}}):a}
function R(a,b,d){return t(function*(){if(a.search(Q)===-1)return a;const c=ma(a,d);return ka(c).reduce((e,f)=>e.then(g=>la(g,f,b,d)),Promise.resolve(c))})};function S(a,b,d){return t(function*(){var c;const e=(c=b.style)==null?void 0:c.getPropertyValue(a);return e?(c=yield R(e,null,d),b.style.setProperty(a,c,b.style.getPropertyPriority(a)),!0):!1})}function na(a,b){return t(function*(){(yield S("background",a,b))||(yield S("background-image",a,b));(yield S("mask",a,b))||(yield S("-webkit-mask",a,b))||(yield S("mask-image",a,b))||(yield S("-webkit-mask-image",a,b))})}
function oa(a,b){return t(function*(){const d=E(a,HTMLImageElement);if(d&&!H(a.src)||E(a,SVGImageElement)&&!H(a.href.baseVal)){var c=d?a.src:a.href.baseVal,e=yield L(c,M[N(c).toLowerCase()]||"",b);yield new Promise((f,g)=>{a.onload=f;a.onerror=b.m?(...k)=>{try{f(b.m(...k))}catch(m){g(m)}}:g;a.decode&&(a.decode=f);a.loading==="lazy"&&(a.loading="eager");d?(a.srcset="",a.src=e):a.href.baseVal=e})}})}
function pa(a,b){return t(function*(){const d=w(a.childNodes).map(c=>T(c,b));yield Promise.all(d).then(()=>a)})}function T(a,b){return t(function*(){E(a,Element)&&(yield na(a,b),yield oa(a,b),yield pa(a,b))})};const U={};function V(a){return t(function*(){var b=U[a];if(b!=null)return b;b=yield(yield fetch(a)).text();b={url:a,cssText:b};return U[a]=b})}function W(a,b){return t(function*(){let d=a.cssText;const c=/url\(["']?([^"')]+)["']?\)/g,e=(d.match(/url\([^)]+\)/g)||[]).map(f=>t(function*(){let g=f.replace(c,"$1");g.startsWith("https://")||(g=(new URL(g,a.url)).href);return I(g,b.i,({result:k})=>{d=d.replace(f,`url(${k})`);return[f,k]})}));return Promise.all(e).then(()=>d)})}
function X(a){if(a==null)return[];const b=[];a=a.replace(/(\/\*[\s\S]*?\*\/)/gi,"");for(var d=RegExp("((@.*?keyframes [\\s\\S]*?){([\\s\\S]*?}\\s*?)})","gi");;){var c=d.exec(a);if(c===null)break;b.push(c[0])}a=a.replace(d,"");d=/@import[\s\S]*?url\([^)]*\)[\s\S]*?;/gi;for(c=RegExp("((\\s*?(?:\\/\\*[\\s\\S]*?\\*\\/)?\\s*?@media[\\s\\S]*?){([\\s\\S]*?)}\\s*?})|(([\\s\\S]*?){([\\s\\S]*?)})","gi");;){let e=d.exec(a);if(e===null)if(e=c.exec(a),e===null)break;else d.lastIndex=c.lastIndex;else c.lastIndex=
d.lastIndex;b.push(e[0])}return b}
function qa(a,b){return t(function*(){const d=[],c=[];a.forEach(e=>{if("cssRules"in e)try{w(e.cssRules||[]).forEach((f,g)=>{if(f.type===CSSRule.IMPORT_RULE){let k=g+1;f=V(f.href).then(m=>W(m,b)).then(m=>X(m).forEach(q=>{try{e.insertRule(q,q.startsWith("@import")?k+=1:e.cssRules.length)}catch(Da){}})).catch(()=>{});c.push(f)}})}catch(f){const g=a.find(k=>k.href==null)||document.styleSheets[0];e.href!=null&&c.push(V(e.href).then(k=>W(k,b)).then(k=>X(k).forEach(m=>{g.insertRule(m,g.cssRules.length)})).catch(()=>
{}))}});return Promise.all(c).then(()=>{a.forEach(e=>{if("cssRules"in e)try{w(e.cssRules||[]).forEach(f=>{d.push(f)})}catch(f){}});return d})})}function ra(a){return a.filter(b=>b.type===CSSRule.FONT_FACE_RULE).filter(b=>b.style.getPropertyValue("src").search(Q)!==-1)}function sa(a,b){return t(function*(){if(a.ownerDocument==null)throw Error("Provided element is not within a Document");var d=w(a.ownerDocument.styleSheets);d=yield qa(d,b);return ra(d)})}
function ta(a){function b(c){(c.style.fontFamily||getComputedStyle(c).fontFamily).split(",").forEach(e=>{d.add(e.trim().replace(/["']/g,""))});Array.from(c.children).forEach(e=>{e instanceof HTMLElement&&b(e)})}const d=new Set;b(a);return d}function ua(a,b){return t(function*(){const d=yield sa(a,b),c=ta(a);return(yield Promise.all(d.filter(e=>c.has(e.style.fontFamily.trim().replace(/["']/g,""))).map(e=>R(e.cssText,e.parentStyleSheet?e.parentStyleSheet.href:null,b)))).join("\n")})}
function va(a,b){return t(function*(){const d=b.j!=null?b.j:b.K?null:yield ua(a,b);if(d){const c=document.createElement("style");c.appendChild(document.createTextNode(d));a.firstChild?a.insertBefore(c,a.firstChild):a.appendChild(c)}})};function wa(a,b={}){return t(function*(){const {width:d,height:c}=A(a,b),e=yield P(a,b,!0);yield va(e,b);yield T(e,b);u(e,b);return yield D(e,d,c)})}
function xa(a,b={}){return t(function*(){const {width:d,height:c}=A(a,b);var e=yield wa(a,b);e=yield B(e);const f=document.createElement("canvas"),g=f.getContext("2d"),k=b.G||window.devicePixelRatio||1,m=b.h||d,q=b.g||c;f.width=m*k;f.height=q*k;!b.J&&(f.width>16384||f.height>16384)&&(f.width>16384&&f.height>16384?f.width>f.height?(f.height*=16384/f.width,f.width=16384):(f.width*=16384/f.height,f.height=16384):f.width>16384?(f.height*=16384/f.width,f.width=16384):(f.width*=16384/f.height,f.height=
16384));f.style.width=`${m}`;f.style.height=`${q}`;b.backgroundColor&&(g.fillStyle=b.backgroundColor,g.fillRect(0,0,f.width,f.height));g.drawImage(e,0,0,f.width,f.height);return f})}function ya(a,b={}){return t(function*(){return(yield xa(a,b)).toDataURL()})};const za=["gemini.google.com","corp.google.com","proxy.googlers.com"];function Y(){return document.body.querySelectorAll('[class*="animate"]').length>0}function Z(a){return t(function*(){try{return yield ya(a,{h:a.offsetWidth,g:a.offsetHeight})}catch(d){var b=a.offsetHeight;const c=document.createElement("canvas");c.width=a.offsetWidth;c.height=b;return c.toDataURL("image/png")}})}
function Aa(){return t(function*(){const a=document.body.offsetWidth,b=document.body.offsetHeight,d=document.body.cloneNode(!0);d.querySelectorAll('[class*="animate"]').forEach(c=>{c.classList.remove(...Array.from(c.classList).filter(e=>e.startsWith("animate")))});d.style.width=`${a}px`;d.style.height=`${b}px`;return d})}
function Ba(a){return t(function*(){let b=document.body;if(Y()){var d=yield Aa();b=d;document.body.appendChild(d)}d=yield Z(b);Y()&&document.body.removeChild(b);window.parent.postMessage({type:"SEND_SCREENSHOT",image:d,topOffset:document.documentElement.scrollTop},a.origin)})}function Ca(a){return t(function*(){const b={type:"SEND_SCREENSHOT_FOR_DATA_VISUALIZATION",image:yield Z(document.body),topOffset:0};window.parent.postMessage(b,a.origin)})}
window.addEventListener("message",a=>t(function*(){if(za.some(d=>a.origin.includes(d))){var b=a.data;b&&(b.type==="MAKE_SCREENSHOT"&&(yield Ba(a)),b.type==="MAKE_SCREENSHOT_FOR_DATA_VISUALIZATION"&&(yield Ca(a)))}}));
</script><script>(function() {
  // Ensure this script is executed only once
  if (window.firebaseAuthBridgeScriptLoaded) {
    return;
  }
  window.firebaseAuthBridgeScriptLoaded = true;

  let nextTokenPromiseId = 0;

  // Stores { resolve, reject } for ongoing token requests
  const pendingTokenPromises = {};

  // Listen for messages from the Host Application
  window.addEventListener('message', function(event) {

    const messageData = event.data;

  if (messageData && messageData.type === 'RESOLVE_NEW_FIREBASE_TOKEN') {
      const { success, token, error, promiseId } = messageData ?? {};
      if (pendingTokenPromises[promiseId]) {
        if (success) {
          pendingTokenPromises[promiseId].resolve(token);
        } else {
          pendingTokenPromises[promiseId].reject(new Error(error || 'Token refresh failed from host.'));
        }
        delete pendingTokenPromises[promiseId];
      }
    }
  });

  // Expose a function for the Generated App to request a new Firebase token
  window.requestNewFirebaseToken = function() {
    const currentPromiseId = nextTokenPromiseId++;
    const promise = new Promise((resolve, reject) => {
      pendingTokenPromises[currentPromiseId] = { resolve, reject };
    });
    if (window.parent && window.parent !== window) {
      window.parent.postMessage({
        type: 'REQUEST_NEW_FIREBASE_TOKEN',
        promiseId: currentPromiseId
      }, '*');
    } else {
      pendingTokenPromises[currentPromiseId].reject(new Error('No parent window to request token from.'));
      delete pendingTokenPromises[currentPromiseId];
    }
    return promise;
  };
})();</script><script>
let realOriginalGetUserMedia = null;
if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
  realOriginalGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
}

(function() {
  if (navigator.mediaDevices && navigator.mediaDevices.__proto__) {
    try {
      Object.defineProperty(navigator.mediaDevices.__proto__, 'getUserMedia', {
        get: function() {
          return undefined; // Or throw an error
        },
        configurable: false
      });
    } catch (error) {
      console.error("Error defining prototype getter:", error);
    }
  }
})();

(function() {
  const pendingMediaResolvers = {};
  let nextMediaPromiseId = 0;

  function requestMediaPermissions(constraints) {
    const mediaPromiseId = nextMediaPromiseId++;
    const promise = new Promise((resolve, reject) => {
      pendingMediaResolvers[mediaPromiseId] = (granted) => {
        delete pendingMediaResolvers[mediaPromiseId];
        resolve(granted);
      };
    });

    window.parent.postMessage({
      type: 'requestMediaPermission',
      constraints: constraints,
      promiseId: mediaPromiseId,
    }, '*');

    return promise;
  }

  let originalGetUserMedia = realOriginalGetUserMedia;

  function interceptGetUserMedia() {
    if (navigator.mediaDevices) {
      Object.defineProperty(navigator.mediaDevices, 'getUserMedia', {
        value: function(constraints) {
          return requestMediaPermissions(constraints).then((granted) => {
            if (granted) {
              if (originalGetUserMedia) {
                return originalGetUserMedia(constraints);
              } else {
                throw new Error("Original getUserMedia not available.");
              }
            } else {
              throw new DOMException('Permission denied', 'NotAllowedError');
            }
          });
        },
        writable: false,
        configurable: false
      });
    }
  }

  interceptGetUserMedia();

  const observer = new MutationObserver(function(mutationsList, observer) {
    for (const mutation of mutationsList) {
      if (mutation.type === 'reconfigured' && mutation.name === 'getUserMedia' && mutation.object === navigator.mediaDevices) {
        interceptGetUserMedia();
      } else if (mutation.type === 'attributes' && mutation.attributeName === 'getUserMedia' && mutation.target === navigator.mediaDevices) {
        interceptGetUserMedia();
      } else if (mutation.type === 'childList' && mutation.addedNodes) {
        mutation.addedNodes.forEach(node => {
          if (node === navigator.mediaDevices) {
            interceptGetUserMedia();
          }
        });
      }
    }
  });

  function interceptSpeechRecognition() {
    if (!window.SpeechRecognition && !window.webkitSpeechRecognition) {
      return;
    }

    const OriginalSpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

    const SpeechRecognitionWrapper = function(...args) {
      const recognizer = new OriginalSpeechRecognition(...args);
      const originalStart = recognizer.start.bind(recognizer);

      recognizer.start = function() {
        requestMediaPermissions({ audio: true }).then(granted => {
          if (granted) {
            originalStart();
          } else {
            const errorEvent = new SpeechRecognitionErrorEvent('error');
            errorEvent.error = 'not-allowed'; // This is the standard error for permission denial.
            recognizer.dispatchEvent(errorEvent);
          }
        });
      };

      return recognizer;
    };

    SpeechRecognitionWrapper.prototype = OriginalSpeechRecognition.prototype;
    SpeechRecognitionWrapper.prototype.constructor = SpeechRecognitionWrapper;

    if (window.SpeechRecognition) {
      window.SpeechRecognition = SpeechRecognitionWrapper;
    }
    if (window.webkitSpeechRecognition) {
      window.webkitSpeechRecognition = SpeechRecognitionWrapper;
    }
  }

  interceptSpeechRecognition();

  window.addEventListener('message', function(event) {
    if (event.data) {
      if (event.data.type === 'resolveMediaPermission') {
        const { promiseId, granted } = event.data;
        if (pendingMediaResolvers[promiseId]) {
          pendingMediaResolvers[promiseId](granted);
        }
      }
    }
  });

})();</script><script>((function(modelInformation) {
  const originalFetch = window.fetch;
  // TODO: b/421908508 - Move these out of the script and match all generative AI model calls.
  let googleLlmBaseApiUrls = [
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.textModelName + ':streamGenerateContent',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.textModelName + ':generateContent',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.imageModelName + ':predict',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.imageModelName + ':predictLongRunning',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.imageEditModelName + ':generateContent',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.imageTransformModelName + ':generateContent',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.videoModelName + ':predict',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.videoModelName + ':predictLongRunning',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.ttsModelName + ':generateContent',
  ];
  modelInformation.deprecatedTextModelNames.forEach((modelName) => {
    googleLlmBaseApiUrls.push(
      'https://generativelanguage.googleapis.com/v1beta/models/' + modelName + ':streamGenerateContent',
      'https://generativelanguage.googleapis.com/v1beta/models/' + modelName + ':generateContent',
    );
  });
  modelInformation.deprecatedImageModelNames.forEach((modelName) => {
    googleLlmBaseApiUrls.push(
      'https://generativelanguage.googleapis.com/v1beta/models/' + modelName + ':predict',
      'https://generativelanguage.googleapis.com/v1beta/models/' + modelName + ':predictLongRunning',
    );
  });

  const pendingFetchResolvers = {};
  let nextPromiseId = 0;

  function handleStringInput(input, optionsArgument) {
    const actualUrl = input;
    const fetchCallArgs = [actualUrl, optionsArgument];
    const effectiveOptions = optionsArgument || {};
    const bodyForApiKeyCheck = effectiveOptions.body;
    const bodyForPostMessage = effectiveOptions.body;
    return { actualUrl, fetchCallArgs, effectiveOptions, bodyForApiKeyCheck, bodyForPostMessage };
  }

  function handleRequestInput(input, optionsArgument) {
    const actualUrl = input.url;
    const fetchCallArgs = [input, optionsArgument];
    const effectiveOptions = { method: input.method, headers: new Headers(input.headers) };
    let bodyForApiKeyCheck;
    let bodyForPostMessage;

    if (optionsArgument) {
      if (optionsArgument.method) effectiveOptions.method = optionsArgument.method;
      if (optionsArgument.headers) effectiveOptions.headers = new Headers(optionsArgument.headers);
      if ('body' in optionsArgument) {
        bodyForApiKeyCheck = optionsArgument.body;
        bodyForPostMessage = optionsArgument.body;
      } else {
        bodyForApiKeyCheck = undefined;
        bodyForPostMessage = input.body;
      }
    } else {
      bodyForApiKeyCheck = undefined;
      bodyForPostMessage = input.body;
    }
    return { actualUrl, fetchCallArgs, effectiveOptions, bodyForApiKeyCheck, bodyForPostMessage };
  }

  window.fetch = function(input, optionsArgument) {
    let actualUrl;
    let fetchCallArgs;
    let effectiveOptions = {};
    let bodyForApiKeyCheck;
    let bodyForPostMessage;

    if (typeof input === 'string') {
      ({actualUrl, fetchCallArgs, effectiveOptions, bodyForApiKeyCheck, bodyForPostMessage} = handleStringInput(input, optionsArgument));
    } else if (input instanceof Request) {
      ({actualUrl, fetchCallArgs, effectiveOptions, bodyForApiKeyCheck, bodyForPostMessage} = handleRequestInput(input, optionsArgument));
    } else {
      return originalFetch.apply(window, [input, optionsArgument]);
    }

    effectiveOptions.method = effectiveOptions.method || 'GET';
    if (!effectiveOptions.headers) {
      effectiveOptions.headers = new Headers();
    }


    if (typeof actualUrl === 'string' && googleLlmBaseApiUrls.some((url) => actualUrl.startsWith(url))) {
      let apiKeyIsNull = true;

      const regex = new RegExp("models/([^:]+)");
      const modelNameMatch = actualUrl.match(regex);
      const modelName = modelNameMatch ? modelNameMatch[1] : 'unspecified';


      try {
        const urlObject = new URL(actualUrl);  // Use URL object for robust parsing
        const apiKeyParam = urlObject.searchParams.get('key');
        if (apiKeyParam) {
          apiKeyIsNull = false;
        }
      } catch (e) {
        // Continue checks even if URL parsing fails
      }

      if (apiKeyIsNull && effectiveOptions.headers) {
        const h = new Headers(effectiveOptions.headers);
        const apiKeyHeaderValue = h.get('X-API-Key') || h.get('x-api-key');
        if (apiKeyHeaderValue) {
          apiKeyIsNull = false;
          return originalFetch.apply(window, fetchCallArgs);
        }
      }

      if (apiKeyIsNull && effectiveOptions.method && ['POST', 'PUT', 'PATCH'].includes(effectiveOptions.method.toUpperCase()) && typeof bodyForApiKeyCheck === 'string') {
        try {
          const bodyData = JSON.parse(bodyForApiKeyCheck);
          if (bodyData && bodyData.apiKey) {
            apiKeyIsNull = false;
            return originalFetch.apply(window, fetchCallArgs);
          }
        } catch (e) {
          // Ignore JSON parsing errors
        }
      }

      if(apiKeyIsNull) {
        const promiseId = nextPromiseId++;
        const promise = new Promise((resolve) => {
          pendingFetchResolvers[promiseId] = (resolvedResponse) => {
            delete pendingFetchResolvers[promiseId];
            resolve(resolvedResponse);
          };
        });

        let serializedBodyForPostMessage;
        if (typeof bodyForPostMessage === 'string' || bodyForPostMessage == null) {
            serializedBodyForPostMessage = bodyForPostMessage;
        } else if (bodyForPostMessage instanceof ReadableStream) {
            serializedBodyForPostMessage = null;
        } else {
            try {
                serializedBodyForPostMessage = JSON.stringify(bodyForPostMessage);
            } catch (e) {
                serializedBodyForPostMessage = null;
            }
        }

        const messageOptions = {
            method: effectiveOptions.method,
            headers: Object.fromEntries(new Headers(effectiveOptions.headers).entries()),
            body: serializedBodyForPostMessage
        };

        window.parent.postMessage({
          type: 'requestFetch',
          url: actualUrl,
          modelName: modelName,
          options: messageOptions,
          promiseId: promiseId,
        }, '*');

        return promise;
      }
      return originalFetch.apply(window, fetchCallArgs);
    }
    return originalFetch.apply(window, fetchCallArgs);
  };

  window.addEventListener('message', function(event) {
    if (event.data && event.data.type === 'resolveFetch') {
      const { promiseId, response } = event.data;
      if (pendingFetchResolvers[promiseId]) {
        try {
          const reconstructedResponse = new Response(response.body, {
            status: response.status,
            statusText: response.statusText,
            headers: new Headers(response.headers),
          });
          pendingFetchResolvers[promiseId](reconstructedResponse);
        } catch (error) {
          pendingFetchResolvers[promiseId](new Response(null, { status: 500, statusText: "Interceptor Response Reconstruction Error" }));
        }
      }
    }
  });

}))({"textModelName":"gemini-2.5-flash-preview-09-2025","imageModelName":"imagen-4.0-generate-001","imageEditModelName":"gemini-2.5-flash-image-preview","imageTransformModelName":"gemini-3-pro-image-preview-11-2025","videoModelName":"veo-2.0-generate-001","ttsModelName":"gemini-2.5-flash-preview-tts","deprecatedTextModelNames":["gemini-2.0-flash","gemini-2.5-flash-preview-04-17","gemini-2.5-flash-preview-05-20"],"deprecatedImageModelNames":["imagen-3.0-generate-001","imagen-3.0-generate-002"]})</script><script>(function() {
  const originalConsoleLog = console.log;
  const originalConsoleError = console.error;

    /**
   * Normalizes an error event or a promise rejection reason into a structured error object.
   * @param {*} errorEventOrReason The error object or reason.
   * @return {object} Structured error data { message, name, stack }.
   */
  function getErrorObject(errorEventOrReason) {
    if (errorEventOrReason instanceof Error) {
      return {
        message: errorEventOrReason.message,
        name: errorEventOrReason.name,
        stack: errorEventOrReason.stack,
      };
    }
    // Fallback for non-Error objects.
    try {
      return {
        message: JSON.stringify(errorEventOrReason),
        name: 'UnknownErrorType',
        stack: null,
      };
    } catch (e) {
      return {
        message: String(errorEventOrReason),
        name: 'UnknownErrorTypeNonStringifiable',
        stack: null,
      };
    }
  }

  /**
   * Converts an array of arguments (from log/error) into a single string.
   * Handles Error objects specially to include their message and stack.
   * @param {Array<*>} args - Arguments passed to console methods.
   * @return {string} A string representation of the arguments.
   */
  function stringifyArgs(args) {
    return args
      .map((arg) => {
        if (arg instanceof Error) {
          const {message, stack} = arg;
          return `Error: ${message}${stack ? ('\nStack: ' + stack) : ''}`;
        }
        if (typeof arg === 'object' && arg !== null) {
          try {
            return JSON.stringify(arg);
          } catch (error) {
            return '[Circular Object]';
          }
        } else {
          return String(arg);
        }
      })
      .join(' ');
  }

  console.log = function(...args) {
    const logString = stringifyArgs(args);
    window.parent.postMessage({ type: 'log', message: logString }, '*');
    originalConsoleLog.apply(console, args);
  };

  console.error = function(...args) {
    let errorData;
    if (args.length > 0 && args[0] instanceof Error) {
      const err = args[0];
      // If the first arg is an Error, capture its details.
      errorData = {
        type: 'error',
        source: 'CONSOLE_ERROR',
        ...getErrorObject(err),
        rawArgsString: stringifyArgs(args.slice(1)),
        timestamp: new Date().toISOString(),
      };
    } else {
      // If not an Error object, treat all args as a general error message.
      errorData = {
        type: 'error',
        source: 'CONSOLE_ERROR',
        message: stringifyArgs(args),
        name: 'ConsoleLoggedError',
        stack: null,
        timestamp: new Date().toISOString(),
      };
    }
    window.parent.postMessage(errorData, '*');
    originalConsoleError.apply(console, args);
  };

  // Listen for global unhandled synchronous errors.
  window.addEventListener('error', function(event) {
    const errorDetails = event.error ? getErrorObject(event.error) : {
      message: event.message,
      name: 'GlobalError',
      stack: null,
      filename: event.filename,
      lineno: event.lineno,
      colno: event.colno,
    };

    window.parent.postMessage({
      type: 'error',
      source: 'global',
      ...errorDetails,
      message: errorDetails.message || event.message,
      timestamp: new Date().toISOString(),
    }, '*');
  });

  // Listen for unhandled promise rejections (asynchronous errors).
  window.addEventListener('unhandledrejection', function(event) {
    const errorDetails = getErrorObject(event.reason);

    window.parent.postMessage({
      type: 'error',
      source: 'unhandledrejection',
      ...errorDetails,
      message: errorDetails.message || 'Unhandled Promise Rejection',
      timestamp: new Date().toISOString(),
    }, '*');
  });

})();</script>
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <!-- Admin Config - Load before main script (for superadmin email) -->
    <script src="/admin-config.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Perforated panel Designer</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --primary: #2563eb;
            --primary-hover: #1d4ed8;
            --bg: #f1f5f9;
            --panel-bg: #ffffff;
            --text: #0f172a;
            --border: #e2e8f0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: var(--bg);
            color: var(--text);
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }
        
        /* Main content wrapper to account for header */
        .main-wrapper {
            display: flex;
            flex: 1;
            overflow: hidden;
            margin-top: 0;
        }

        /* Sidebar Layout */
        aside {
            width: 360px;
            background: var(--panel-bg);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            padding: 20px;
            overflow-y: auto;
            flex-shrink: 0;
            box-shadow: 4px 0 24px rgba(0,0,0,0.05);
            z-index: 10;
        }

        h1 {
            font-size: 1.25rem;
            margin-top: 0;
            margin-bottom: 20px;
            color: var(--primary);
            font-weight: 800;
        }

        h2 {
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #64748b;
            margin-top: 24px;
            margin-bottom: 12px;
            border-bottom: 1px solid var(--border);
            padding-bottom: 5px;
            font-weight: 700;
        }

        /* Form Elements */
        .control-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            font-size: 0.85rem;
            font-weight: 600;
            margin-bottom: 5px;
            color: #334155;
        }

        input[type="number"], 
        input[type="text"],
        select {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid #cbd5e1;
            border-radius: 6px;
            font-size: 0.9rem;
            box-sizing: border-box; 
            font-family: inherit;
        }
        
        select {
            background-color: white;
        }

        input[type="file"] {
            font-size: 0.85rem;
            width: 100%;
        }

        .row {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .row input {
            width: 100%;
        }

        .checkbox-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 10px;
            cursor: pointer;
        }
        
        input[type="checkbox"] {
            width: 16px; 
            height: 16px;
            margin: 0;
        }

        /* Lock Controls */
        .lock-wrapper {
            position: relative;
        }
        .lock-toggle {
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            width: 24px;
            height: 24px;
            border-radius: 4px;
            color: #cbd5e1;
        }
        .lock-toggle:hover {
            color: #94a3b8;
        }
        .lock-toggle input {
            display: none;
        }
        .lock-toggle input:checked + svg {
            fill: var(--primary);
            color: var(--primary);
        }
        .lock-icon {
            width: 16px;
            height: 16px;
            fill: currentColor;
        }

        /* Buttons */
        button {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
            font-size: 0.95rem;
            margin-top: 10px;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
            box-shadow: 0 4px 6px -1px rgba(37, 99, 235, 0.2);
        }

        .btn-primary:hover {
            background: var(--primary-hover);
        }

        .btn-secondary {
            background: white;
            border: 1px solid #cbd5e1;
            color: #334155;
            margin-top: 0;
        }

        .btn-secondary:hover {
            background: #f8fafc;
            border-color: #94a3b8;
        }
        
        .btn-secondary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .btn-small {
            padding: 6px 12px;
            font-size: 0.8rem;
            margin-top: 0;
            width: auto;
        }

        /* Stats Panel */
        #stats {
            background: #f0f9ff;
            border: 1px solid #bae6fd;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            display: none; /* Hidden by default */
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 0.9rem;
        }

        .stat-value {
            font-weight: 700;
            color: var(--primary);
        }
        
        .error-text {
            color: #ef4444;
            font-size: 0.75rem;
            margin-top: 4px;
            display: none;
        }

        /* Main Preview Area */
        main {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #cbd5e1; /* Darker background for contrast */
            position: relative;
            overflow: hidden; 
            cursor: grab;
        }
        
        main:active {
            cursor: grabbing;
        }
        
        /* Pattern Background behind canvas to show transparency if needed */
        main::before {
            content: "";
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            opacity: 0.1;
            background-image: radial-gradient(#64748b 1px, transparent 1px);
            background-size: 20px 20px;
            pointer-events: none;
            z-index: 0;
        }

        #canvas-container {
            /* Container doesn't scroll natively anymore, we use transform for pan */
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center; 
            align-items: center;
            z-index: 1;
            transform-origin: center;
        }

        canvas {
            display: block;
            background: white;
            box-shadow: 0 20px 50px -12px rgba(0, 0, 0, 0.25);
            /* Remove transition for direct pan control */
        }

        small {
            color: #64748b;
            font-size: 0.75rem;
            margin-top: 4px;
            display: block;
        }

        /* Floating Zoom Controls */
        .zoom-controls {
            position: absolute;
            bottom: 30px;
            right: 30px;
            display: flex;
            gap: 8px;
            background: white;
            padding: 8px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 20;
        }

        .zoom-btn {
            width: 40px;
            height: 40px;
            border-radius: 6px;
            background: #f1f5f9;
            color: #334155;
            border: 1px solid #e2e8f0;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0;
            padding: 0;
        }
        
        .zoom-btn:hover {
            background: #e2e8f0;
            color: #0f172a;
        }

        .zoom-btn svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }
        
        .sub-control-panel {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            padding: 10px;
            border-radius: 6px;
            margin-top: 5px;
        }
        
        /* Grid for Download Buttons */
        .download-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 20px;
        }
        
        .download-grid button {
            margin-top: 0;
        }

        .full-width {
            grid-column: span 2;
        }
        
        /* Download Toggle */
        .download-with-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .download-toggle {
            position: relative;
            width: 36px;
            height: 20px;
            background: #cbd5e1;
            border-radius: 10px;
            cursor: pointer;
            transition: background 0.2s;
            flex-shrink: 0;
        }
        
        .download-toggle.active {
            background: var(--primary);
        }
        
        .download-toggle::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: transform 0.2s;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        
        .download-toggle.active::after {
            transform: translateX(16px);
        }
        
        .download-toggle-label {
            font-size: 0.7rem;
            color: #64748b;
            margin-top: 2px;
        }
        
        /* Auth UI Styles - Using Tailwind, keeping modal styles */
        
        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            align-items: center;
            justify-content: center;
        }
        
        .modal.active {
            display: flex;
        }
        
        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 8px;
            max-width: 400px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .modal-header {
            margin-bottom: 20px;
        }
        
        .modal-header h2 {
            margin: 0;
            font-size: 1.5rem;
        }
        
        .modal-close {
            float: right;
            font-size: 1.5rem;
            cursor: pointer;
            color: #64748b;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9rem;
            font-weight: 600;
        }
        
        .form-group input {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--border);
            border-radius: 4px;
            font-size: 0.9rem;
            box-sizing: border-box;
        }
        
        .error-message {
            color: #ef4444;
            font-size: 0.8rem;
            margin-top: 5px;
            display: none;
        }
        
        .error-message.show {
            display: block;
        }
        
        .auth-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid var(--border);
        }
        
        .auth-tab {
            padding: 10px 20px;
            cursor: pointer;
            border: none;
            background: none;
            font-size: 0.9rem;
            color: #64748b;
            border-bottom: 2px solid transparent;
            margin-bottom: -2px;
        }
        
        .auth-tab.active {
            color: var(--primary);
            border-bottom-color: var(--primary);
            font-weight: 600;
        }
        
        .admin-panel {
            max-width: 800px;
            width: 90%;
        }
        
        .admin-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .stat-card {
            background: #f8fafc;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid var(--border);
        }
        
        .stat-card h3 {
            margin: 0 0 10px 0;
            font-size: 0.9rem;
            color: #64748b;
        }
        
        .stat-card .value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--primary);
        }
        
        .users-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        
        .users-table th,
        .users-table td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }
        
        .users-table th {
            background: #f8fafc;
            font-weight: 600;
        }
        
        /* Footer Styles */
        footer {
            position: fixed;
            bottom: 0;
            left: 360px; /* Account for sidebar width */
            right: 0;
            background: var(--panel-bg);
            border-top: 1px solid var(--border);
            padding: 10px 20px;
            z-index: 5;
            text-align: center;
            font-size: 0.85rem;
            color: #64748b;
            z-index: 100;
        }
        
        /* Slider Styles */
        .slider-container {
            margin-top: 10px;
        }
        
        .slider-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
            font-size: 0.85rem;
        }
        
        .slider-value {
            font-weight: 600;
            color: var(--primary);
            min-width: 40px;
            text-align: right;
        }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #e2e8f0;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        input[type="range"]:hover::-webkit-slider-thumb {
            background: var(--primary-hover);
        }
        
        input[type="range"]:hover::-moz-range-thumb {
            background: var(--primary-hover);
        }
        
        /* Alignment Controls */
        .alignment-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 4px;
            margin-top: 10px;
        }
        
        .align-btn {
            width: 100%;
            padding: 8px;
            border: 1px solid #cbd5e1;
            border-radius: 4px;
            background: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            transition: all 0.2s;
        }
        
        .align-btn:hover {
            background: #f1f5f9;
            border-color: var(--primary);
        }
        
        .align-btn.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }
        
        .align-btn svg {
            width: 18px;
            height: 18px;
            fill: currentColor;
        }
        
        .align-center {
            grid-column: 2;
            grid-row: 2;
        }
        
        .toggle-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 10px;
        }
        
        .toggle-switch {
            position: relative;
            width: 44px;
            height: 24px;
            background: #cbd5e1;
            border-radius: 12px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .toggle-switch.active {
            background: var(--primary);
        }
        
        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: transform 0.2s;
        }
        
        .toggle-switch.active::after {
            transform: translateX(20px);
        }

    </style>
</head>
<body>

<!-- Header with Auth -->
<header class="bg-white border-b border-gray-200 shadow-sm sticky top-0 z-50">
    <div class="max-w-full mx-auto px-4 sm:px-6 lg:px-8">
        <div class="flex justify-between items-center h-16">
            <!-- Logo/Title -->
            <div class="flex items-center">
                <h1 class="text-xl font-bold text-blue-600">Perforated panel Designer</h1>
    </div>

            <!-- Right Side: Actions & Auth -->
            <div class="flex items-center gap-3 ml-auto">
                <!-- Upload Photo -->
                <button onclick="document.getElementById('fileInput').click()" class="px-4 py-2 bg-gradient-to-r from-blue-500 to-blue-600 text-white rounded-lg hover:from-blue-600 hover:to-blue-700 transition-all text-sm font-medium flex items-center gap-2 shadow-sm hover:shadow">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
                    </svg>
                    Upload Photo
                </button>
                
                <!-- Import Settings -->
                <button onclick="document.getElementById('importFile').click()" class="px-4 py-2 bg-gradient-to-r from-gray-100 to-gray-200 text-gray-700 rounded-lg hover:from-gray-200 hover:to-gray-300 transition-all text-sm font-medium flex items-center gap-2 shadow-sm hover:shadow border border-gray-300">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path>
                    </svg>
                    Import Settings
                </button>
                
                <!-- Downloads Dropdown -->
                <div class="relative" id="downloadsMenuContainer">
                    <button onclick="toggleDownloadsMenu()" class="px-4 py-2 bg-gradient-to-r from-indigo-500 to-indigo-600 text-white rounded-lg hover:from-indigo-600 hover:to-indigo-700 transition-all text-sm font-medium flex items-center gap-2 shadow-sm hover:shadow">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path>
                        </svg>
                        Downloads
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                        </svg>
                    </button>
                    
                    <!-- Downloads Dropdown Menu -->
                    <div id="downloadsMenuDropdown" class="hidden absolute right-0 mt-2 w-52 bg-white rounded-lg shadow-xl border border-gray-200 py-1 z-50">
                        <button id="downloadImgBtn" onclick="window.downloadImage(); toggleDownloadsMenu();" class="w-full text-left px-4 py-2.5 text-sm text-gray-700 hover:bg-blue-50 hover:text-blue-700 transition-colors flex items-center gap-3" disabled>
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
                            </svg>
                            <span class="font-medium">Map (.png)</span>
                        </button>
                        <button id="downloadTxtBtn" onclick="window.downloadSpecs(); toggleDownloadsMenu();" class="w-full text-left px-4 py-2.5 text-sm text-gray-700 hover:bg-blue-50 hover:text-blue-700 transition-colors flex items-center gap-3" disabled>
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                            </svg>
                            <span class="font-medium">Settings (.txt)</span>
                        </button>
                        <button id="downloadDxfBtn" onclick="handleDownloadClick('dxf');" class="w-full text-left px-4 py-2.5 text-sm text-gray-700 hover:bg-blue-50 hover:text-blue-700 transition-colors flex items-center gap-3" disabled>
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                            </svg>
                            <span class="font-medium flex-1">CAD (.dxf)</span>
                            <svg id="dxfLockIcon" class="w-4 h-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" style="display:none;">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"></path>
                            </svg>
                        </button>
                        <button id="downloadSvgBtn" onclick="handleDownloadClick('svg');" class="w-full text-left px-4 py-2.5 text-sm text-gray-700 hover:bg-blue-50 hover:text-blue-700 transition-colors flex items-center gap-3" disabled>
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                            </svg>
                            <span class="font-medium flex-1">Vector (.svg)</span>
                            <svg id="svgLockIcon" class="w-4 h-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" style="display:none;">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"></path>
                            </svg>
                        </button>
                        <button id="downloadShareableBtn" onclick="downloadShareableHTML(); toggleDownloadsMenu();" class="hidden w-full text-left px-4 py-2.5 text-sm text-gray-700 hover:bg-blue-50 hover:text-blue-700 transition-colors flex items-center gap-3" disabled>
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.368 2.684 3 3 0 00-5.368-2.684z"></path>
                            </svg>
                            <span class="font-medium">Shareable File (.html)</span>
                        </button>
                        <button id="downloadZipBtn" onclick="handleDownloadClick('zip');" class="w-full text-left px-4 py-2.5 text-sm text-gray-700 hover:bg-blue-50 hover:text-blue-700 transition-colors flex items-center gap-3" disabled>
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                            </svg>
                            <span class="font-medium flex-1">All Files (.zip)</span>
                            <svg id="zipLockIcon" class="w-4 h-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" style="display:none;">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"></path>
                            </svg>
                        </button>
                    </div>
                </div>
                
                <!-- Auth Section -->
                <div class="flex items-center gap-3 border-l border-gray-300 pl-3 ml-3">
                    <!-- Guest User - Login Button -->
                    <div id="guestInfo" class="flex items-center gap-3">
                        <button onclick="showAuthModal()" class="px-4 py-2 bg-gradient-to-r from-green-500 to-green-600 text-white rounded-lg hover:from-green-600 hover:to-green-700 transition-all text-sm font-medium shadow-sm hover:shadow">
                            Login / Register
                        </button>
                    </div>
                    
                    <!-- Logged In User - User Menu -->
                    <div id="userInfo" class="hidden flex items-center gap-3">
                        <span id="userEmail" class="text-sm text-gray-600 hidden sm:inline font-medium"></span>
                        
                        <!-- User Icon Dropdown -->
                        <div class="relative" id="userMenuContainer">
                            <button onclick="toggleUserMenu()" class="flex items-center gap-2 p-2 rounded-full hover:bg-gray-100 transition-colors border border-gray-300" id="userMenuButton">
                                <svg class="w-5 h-5 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path>
                                </svg>
                            </button>
                            
                            <!-- Dropdown Menu -->
                            <div id="userMenuDropdown" class="hidden absolute right-0 mt-2 w-48 bg-white rounded-lg shadow-xl border border-gray-200 py-1 z-50">
                                <a href="#" onclick="showChangePasswordModal(); return false;" class="block px-4 py-2.5 text-sm text-gray-700 hover:bg-blue-50 hover:text-blue-700 transition-colors flex items-center gap-3">
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 7a2 2 0 012 2m4 0a6 6 0 01-7.743 5.743L11 17H9v2H7v2H4a1 1 0 01-1-1v-2.586a1 1 0 01.293-.707l5.964-5.964A6 6 0 1121 9z"></path>
                                    </svg>
                                    <span class="font-medium">Change Password</span>
                                </a>
                                <a id="adminPanelLink" href="/adminpanel" class="hidden block px-4 py-2.5 text-sm text-gray-700 hover:bg-purple-50 hover:text-purple-700 transition-colors flex items-center gap-3 border-t border-gray-200 mt-1 pt-1">
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z"></path>
                                    </svg>
                                    <span class="font-medium">Admin Panel</span>
                                </a>
                                <a href="#" onclick="authManager.signOut(); return false;" class="block px-4 py-2.5 text-sm text-gray-700 hover:bg-red-50 hover:text-red-700 transition-colors flex items-center gap-3 border-t border-gray-200 mt-1 pt-1">
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1"></path>
                                    </svg>
                                    <span class="font-medium">Logout</span>
                                </a>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Admin Button -->
                    <button id="adminBtn" onclick="showAdminPanel()" class="hidden px-4 py-2 bg-gradient-to-r from-purple-500 to-purple-600 text-white rounded-lg hover:from-purple-600 hover:to-purple-700 transition-all text-sm font-medium shadow-sm hover:shadow">
                        Admin Panel
                    </button>
                </div>
            </div>
        </div>
    </div>
</header>

        <!-- Change Password Modal -->
<div id="changePasswordModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2>Change Password</h2>
            <span class="modal-close" onclick="closeChangePasswordModal()">&times;</span>
        </div>
        <div class="form-group" id="currentPasswordGroup">
            <label id="currentPasswordLabel">Current Password</label>
            <input type="password" id="currentPassword" placeholder="Enter current password">
        </div>
        <div class="form-group">
            <label>New Password</label>
            <input type="password" id="newPassword" placeholder="Min 6 characters">
        </div>
        <div class="form-group">
            <label>Confirm New Password</label>
            <input type="password" id="confirmPassword" placeholder="Confirm new password">
        </div>
        <div class="error-message" id="changePasswordError"></div>
        <div class="error-message" id="changePasswordSuccess" style="color:green;"></div>
        <button class="btn-primary" style="width:100%; margin-top:10px;" onclick="handleChangePassword()">Change Password</button>
        <button class="btn-secondary" style="width:100%; margin-top:10px;" onclick="closeChangePasswordModal()">Cancel</button>
    </div>
</div>

        <!-- Auth Modal -->
<div id="authModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2>Authentication</h2>
            <span class="modal-close" onclick="closeAuthModal()">&times;</span>
        </div>
        <div class="auth-tabs">
            <button class="auth-tab active" onclick="switchAuthTab('login')">Login</button>
            <button class="auth-tab" onclick="switchAuthTab('register')">Register</button>
        </div>
        <div id="loginForm">
            <div class="form-group">
                <label>Email</label>
                <input type="email" id="loginEmail" placeholder="your@email.com">
            </div>
            <div class="form-group">
                <label>Password</label>
                <input type="password" id="loginPassword" placeholder="Password">
            </div>
            <div class="error-message" id="loginError"></div>
            <button class="btn-primary" style="width:100%; margin-top:10px;" onclick="handleLogin()">Login</button>
            <button class="btn-secondary" style="width:100%; margin-top:10px;" onclick="handleGoogleLogin()">Login with Google</button>
            <button class="link-btn" style="width:100%; margin-top:10px; text-align:center;" onclick="switchAuthTab('forgot')">Forgot Password?</button>
        </div>
        <div id="registerForm" style="display:none;">
            <div class="form-group">
                <label>Email</label>
                <input type="email" id="registerEmail" placeholder="your@email.com">
            </div>
            <div class="form-group">
                <label>Password</label>
                <input type="password" id="registerPassword" placeholder="Min 6 characters">
            </div>
            <div class="error-message" id="registerError"></div>
            <button class="btn-primary" style="width:100%; margin-top:10px;" onclick="handleRegister()">Register</button>
            <button class="btn-secondary" style="width:100%; margin-top:10px;" onclick="handleGoogleLogin()">Register with Google</button>
        </div>
        <div id="forgotForm" style="display:none;">
            <div class="form-group">
                <label>Email</label>
                <input type="email" id="forgotEmail" placeholder="your@email.com">
            </div>
            <div class="error-message" id="forgotError"></div>
            <div class="error-message" id="forgotSuccess" style="color:green;"></div>
            <button class="btn-primary" style="width:100%; margin-top:10px;" onclick="handleForgotPassword()">Send Reset Link</button>
            <button class="link-btn" style="width:100%; margin-top:10px; text-align:center;" onclick="switchAuthTab('login')">Back to Login</button>
        </div>
    </div>
</div>

<!-- Admin Panel Modal -->
<div id="adminModal" class="modal">
    <div class="modal-content admin-panel">
        <div class="modal-header">
            <h2>Admin Panel</h2>
            <span class="modal-close" onclick="closeAdminPanel()">&times;</span>
        </div>
        <div id="adminLoginForm">
            <div class="form-group">
                <label>Admin Username</label>
                <input type="text" id="adminUsername" placeholder="Username">
            </div>
            <div class="form-group">
                <label>Admin Password</label>
                <input type="password" id="adminPassword" placeholder="Password">
            </div>
            <div class="error-message" id="adminLoginError"></div>
            <button class="btn-primary" style="width:100%;" onclick="handleAdminLogin()">Login</button>
        </div>
        <div id="adminPanelContent" style="display:none;">
            <div class="admin-stats">
                <div class="stat-card">
                    <h3>Total Users</h3>
                    <div class="value" id="totalUsers">0</div>
                </div>
                <div class="stat-card">
                    <h3>Total Downloads</h3>
                    <div class="value" id="totalDownloads">0</div>
                </div>
                <div class="stat-card">
                    <h3>Downloads Today</h3>
                    <div class="value" id="downloadsToday">0</div>
                </div>
            </div>
            <h3>Users</h3>
            <table class="users-table">
                <thead>
                    <tr>
                        <th>Email</th>
                        <th>Downloads</th>
                        <th>Last Login</th>
                    </tr>
                </thead>
                <tbody id="usersTableBody">
                </tbody>
            </table>
        </div>
    </div>
</div>

<!-- Main Content Wrapper -->
<div class="main-wrapper">
<!-- Hidden file inputs for navbar buttons -->
<input type="file" id="fileInput" accept="image/*" style="display:none">
<input type="file" id="importFile" accept=".txt" style="display:none">

<aside>
    <div style="margin-bottom:20px;">
        <h2 style="margin:0; font-size:1.2rem;">Design Controls</h2>
    </div>
    
    <div class="control-group sub-control-panel">
        <label style="margin-bottom:8px">Project Name</label>
        <input type="text" id="projectName" placeholder="Enter project name" style="width:100%; padding:6px; margin-bottom:8px; border:1px solid #e2e8f0; border-radius:4px;">
    </div>
    
    <div class="control-group sub-control-panel">
        <label style="margin-bottom:8px">Image Fit &amp; Placement</label>
        <select id="imgFitMode" style="margin-bottom:8px">
            <option value="stretch">Stretch to Fit (Default)</option>
            <option value="ratio">Keep Ratio (Center)</option>
        </select>
        
        <div id="imgPlacementControls" style="display:none;">
            <div class="row" style="margin-bottom:5px">
                <div>
                    <label style="font-size:0.75rem;">Scale (x)</label>
                    <input type="number" id="imgScale" value="1.0" step="0.1">
                </div>
            </div>
            <div class="row">
                <div>
                    <label style="font-size:0.75rem;">Pan X (mm)</label>
                    <input type="number" id="imgPanX" value="0">
                </div>
                <div>
                    <label style="font-size:0.75rem;">Pan Y (mm)</label>
                    <input type="number" id="imgPanY" value="0">
                </div>
            </div>
        </div>
    </div>

    <h2>Global Geometry (mm)</h2>
    <div class="control-group">
        <label class="checkbox-row" style="margin-bottom: 12px; color: var(--primary); background: #eff6ff; padding: 8px; border-radius: 4px;">
            <input type="checkbox" id="lockRatio" checked="">
            <span>Link Dimensions to Image Ratio</span>
        </label>

        <div class="row">
            <div>
                <label>Total Width</label>
                <input type="number" id="panelW" value="1000">
            </div>
            <div>
                <label>Total Height</label>
                <input type="number" id="panelH" value="2000">
            </div>
        </div>
        <small id="ratioDisplay" style="margin-top:5px; font-style: italic;"></small>
    </div>
    
    <h2>Sheet Layout (Subdivision)</h2>
    <div class="control-group">
        <label>Split Logic</label>
        <select id="splitMode">
            <option value="strict">Strict (Show Error if mismatch)</option>
            <option value="fill">Fill Remainder (Auto-add panel)</option>
            <option value="update">Update Total (Resize Global)</option>
        </select>
    </div>

    <div class="control-group">
        <label>Vertical Splits (Left-to-Right)</label>
        <input type="text" id="splitW" placeholder="e.g. 1000, 1000">
        <div id="errSplitW" class="error-text"></div>
    </div>
    <div class="control-group">
        <label>Horizontal Splits (Top-to-Bottom)</label>
        <input type="text" id="splitH" placeholder="e.g. 2000">
        <div id="errSplitH" class="error-text"></div>
    </div>
    
    <h2>Margins Per Sheet (mm)</h2>
    <div class="control-group">
         <div class="row">
            <div>
                <label>Top/Bottom</label>
                <input type="number" id="marginTop" value="20" placeholder="T">
                <input type="number" id="marginBottom" value="20" placeholder="B" style="margin-top:5px">
            </div>
            <div>
                <label>Left/Right</label>
                <input type="number" id="marginLeft" value="20" placeholder="L">
                <input type="number" id="marginRight" value="20" placeholder="R" style="margin-top:5px">
            </div>
        </div>
        <small>Safe zone applied to each split.</small>
    </div>

    <h2>Perforation Specs (mm)</h2>
    <div class="control-group">
        <div class="row">
            <div>
                <label>Min Hole </label>
                <input type="number" id="minHole" value="2">
            </div>
            <div>
                <label>Max Hole </label>
                <input type="number" id="maxHole" value="18">
            </div>
        </div>
    </div>

    <div class="control-group">
        <label>Spacing Control</label>
        <div class="row">
            <div style="flex:1">
                <div style="display:flex; justify-content:space-between; align-items:center;">
                    <label style="font-size:0.75rem; color:#64748b; margin:0;">Pitch (C-C)</label>
                    <label class="lock-toggle" title="Lock Pitch">
                        <input type="radio" name="lockMode" id="lockPitch" checked="">
                        <svg class="lock-icon" viewBox="0 0 24 24"><path d="M12 17c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm6-9h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zM9 6c0-1.66 1.34-3 3-3s3 1.34 3 3v2H9V6z"></path></svg>
                    </label>
                </div>
                <input type="number" id="pitch" value="20" min="1">
            </div>
            
            <div style="text-align:center; padding-top:18px; color:#94a3b8; font-size:0.8rem;">=</div>
            
            <div style="flex:1">
                <div style="display:flex; justify-content:space-between; align-items:center;">
                    <label style="font-size:0.75rem; color:#64748b; margin:0;">Gap (Edge)</label>
                    <label class="lock-toggle" title="Lock Gap">
                        <input type="radio" name="lockMode" id="lockGap">
                        <svg class="lock-icon" viewBox="0 0 24 24"><path d="M12 17c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm6-9h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zM9 6c0-1.66 1.34-3 3-3s3 1.34 3 3v2H9V6z"></path></svg>
                    </label>
                </div>
                <input type="number" id="edgeGap" value="2">
            </div>
        </div>
    </div>

    <div class="control-group">
        <label class="checkbox-row">
            <input type="checkbox" id="invertColors">
            <span>Invert (Darker = Smaller Hole)</span>
        </label>
    </div>
    
    <h2>Panel Alignment</h2>
    <div class="control-group">
        <label>Hole Pattern Alignment</label>
        <div class="alignment-controls">
            <button class="align-btn" data-align="top-left" title="Top Left">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="12" y1="2" x2="12" y2="8"/>
                    <polyline points="8 6 12 2 16 6"/>
                    <line x1="2" y1="12" x2="8" y2="12"/>
                    <polyline points="6 8 2 12 6 16"/>
                </svg>
            </button>
            <button class="align-btn" data-align="top" title="Top">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="12" y1="2" x2="12" y2="8"/>
                    <polyline points="8 6 12 2 16 6"/>
                </svg>
            </button>
            <button class="align-btn" data-align="top-right" title="Top Right">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="12" y1="2" x2="12" y2="8"/>
                    <polyline points="8 6 12 2 16 6"/>
                    <line x1="16" y1="12" x2="22" y2="12"/>
                    <polyline points="18 8 22 12 18 16"/>
                </svg>
            </button>
            <button class="align-btn" data-align="left" title="Left">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="2" y1="12" x2="8" y2="12"/>
                    <polyline points="6 8 2 12 6 16"/>
                </svg>
            </button>
            <button class="align-btn align-center active" data-align="center" title="Center">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="3"/>
                </svg>
            </button>
            <button class="align-btn" data-align="right" title="Right">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="16" y1="12" x2="22" y2="12"/>
                    <polyline points="18 8 22 12 18 16"/>
                </svg>
            </button>
            <button class="align-btn" data-align="bottom-left" title="Bottom Left">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="12" y1="16" x2="12" y2="22"/>
                    <polyline points="8 18 12 22 16 18"/>
                    <line x1="2" y1="12" x2="8" y2="12"/>
                    <polyline points="6 8 2 12 6 16"/>
                </svg>
            </button>
            <button class="align-btn" data-align="bottom" title="Bottom">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="12" y1="16" x2="12" y2="22"/>
                    <polyline points="8 18 12 22 16 18"/>
                </svg>
            </button>
            <button class="align-btn" data-align="bottom-right" title="Bottom Right">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="12" y1="16" x2="12" y2="22"/>
                    <polyline points="8 18 12 22 16 18"/>
                    <line x1="16" y1="12" x2="22" y2="12"/>
                    <polyline points="18 8 22 12 18 16"/>
                </svg>
            </button>
        </div>
        <small>Adjust starting point for hole pattern in each panel</small>
    </div>
    
    <h2>Display Options</h2>
    <div class="control-group">
        <div class="toggle-group">
            <label style="margin:0; flex:1;">Show Opening % on Panels</label>
            <div class="toggle-switch" id="showPercentageToggle"></div>
        </div>
        <div class="slider-container" id="percentageSizeContainer" style="display:none;">
            <div class="slider-label">
                <label style="margin:0;">Text Size</label>
                <span class="slider-value" id="percentageSizeValue">100%</span>
            </div>
            <input type="range" id="percentageSizeSlider" min="50" max="1000" value="100" step="10">
        </div>
        <small>Display opening percentage overlay on each subdivided panel</small>
    </div>
    <div class="control-group">
        <div class="toggle-group">
            <label style="margin:0; flex:1;">Include Footer Statistics in Downloads</label>
            <div class="toggle-switch" id="includeFooterStatsToggle"></div>
        </div>
        <small>Add panel count, hole count, and opening percentage below the image in downloaded files</small>
    </div>

    <button id="generateBtn" class="btn-primary">Generate Pattern</button>
    
    <div id="stats">
        <div class="stat-item">
            <span>Hole Count:</span>
            <span class="stat-value" id="statCount">0</span>
        </div>
        <div class="stat-item">
            <span>Open Area:</span>
            <span class="stat-value" id="statArea">0%</span>
        </div>
        <div class="stat-item" id="warningMsg" style="display:none; color: #ef4444; margin-top:5px; font-size:0.8rem;">
            Warning: High hole count. Rendering might be slow.
        </div>
    </div>
    
</aside>

<main id="mainViewport" style="cursor: grab; flex: 1;">
    <div id="canvas-container">
        <canvas id="previewCanvas"></canvas>
    </div>
    
    <!-- Zoom Controls -->
    <div class="zoom-controls">
        <button class="zoom-btn" id="zoomOut" title="Zoom Out">-</button>
        <button class="zoom-btn" id="zoomFit" title="Zoom Extent (Fit)">
            <svg viewBox="0 0 24 24"><path d="M4 4h6v2H6v4H4V4zm10 0h6v6h-2V6h-4V4zm6 10h-2v4h-4v2h6v-6zM4 14h2v4h4v2H4v-6z"></path></svg>
        </button>
        <button class="zoom-btn" id="zoomIn" title="Zoom In">+</button>
    </div>
</main>

<script>
    // State
    const CONFIG = {
        baseScale: 2, // Desired Pixels per MM
        maxCanvasDimension: 4096 // Hard limit
    };
    
    let sourceImage = null;
    let imageAspectRatio = 0;
    
    // Unique ID for current generation
    let currentFileID = null;

    // Viewport State
    let scale = 1;
    let panX = 0;
    let panY = 0;
    let isDragging = false;
    let dragStartX = 0;
    let dragStartY = 0;

    // Elements
    const canvas = document.getElementById('previewCanvas');
    const mainViewport = document.getElementById('mainViewport');
    const container = document.getElementById('canvas-container'); // Holds the canvas, is transformed
    const ctx = canvas.getContext('2d');
    
    const fileInput = document.getElementById('fileInput');
    const importFile = document.getElementById('importFile');
    const generateBtn = document.getElementById('generateBtn');
    
    const downloadImgBtn = document.getElementById('downloadImgBtn');
    const downloadTxtBtn = document.getElementById('downloadTxtBtn');
    const downloadDxfBtn = document.getElementById('downloadDxfBtn');
    const downloadSvgBtn = document.getElementById('downloadSvgBtn');
    const downloadZipBtn = document.getElementById('downloadZipBtn');
    
    const statsPanel = document.getElementById('stats');
    const ratioDisplay = document.getElementById('ratioDisplay');
    const lockRatioCheckbox = document.getElementById('lockRatio');
    const warningMsg = document.getElementById('warningMsg');
    
    const lockPitchRadio = document.getElementById('lockPitch');
    const lockGapRadio = document.getElementById('lockGap');
    
    // New Elements
    const imgFitMode = document.getElementById('imgFitMode');
    const imgPlacementControls = document.getElementById('imgPlacementControls');
    const splitMode = document.getElementById('splitMode');
    const errSplitW = document.getElementById('errSplitW');
    const errSplitH = document.getElementById('errSplitH');
    
    // Zoom Buttons
    const btnZoomIn = document.getElementById('zoomIn');
    const btnZoomOut = document.getElementById('zoomOut');
    const btnZoomFit = document.getElementById('zoomFit');
    
    // Alignment and Display Controls
    const alignmentButtons = document.querySelectorAll('.align-btn');
    const showPercentageToggle = document.getElementById('showPercentageToggle');
    const includeFooterStatsToggle = document.getElementById('includeFooterStatsToggle');
    const percentageSizeSlider = document.getElementById('percentageSizeSlider');
    const percentageSizeValue = document.getElementById('percentageSizeValue');
    const percentageSizeContainer = document.getElementById('percentageSizeContainer');

    // Project Name
    const projectNameInput = document.getElementById('projectName');
    
    // Inputs
    const inputs = {
        w: document.getElementById('panelW'),
        h: document.getElementById('panelH'),
        pitch: document.getElementById('pitch'),
        edge: document.getElementById('edgeGap'),
        min: document.getElementById('minHole'),
        max: document.getElementById('maxHole'),
        invert: document.getElementById('invertColors'),
        splitW: document.getElementById('splitW'),
        splitH: document.getElementById('splitH'),
        mT: document.getElementById('marginTop'),
        mB: document.getElementById('marginBottom'),
        mL: document.getElementById('marginLeft'),
        mR: document.getElementById('marginRight'),
        // Image mapping inputs
        imgScale: document.getElementById('imgScale'),
        imgPanX: document.getElementById('imgPanX'),
        imgPanY: document.getElementById('imgPanY'),
    };
    
    // Holes data cache for DXF export
    let generatedHoles = []; 
    let sheetDefinitions = []; 
    
    // Panel alignment and display state
    let panelAlignment = 'center'; // 'center', 'top-left', 'top', 'top-right', 'left', 'right', 'bottom-left', 'bottom', 'bottom-right'
    let showPercentage = false;
    let percentageSize = 100; // Percentage size multiplier (50-200%)
    let panelStats = []; // Store stats per panel: [{sheetIndex, holeCount, openArea, bounds}]
    let includeFooterStatsInDownload = false; // Include footer statistics in downloaded files 

    // --- LOCAL STORAGE ---
    function saveSettings() {
        const settings = {
            projectName: projectNameInput ? projectNameInput.value : '',
            w: inputs.w.value,
            h: inputs.h.value,
            pitch: inputs.pitch.value,
            edge: inputs.edge.value,
            min: inputs.min.value,
            max: inputs.max.value,
            invert: inputs.invert.checked,
            splitW: inputs.splitW.value,
            splitH: inputs.splitH.value,
            mT: inputs.mT.value,
            mB: inputs.mB.value,
            mL: inputs.mL.value,
            mR: inputs.mR.value,
            imgFit: imgFitMode.value,
            imgScale: inputs.imgScale.value,
            imgPanX: inputs.imgPanX.value,
            imgPanY: inputs.imgPanY.value,
            splitMode: splitMode.value,
            lockRatio: lockRatioCheckbox.checked,
            lockMode: lockPitchRadio.checked ? 'pitch' : 'gap',
            panelAlignment: panelAlignment,
            showPercentage: showPercentage,
            percentageSize: percentageSize,
            includeFooterStatsInDownload: includeFooterStatsInDownload
        };
        localStorage.setItem('holemapper_settings_v3', JSON.stringify(settings));
    }

    function loadSettings() {
        const saved = localStorage.getItem('holemapper_settings_v3');
        if (saved) {
            try {
                const s = JSON.parse(saved);
                if(s.projectName && projectNameInput) projectNameInput.value = s.projectName;
                if(s.w) inputs.w.value = s.w;
                if(s.h) inputs.h.value = s.h;
                if(s.pitch) inputs.pitch.value = s.pitch;
                if(s.edge) inputs.edge.value = s.edge;
                if(s.min) inputs.min.value = s.min;
                if(s.max) inputs.max.value = s.max;
                if(s.invert !== undefined) inputs.invert.checked = s.invert;
                if(s.splitW !== undefined) inputs.splitW.value = s.splitW;
                if(s.splitH !== undefined) inputs.splitH.value = s.splitH;
                if(s.mT !== undefined) inputs.mT.value = s.mT;
                if(s.mB !== undefined) inputs.mB.value = s.mB;
                if(s.mL !== undefined) inputs.mL.value = s.mL;
                if(s.mR !== undefined) inputs.mR.value = s.mR;
                if(s.imgFit) imgFitMode.value = s.imgFit;
                if(s.imgScale) inputs.imgScale.value = s.imgScale;
                if(s.imgPanX) inputs.imgPanX.value = s.imgPanX;
                if(s.imgPanY) inputs.imgPanY.value = s.imgPanY;
                if(s.splitMode) splitMode.value = s.splitMode;
                if(s.lockRatio !== undefined) lockRatioCheckbox.checked = s.lockRatio;
                
                if(s.lockMode === 'gap') lockGapRadio.checked = true;
                else lockPitchRadio.checked = true;
                
                if(s.panelAlignment) {
                    panelAlignment = s.panelAlignment;
                    if (alignmentButtons && alignmentButtons.length > 0) {
                        alignmentButtons.forEach(btn => {
                            btn.classList.toggle('active', btn.dataset.align === panelAlignment);
                        });
                    }
                }
                
                if(s.showPercentage !== undefined) {
                    showPercentage = s.showPercentage;
                    if (showPercentageToggle) {
                        showPercentageToggle.classList.toggle('active', showPercentage);
                    }
                    if (percentageSizeContainer) {
                        percentageSizeContainer.style.display = showPercentage ? 'block' : 'none';
                    }
                }
                
                if(s.percentageSize !== undefined) {
                    percentageSize = s.percentageSize;
                    if (percentageSizeSlider) {
                        percentageSizeSlider.value = percentageSize;
                    }
                    if (percentageSizeValue) {
                        percentageSizeValue.textContent = percentageSize + '%';
                    }
                }
                
                if(s.includeFooterStatsInDownload !== undefined) {
                    includeFooterStatsInDownload = s.includeFooterStatsInDownload;
                    if (includeFooterStatsToggle) {
                        includeFooterStatsToggle.classList.toggle('active', includeFooterStatsInDownload);
                    }
                }
                
                toggleImgControls();
            } catch(e) { console.error(e); }
        }
    }
    
    function toggleImgControls() {
        if(imgFitMode.value === 'ratio') {
            imgPlacementControls.style.display = 'block';
        } else {
            imgPlacementControls.style.display = 'none';
        }
    }
    
    function generateUniqueID() {
        // Generate a random 8-character string, e.g., HM-A1B2C3D4
        const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
        let result = "";
        for (let i = 0; i < 8; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        return "HM-" + result;
    }
    
    function getDownloadFilename() {
        const projectName = projectNameInput && projectNameInput.value.trim() ? projectNameInput.value.trim() : '';
        const uniqueId = currentFileID || generateUniqueID();
        // Sanitize project name for filename (remove invalid characters)
        const sanitizedName = projectName.replace(/[^a-z0-9_-]/gi, '_').substring(0, 50);
        return sanitizedName ? `${sanitizedName}_${uniqueId}` : uniqueId;
    }

    // Load shared design from URL (if opened from shareable HTML)
    function loadSharedDesign() {
        const urlParams = new URLSearchParams(window.location.search);
        const sharedData = urlParams.get('shared');
        
        if (sharedData) {
            try {
                const decoded = atob(decodeURIComponent(sharedData));
                const designData = JSON.parse(decoded);
                
                if (designData.image && designData.settings) {
                    // Load image
                    const img = new Image();
                    img.onload = () => {
                        sourceImage = img;
                        imageAspectRatio = img.naturalWidth / img.naturalHeight;
                        ratioDisplay.innerText = `Image Ratio: ${imageAspectRatio.toFixed(3)}`;
                        
                        // Load settings
                        const s = designData.settings;
                        if(s.w) inputs.w.value = s.w;
                        if(s.h) inputs.h.value = s.h;
                        if(s.pitch) inputs.pitch.value = s.pitch;
                        if(s.edge) inputs.edge.value = s.edge;
                        if(s.min) inputs.min.value = s.min;
                        if(s.max) inputs.max.value = s.max;
                        if(s.invert !== undefined) inputs.invert.checked = s.invert;
                        if(s.splitW !== undefined) inputs.splitW.value = s.splitW;
                        if(s.splitH !== undefined) inputs.splitH.value = s.splitH;
                        if(s.mT !== undefined) inputs.mT.value = s.mT;
                        if(s.mB !== undefined) inputs.mB.value = s.mB;
                        if(s.mL !== undefined) inputs.mL.value = s.mL;
                        if(s.mR !== undefined) inputs.mR.value = s.mR;
                        if(s.imgFit) imgFitMode.value = s.imgFit;
                        if(s.imgScale) inputs.imgScale.value = s.imgScale;
                        if(s.imgPanX) inputs.imgPanX.value = s.imgPanX;
                        if(s.imgPanY) inputs.imgPanY.value = s.imgPanY;
                        if(s.splitMode) splitMode.value = s.splitMode;
                        if(s.lockRatio !== undefined) lockRatioCheckbox.checked = s.lockRatio;
                        if(s.lockMode === 'gap') lockGapRadio.checked = true;
                        else lockPitchRadio.checked = true;
                        if(s.panelAlignment) {
                            panelAlignment = s.panelAlignment;
                            if (alignmentButtons && alignmentButtons.length > 0) {
                                alignmentButtons.forEach(btn => {
                                    btn.classList.toggle('active', btn.dataset.align === panelAlignment);
                                });
                            }
                        }
                        if(s.showPercentage !== undefined) {
                            showPercentage = s.showPercentage;
                            if (showPercentageToggle) {
                                showPercentageToggle.classList.toggle('active', showPercentage);
                            }
                            if (percentageSizeContainer) {
                                percentageSizeContainer.style.display = showPercentage ? 'block' : 'none';
                            }
                        }
                        if(s.percentageSize !== undefined) {
                            percentageSize = s.percentageSize;
                            if (percentageSizeSlider) {
                                percentageSizeSlider.value = percentageSize;
                            }
                            if (percentageSizeValue) {
                                percentageSizeValue.textContent = percentageSize + '%';
                            }
                        }
                        
                        toggleImgControls();
                        saveSettings();
                        generateBtn.innerText = "Generate Pattern";
                        generatePerforation();
                        
                        // Clean URL
                        window.history.replaceState({}, document.title, window.location.pathname);
                    };
                    img.src = designData.image;
                }
            } catch (e) {
                console.error('Failed to load shared design:', e);
                alert('Failed to load shared design. Please check the file and try again.');
            }
        }
    }

    // Initialize
    loadSettings();
    loadSharedDesign();

    // Event Listeners
    if (fileInput) {
    fileInput.addEventListener('change', handleImageUpload);
    } else {
        console.error('fileInput not found');
    }
    if (importFile) {
    importFile.addEventListener('change', handleImportConfig);
    } else {
        console.error('importFile not found');
    }
    if (generateBtn) {
    generateBtn.addEventListener('click', generatePerforation);
    }
    
    // Download buttons - these are now in navbar dropdown with onclick handlers
    // Event listeners are optional since onclick is already set
    if (downloadImgBtn) {
        // Remove duplicate listener if onclick is already set
        // downloadImgBtn.addEventListener('click', () => downloadImage());
    }
    if (downloadTxtBtn) {
        // downloadTxtBtn.addEventListener('click', () => downloadSpecs());
    }
    if (downloadDxfBtn) {
        // downloadDxfBtn.addEventListener('click', () => downloadDXF());
    }
    if (downloadSvgBtn) {
        // downloadSvgBtn.addEventListener('click', () => downloadSVG());
    }
    
    imgFitMode.addEventListener('change', () => {
        toggleImgControls();
        saveSettings();
        generatePerforation(); // Immediate redraw on mode change
    });
    
    // Canvas Pan/Zoom Interaction
    mainViewport.addEventListener('wheel', handleWheel, { passive: false });
    mainViewport.addEventListener('mousedown', startDrag);
    window.addEventListener('mousemove', drag);
    window.addEventListener('mouseup', endDrag);
    
    btnZoomIn.addEventListener('click', () => applyZoom(scale * 1.2));
    btnZoomOut.addEventListener('click', () => applyZoom(scale * 0.8));
    btnZoomFit.addEventListener('click', zoomFit);
    
    // Alignment button handlers
    if (alignmentButtons && alignmentButtons.length > 0) {
        alignmentButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                alignmentButtons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                panelAlignment = btn.dataset.align;
                saveSettings();
                if (sourceImage) generatePerforation();
            });
        });
    }
    
    // Show percentage toggle
    if (showPercentageToggle) {
        showPercentageToggle.addEventListener('click', () => {
            showPercentage = !showPercentage;
            showPercentageToggle.classList.toggle('active', showPercentage);
            if (percentageSizeContainer) {
                percentageSizeContainer.style.display = showPercentage ? 'block' : 'none';
            }
            saveSettings();
            if (sourceImage) generatePerforation();
        });
    }
    
    // Include footer stats in download toggle
    if (includeFooterStatsToggle) {
        includeFooterStatsToggle.addEventListener('click', () => {
            includeFooterStatsInDownload = !includeFooterStatsInDownload;
            includeFooterStatsToggle.classList.toggle('active', includeFooterStatsInDownload);
            saveSettings();
        });
    }
    
    // Percentage size slider
    if (percentageSizeSlider && percentageSizeValue) {
        percentageSizeSlider.addEventListener('input', (e) => {
            percentageSize = parseInt(e.target.value);
            percentageSizeValue.textContent = percentageSize + '%';
            saveSettings();
            if (sourceImage && showPercentage) generatePerforation();
        });
    }
    
    // Sync Inputs
    inputs.h.addEventListener('input', () => {
        if (lockRatioCheckbox.checked && imageAspectRatio > 0) {
            const h = parseFloat(inputs.h.value);
            if (!isNaN(h)) inputs.w.value = Math.round(h * imageAspectRatio);
        }
        saveSettings();
    });
    inputs.w.addEventListener('input', () => {
        if (lockRatioCheckbox.checked && imageAspectRatio > 0) {
            const w = parseFloat(inputs.w.value);
            if (!isNaN(w)) inputs.h.value = Math.round(w / imageAspectRatio);
        }
        saveSettings();
    });

    // Pitch/Gap Sync
    inputs.pitch.addEventListener('input', () => {
        const p = parseFloat(inputs.pitch.value) || 0;
        const m = parseFloat(inputs.max.value) || 0;
        inputs.edge.value = parseFloat((p - m).toFixed(2));
        saveSettings();
    });
    inputs.edge.addEventListener('input', () => {
        const e = parseFloat(inputs.edge.value) || 0;
        const m = parseFloat(inputs.max.value) || 0;
        inputs.pitch.value = parseFloat((e + m).toFixed(2));
        saveSettings();
    });
    inputs.max.addEventListener('input', () => {
        if (lockPitchRadio.checked) {
            const p = parseFloat(inputs.pitch.value) || 0;
            const m = parseFloat(inputs.max.value) || 0;
            inputs.edge.value = parseFloat((p - m).toFixed(2));
        } else {
            const e = parseFloat(inputs.edge.value) || 0;
            const m = parseFloat(inputs.max.value) || 0;
            inputs.pitch.value = parseFloat((e + m).toFixed(2));
        }
        saveSettings();
    });

    // Auto-save & Refresh triggers
    const allInputs = Object.values(inputs);
    allInputs.push(lockRatioCheckbox, lockPitchRadio, lockGapRadio, splitMode);
    
    allInputs.forEach(el => {
        el.addEventListener('change', () => {
            saveSettings();
            setTimeout(generatePerforation, 10);
        });
    });

    // --- CANVAS VIEWPORT LOGIC ---
    function updateTransform() {
        container.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
    }

    function handleWheel(e) {
        if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            const factor = e.deltaY < 0 ? 1.1 : 0.9;
            applyZoom(scale * factor);
        }
    }
    
    function applyZoom(newScale) {
        if (newScale < 0.05) newScale = 0.05;
        if (newScale > 20) newScale = 20;
        scale = newScale;
        updateTransform();
    }
    
    function zoomFit() {
        if (canvas.width === 0) return;
        panX = 0; 
        panY = 0;
        const vw = mainViewport.clientWidth - 40;
        const vh = mainViewport.clientHeight - 40;
        const fitScale = Math.min(vw / canvas.width, vh / canvas.height);
        applyZoom(fitScale * 0.9);
    }

    function startDrag(e) {
        isDragging = true;
        dragStartX = e.clientX - panX;
        dragStartY = e.clientY - panY;
        mainViewport.style.cursor = 'grabbing';
    }

    function drag(e) {
        if (!isDragging) return;
        e.preventDefault();
        panX = e.clientX - dragStartX;
        panY = e.clientY - dragStartY;
        updateTransform();
    }

    function endDrag() {
        isDragging = false;
        mainViewport.style.cursor = 'grab';
    }

    // --- IMPORT / EXPORT LOGIC ---

    function handleImportConfig(e) {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (ev) => {
            const text = ev.target.result;
            // Simple parser for "Key: Value" lines
            const lines = text.split('\n');
            const config = {};
            lines.forEach(line => {
                const parts = line.split(':');
                if (parts.length >= 2) {
                    const key = parts[0].trim();
                    const val = parts.slice(1).join(':').trim();
                    config[key] = val;
                }
            });

            // Map back to inputs
            if(config['TotalWidth']) inputs.w.value = config['TotalWidth'].replace('mm','').trim();
            if(config['TotalHeight']) inputs.h.value = config['TotalHeight'].replace('mm','').trim();
            if(config['Pitch']) inputs.pitch.value = config['Pitch'].replace('mm','').trim();
            if(config['Gap']) inputs.edge.value = config['Gap'].replace('mm','').trim();
            if(config['MinHole']) inputs.min.value = config['MinHole'].replace('mm','').trim();
            if(config['MaxHole']) inputs.max.value = config['MaxHole'].replace('mm','').trim();
            
            // Layout
            if(config['SplitsW']) inputs.splitW.value = config['SplitsW'];
            if(config['SplitsH']) inputs.splitH.value = config['SplitsH'];
            
            // Margins
            if(config['MarginTop']) inputs.mT.value = config['MarginTop'];
            if(config['MarginBottom']) inputs.mB.value = config['MarginBottom'];
            if(config['MarginLeft']) inputs.mL.value = config['MarginLeft'];
            if(config['MarginRight']) inputs.mR.value = config['MarginRight'];
            
            // Image Settings
            if(config['ImageFit']) imgFitMode.value = config['ImageFit'];
            if(config['ImageScale']) inputs.imgScale.value = config['ImageScale'];
            if(config['ImagePanX']) inputs.imgPanX.value = config['ImagePanX'];
            if(config['ImagePanY']) inputs.imgPanY.value = config['ImagePanY'];
            
            toggleImgControls();
            saveSettings();
            generatePerforation();
            alert("Settings imported!");
        };
        reader.readAsText(file);
        // Reset input
        e.target.value = '';
    }

    // --- GENERATION LOGIC ---

    function handleImageUpload(e) {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (event) => {
            const img = new Image();
            img.onload = () => {
                sourceImage = img;
                imageAspectRatio = img.naturalWidth / img.naturalHeight;
                ratioDisplay.innerText = `Image Ratio: ${imageAspectRatio.toFixed(3)}`;
                
                if (lockRatioCheckbox.checked) {
                    const currentH = parseFloat(inputs.h.value) || 2000;
                    inputs.w.value = Math.round(currentH * imageAspectRatio);
                }
                generateBtn.innerText = "Generate Pattern";
                generatePerforation();
            };
            img.src = event.target.result;
        };
        reader.readAsDataURL(file);
    }

    function parseSplits(str, total, errEl, axis) {
        const mode = splitMode.value;
        let parts = [];
        
        if (str && str.trim() !== "") {
            parts = str.split(',').map(s => parseFloat(s.trim())).filter(n => !isNaN(n) && n > 0);
        }

        if (parts.length === 0) return [total];

        const sum = parts.reduce((a, b) => a + b, 0);
        const diff = total - sum;

        // Logic based on mode
        if (mode === 'strict') {
            if (Math.abs(diff) > 1) {
                errEl.style.display = 'block';
                errEl.innerText = `Sum (${sum})  Total (${total})`;
                return [total]; // Fallback
            } else {
                errEl.style.display = 'none';
                return parts;
            }
        } 
        else if (mode === 'fill') {
            errEl.style.display = 'none';
            if (diff > 1) {
                // Add remainder panel
                parts.push(parseFloat(diff.toFixed(2)));
            }
            return parts;
        }
        else if (mode === 'update') {
            errEl.style.display = 'none';
            // We use the parts exactly. If they don't sum to total, we update Total.
            if (Math.abs(diff) > 1) {
                // Trigger update of global inputs
                if(axis === 'w') inputs.w.value = sum;
                if(axis === 'h') inputs.h.value = sum;
            }
            return parts;
        }

        return [total];
    }

    // Calculate alignment offset for a panel (usable area after margins)
    function getAlignmentOffset(usableW, usableH, pitch, alignment) {
        // Calculate how many complete holes fit in each direction
        const colsInPanel = Math.floor(usableW / pitch);
        const rowsInPanel = Math.floor(usableH / pitch);
        
        // Calculate the "remainder" space that needs to be distributed for alignment
        const remainderX = usableW - (colsInPanel * pitch);
        const remainderY = usableH - (rowsInPanel * pitch);
        
        let offsetX = 0;
        let offsetY = 0;
        
        switch(alignment) {
            case 'top-left':
                offsetX = 0;
                offsetY = 0;
                break;
            case 'top':
                offsetX = remainderX / 2;
                offsetY = 0;
                break;
            case 'top-right':
                offsetX = remainderX;
                offsetY = 0;
                break;
            case 'left':
                offsetX = 0;
                offsetY = remainderY / 2;
                break;
            case 'center':
                offsetX = remainderX / 2;
                offsetY = remainderY / 2;
                break;
            case 'right':
                offsetX = remainderX;
                offsetY = remainderY / 2;
                break;
            case 'bottom-left':
                offsetX = 0;
                offsetY = remainderY;
                break;
            case 'bottom':
                offsetX = remainderX / 2;
                offsetY = remainderY;
                break;
            case 'bottom-right':
                offsetX = remainderX;
                offsetY = remainderY;
                break;
            default:
                offsetX = remainderX / 2;
                offsetY = remainderY / 2;
        }
        
        return { offsetX, offsetY };
    }

    function generatePerforation() {
        if (!sourceImage) return;

        // Generate new ID for this run
        currentFileID = generateUniqueID();

        const w = parseFloat(inputs.w.value);
        const h = parseFloat(inputs.h.value);
        const pitch = parseFloat(inputs.pitch.value);
        const minDia = parseFloat(inputs.min.value);
        const maxDia = parseFloat(inputs.max.value);
        const invert = inputs.invert.checked;
        
        // Parsing subdivisions
        const widths = parseSplits(inputs.splitW.value, w, errSplitW, 'w');
        const heights = parseSplits(inputs.splitH.value, h, errSplitH, 'h');
        
        // Refresh W/H in case 'update' mode changed them
        const finalW = parseFloat(inputs.w.value);
        const finalH = parseFloat(inputs.h.value);
        
        // Calculate Sheet Definitions
        sheetDefinitions = [];
        let currY = 0;
        for (let sh of heights) {
            let currX = 0;
            for (let sw of widths) {
                sheetDefinitions.push({
                    x: currX, y: currY, w: sw, h: sh
                });
                currX += sw;
            }
            currY += sh;
        }

        // Safety Check
        const estTotal = (finalW / pitch) * (finalH / pitch);
        if (estTotal > 300000) {
            if(!confirm(`Warning: ~${Math.floor(estTotal)} holes. Proceed?`)) return;
        }
        warningMsg.style.display = estTotal > 50000 ? 'block' : 'none';

        generateBtn.innerText = "Processing...";
        setTimeout(() => {
            render(finalW, finalH, pitch, minDia, maxDia, invert);
            generateBtn.innerText = "Update Pattern";
        }, 50);
    }

    function render(w, h, pitch, minDia, maxDia, invert) {
        // Canvas setup
        let pixelScale = CONFIG.baseScale;
        const targetW = w * pixelScale;
        const targetH = h * pixelScale;
        
        if (targetW > CONFIG.maxCanvasDimension || targetH > CONFIG.maxCanvasDimension) {
            const maxSide = Math.max(targetW, targetH);
            pixelScale = pixelScale * (CONFIG.maxCanvasDimension / maxSide);
        }

        canvas.width = w * pixelScale;
        canvas.height = h * pixelScale;

        // Draw Panel Background
        ctx.fillStyle = "white"; 
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Visual Sheets
        ctx.strokeStyle = "#e2e8f0";
        ctx.lineWidth = 2;
        sheetDefinitions.forEach(sheet => {
            ctx.strokeRect(sheet.x * pixelScale, sheet.y * pixelScale, sheet.w * pixelScale, sheet.h * pixelScale);
        });

        // --- IMAGE PROCESSING (WITH OFFSET/SCALE) ---
        const cols = Math.floor(w / pitch);
        const rows = Math.floor(h / pitch);

        const analysisCanvas = document.createElement('canvas');
        analysisCanvas.width = cols;
        analysisCanvas.height = rows;
        const actx = analysisCanvas.getContext('2d');
        
        // Logic for Image Drawing based on mode
        if (imgFitMode.value === 'stretch') {
            actx.drawImage(sourceImage, 0, 0, cols, rows);
        } else {
            // Keep Ratio logic
            // 1. Calculate aspect ratios
            const canvasRatio = cols / rows;
            const imgRatio = sourceImage.naturalWidth / sourceImage.naturalHeight;
            
            // 2. Base fit
            let drawW = cols;
            let drawH = cols / imgRatio;
            
            // User scale override
            const userScale = parseFloat(inputs.imgScale.value) || 1.0;
            drawW *= userScale;
            drawH *= userScale;
            
            // Center the image initially
            let drawX = (cols - drawW) / 2;
            let drawY = (rows - drawH) / 2;
            
            // Apply User Pan (Convert mm to grid units)
            const panXGrid = (parseFloat(inputs.imgPanX.value) || 0) / pitch;
            const panYGrid = (parseFloat(inputs.imgPanY.value) || 0) / pitch;
            
            drawX += panXGrid;
            drawY += panYGrid;
            
            // Clear background for analysis
            actx.fillStyle = "white"; 
            actx.fillRect(0,0, cols, rows);
            
            actx.drawImage(sourceImage, drawX, drawY, drawW, drawH);
        }
        
        const pixels = actx.getImageData(0, 0, cols, rows).data;

        // Margins
        const mT = parseFloat(inputs.mT.value) || 0;
        const mB = parseFloat(inputs.mB.value) || 0;
        const mL = parseFloat(inputs.mL.value) || 0;
        const mR = parseFloat(inputs.mR.value) || 0;

        ctx.fillStyle = "black";
        
        let count = 0;
        let totalHoleArea = 0;
        generatedHoles = []; 
        panelStats = []; // Reset panel stats
        
        // Initialize panel stats
        sheetDefinitions.forEach((sheet, idx) => {
            panelStats.push({
                sheetIndex: idx,
                holeCount: 0,
                openArea: 0,
                panelArea: (sheet.w - mL - mR) * (sheet.h - mT - mB)
            });
        });

        // Process each panel separately with its own alignment
        sheetDefinitions.forEach((activeSheet, sheetIndex) => {
            // Calculate usable area (after margins)
            const usableW = activeSheet.w - mL - mR;
            const usableH = activeSheet.h - mT - mB;
            
            if (usableW <= 0 || usableH <= 0) return; // Skip if no usable area
            
            // Calculate alignment offset for the usable area
            const alignOffset = getAlignmentOffset(usableW, usableH, pitch, panelAlignment);
            
            // Calculate how many holes fit in this panel
            const colsInPanel = Math.floor(usableW / pitch);
            const rowsInPanel = Math.floor(usableH / pitch);
            
            // Starting position for first hole in this panel (with alignment)
            const startX = activeSheet.x + mL + alignOffset.offsetX + (pitch / 2);
            const startY = activeSheet.y + mT + alignOffset.offsetY + (pitch / 2);
            
            // Generate holes for this panel
            for (let py = 0; py < rowsInPanel; py++) {
                for (let px = 0; px < colsInPanel; px++) {
                    const cx = startX + (px * pitch);
                    const cy = startY + (py * pitch);
                    
                    // Verify hole is within panel bounds
                    if (cx < activeSheet.x + mL || cx > activeSheet.x + activeSheet.w - mR) continue;
                    if (cy < activeSheet.y + mT || cy > activeSheet.y + activeSheet.h - mB) continue;
                    
                    // Get image pixel for this position
                    const gridX = Math.floor((cx / w) * cols);
                    const gridY = Math.floor((cy / h) * rows);
                    
                    if (gridX < 0 || gridX >= cols || gridY < 0 || gridY >= rows) continue;
                    
                    const idx = (gridY * cols + gridX) * 4;
                const bVal = (pixels[idx] + pixels[idx+1] + pixels[idx+2]) / 3;
                const norm = bVal / 255;
                const sizeFactor = invert ? norm : (1.0 - norm);
                const diameter = minDia + (sizeFactor * (maxDia - minDia));
                const r = diameter / 2;

                const drawX = cx * pixelScale;
                const drawY = cy * pixelScale;
                const drawR = r * pixelScale;

                ctx.beginPath();
                ctx.arc(drawX, drawY, drawR, 0, Math.PI * 2);
                ctx.fill();

                generatedHoles.push({x: cx, y: cy, r: r});
                
                    const holeArea = Math.PI * Math.pow(r, 2);
                    totalHoleArea += holeArea;
                count++;
                    
                    // Update panel stats
                    if (sheetIndex < panelStats.length) {
                        panelStats[sheetIndex].holeCount++;
                        panelStats[sheetIndex].openArea += holeArea;
            }
        }
            }
        });
        
        
        ctx.strokeStyle = "rgba(239, 68, 68, 0.3)";
        ctx.lineWidth = 1;
        sheetDefinitions.forEach(sheet => {
            const sx = (sheet.x + mL) * pixelScale;
            const sy = (sheet.y + mT) * pixelScale;
            const sw = (sheet.w - mL - mR) * pixelScale;
            const sh = (sheet.h - mT - mB) * pixelScale;
            if (sw > 0 && sh > 0) ctx.strokeRect(sx, sy, sw, sh);
        });
        
        // Draw opening percentage overlay for each panel (if enabled for display)
        drawPercentageOverlay(ctx, pixelScale, showPercentage);

        document.getElementById('statCount').innerText = count.toLocaleString();
        document.getElementById('statArea').innerText = ((totalHoleArea / (w*h)) * 100).toFixed(2) + "%";
        
        // Update footer statistics
        const footerPanels = document.getElementById('footerPanels');
        const footerHoles = document.getElementById('footerHoles');
        const footerOpening = document.getElementById('footerOpening');
        const footerMinHole = document.getElementById('footerMinHole');
        const footerMaxHole = document.getElementById('footerMaxHole');
        const footerSpacing = document.getElementById('footerSpacing');
        
        if (footerPanels) footerPanels.textContent = sheetDefinitions.length.toString();
        if (footerHoles) footerHoles.textContent = count.toLocaleString();
        if (footerOpening) footerOpening.textContent = ((totalHoleArea / (w*h)) * 100).toFixed(2) + "%";
        if (footerMinHole) footerMinHole.textContent = inputs.min.value || "0";
        if (footerMaxHole) footerMaxHole.textContent = inputs.max.value || "0";
        if (footerSpacing) footerSpacing.textContent = inputs.pitch.value || "0";
        
        downloadImgBtn.disabled = false;
        downloadTxtBtn.disabled = false;
        downloadDxfBtn.disabled = false;
        downloadSvgBtn.disabled = false;
        if (downloadZipBtn) downloadZipBtn.disabled = false;
        const shareableBtn = document.getElementById('downloadShareableBtn');
        if (shareableBtn && authManager.currentUser) {
            shareableBtn.disabled = false;
        }
        
        if (scale === 1 && panX === 0) zoomFit();
    }

    // --- EXPORT FUNCTIONS ---
    
    // Helper function to get footer statistics
    function getFooterStatistics() {
        const w = parseFloat(inputs.w.value);
        const h = parseFloat(inputs.h.value);
        const panels = sheetDefinitions.length;
        const holes = generatedHoles.length;
        // Calculate total hole area
        let totalHoleArea = 0;
        generatedHoles.forEach(h => {
            totalHoleArea += Math.PI * Math.pow(h.r, 2);
        });
        const opening = ((totalHoleArea / (w * h)) * 100).toFixed(2) + "%";
        const minHole = inputs.min.value || "0";
        const maxHole = inputs.max.value || "0";
        const spacing = inputs.pitch.value || "0";
        return { panels, holes, opening, minHole, maxHole, spacing };
    }

    function downloadDXF() {
        if (generatedHoles.length === 0) return;
        const filename = getDownloadFilename();
        const totalH = parseFloat(inputs.h.value);
        const totalW = parseFloat(inputs.w.value);

        // Minimal DXF R12 format - simplest possible for maximum compatibility
        let dxf = "";
        
        // Header - minimal required
        dxf += "0\nSECTION\n2\nHEADER\n";
        dxf += "9\n$ACADVER\n1\nAC1009\n";
        dxf += "0\nENDSEC\n";
        
        // Tables - minimal required
        dxf += "0\nSECTION\n2\nTABLES\n";
        
        // Layer table - only layer 0 required
        dxf += "0\nTABLE\n2\nLAYER\n70\n1\n";
        dxf += "0\nLAYER\n2\n0\n70\n0\n62\n7\n6\nCONTINUOUS\n";
        dxf += "0\nENDTAB\n";
        
        dxf += "0\nENDSEC\n";

        // Entities section
        dxf += "0\nSECTION\n2\nENTITIES\n";

        // Draw panel boundaries as simple POLYLINE
        sheetDefinitions.forEach(s => {
            dxf += "0\nPOLYLINE\n8\n0\n66\n1\n70\n1\n";
            dxf += "0\nVERTEX\n8\n0\n10\n" + s.x.toFixed(3) + "\n20\n" + (totalH - s.y).toFixed(3) + "\n";
            dxf += "0\nVERTEX\n8\n0\n10\n" + (s.x + s.w).toFixed(3) + "\n20\n" + (totalH - s.y).toFixed(3) + "\n";
            dxf += "0\nVERTEX\n8\n0\n10\n" + (s.x + s.w).toFixed(3) + "\n20\n" + (totalH - (s.y + s.h)).toFixed(3) + "\n";
            dxf += "0\nVERTEX\n8\n0\n10\n" + s.x.toFixed(3) + "\n20\n" + (totalH - (s.y + s.h)).toFixed(3) + "\n";
            dxf += "0\nSEQEND\n8\n0\n";
        });
        
        // Draw holes as circles
        generatedHoles.forEach(h => {
            const dxfY = totalH - h.y;
            dxf += "0\nCIRCLE\n8\n0\n";
            dxf += "10\n" + h.x.toFixed(3) + "\n";
            dxf += "20\n" + dxfY.toFixed(3) + "\n";
            dxf += "30\n0.0\n";
            dxf += "40\n" + h.r.toFixed(3) + "\n";
        });
        
        // Draw percentage text if enabled
        if (showPercentage && panelStats.length > 0) {
            panelStats.forEach((stat, idx) => {
                if (idx < sheetDefinitions.length && stat.panelArea > 0) {
                    const sheet = sheetDefinitions[idx];
                    const percentage = stat.panelArea > 0 ? ((stat.openArea / stat.panelArea) * 100).toFixed(1) : "0.0";
                    const textX = sheet.x + sheet.w / 2;
                    const textY = totalH - (sheet.y + sheet.h / 2);
                    
                    dxf += "0\nTEXT\n8\n0\n";
                    dxf += "10\n" + textX.toFixed(3) + "\n";
                    dxf += "20\n" + textY.toFixed(3) + "\n";
                    dxf += "30\n0.0\n";
                    dxf += "40\n10.0\n";
                    dxf += "1\n" + percentage + "%\n";
                    dxf += "50\n0.0\n";
                }
            });
        }
        
        // Add footer statistics if enabled
        if (includeFooterStatsInDownload) {
            const stats = getFooterStatistics();
            const footerY = totalH + 20; // Position below the design
            const fontSize = 8.0;
            const startX = totalW / 2 - 100; // Center the text
            
            dxf += "0\nTEXT\n8\n0\n";
            dxf += "10\n" + startX.toFixed(3) + "\n";
            dxf += "20\n" + footerY.toFixed(3) + "\n";
            dxf += "30\n0.0\n";
            dxf += "40\n" + fontSize.toFixed(1) + "\n";
            dxf += "1\nPanels: " + stats.panels + " | Holes: " + stats.holes.toLocaleString() + " | Opening: " + stats.opening + " | Min Hole: " + stats.minHole + "mm | Max Hole: " + stats.maxHole + "mm | Spacing: " + stats.spacing + "mm\n";
            dxf += "50\n0.0\n";
        }

        dxf += "0\nENDSEC\n";
        dxf += "0\nEOF\n";

        const blob = new Blob([dxf], {type: "application/dxf"});
        const link = document.createElement('a');
        link.download = `${filename}.dxf`;
        link.href = URL.createObjectURL(blob);
        link.click();
    }

    // Helper function to draw percentage overlay
    function drawPercentageOverlay(ctx, pixelScale, shouldDraw) {
        if (!shouldDraw || panelStats.length === 0) return;
        
        ctx.save();
        const baseFontSize = Math.max(14, Math.min(24, pixelScale * 1.5));
        const fontSize = baseFontSize * (percentageSize / 100);
        ctx.font = `bold ${fontSize}px sans-serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        
        panelStats.forEach((stat, idx) => {
            if (idx < sheetDefinitions.length && stat.panelArea > 0) {
                const sheet = sheetDefinitions[idx];
                const percentage = stat.panelArea > 0 ? ((stat.openArea / stat.panelArea) * 100).toFixed(1) : "0.0";
                
                const centerX = (sheet.x + sheet.w / 2) * pixelScale;
                const centerY = (sheet.y + sheet.h / 2) * pixelScale;
                
                // Draw background rectangle
                const text = `${percentage}%`;
                const metrics = ctx.measureText(text);
                const textWidth = metrics.width;
                const textHeight = fontSize;
                const padding = 6;
                
                // Background
                ctx.fillStyle = "rgba(0, 0, 0, 0.75)";
                ctx.fillRect(
                    centerX - textWidth / 2 - padding,
                    centerY - textHeight / 2 - padding,
                    textWidth + padding * 2,
                    textHeight + padding * 2
                );
                
                // Border
                ctx.strokeStyle = "white";
                ctx.lineWidth = 1;
                ctx.strokeRect(
                    centerX - textWidth / 2 - padding,
                    centerY - textHeight / 2 - padding,
                    textWidth + padding * 2,
                    textHeight + padding * 2
                );
                
                // Text
                ctx.fillStyle = "white";
                ctx.fillText(text, centerX, centerY);
            }
        });
        ctx.restore();
    }

    function downloadImage() {
        if (!sourceImage) return;
        const filename = getDownloadFilename();
        
        // Calculate footer height if needed
        const footerHeight = includeFooterStatsInDownload ? 50 : 0;
        
        // Create a temporary canvas to render with/without percentage
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height + footerHeight;
        const tempCtx = tempCanvas.getContext('2d');
        
        // Fill background
        tempCtx.fillStyle = '#ffffff';
        tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
        
        // Copy the main canvas
        tempCtx.drawImage(canvas, 0, 0);
        
        // Add percentage if "Show Opening % on Panels" is enabled
        if (showPercentage) {
            const pixelScale = canvas.width / parseFloat(inputs.w.value);
            drawPercentageOverlay(tempCtx, pixelScale, true);
        }
        
        // Add footer statistics if enabled
        if (includeFooterStatsInDownload) {
            const stats = getFooterStatistics();
            tempCtx.save();
            tempCtx.fillStyle = '#000000';
            tempCtx.font = '14px sans-serif';
            tempCtx.textAlign = 'center';
            tempCtx.textBaseline = 'top';
            const footerText = `Panels: ${stats.panels} | Holes: ${stats.holes.toLocaleString()} | Opening: ${stats.opening} | Min Hole: ${stats.minHole}mm | Max Hole: ${stats.maxHole}mm | Spacing: ${stats.spacing}mm`;
            tempCtx.fillText(footerText, tempCanvas.width / 2, canvas.height + 10);
            tempCtx.restore();
        }
        
        const imgLink = document.createElement('a');
        imgLink.download = `${filename}.png`;
        imgLink.href = tempCanvas.toDataURL('image/png');
        imgLink.click();
    }

    function downloadSVG() {
        if (generatedHoles.length === 0) return;
        const filename = getDownloadFilename();
        const totalH = parseFloat(inputs.h.value);
        const totalW = parseFloat(inputs.w.value);
        const footerHeight = includeFooterStatsInDownload ? 20 : 0;
        const svgHeight = totalH + footerHeight;
        
        let svg = '<?xml version="1.0" encoding="UTF-8"?>\n';
        svg += '<svg xmlns="http://www.w3.org/2000/svg" ';
        svg += `width="${totalW}mm" height="${svgHeight}mm" `;
        svg += `viewBox="0 0 ${totalW} ${svgHeight}">\n`;
        svg += '<g transform="translate(0,' + totalH + ') scale(1,-1)">\n'; // Flip Y axis
        
        // Draw panel boundaries
        svg += '<g id="panels" stroke="#0000FF" stroke-width="0.5" fill="none">\n';
        sheetDefinitions.forEach(s => {
            svg += `<rect x="${s.x}" y="${s.y}" width="${s.w}" height="${s.h}"/>\n`;
        });
        svg += '</g>\n';
        
        // Draw holes
        svg += '<g id="holes" fill="#000000">\n';
        generatedHoles.forEach(h => {
            svg += `<circle cx="${h.x.toFixed(3)}" cy="${h.y.toFixed(3)}" r="${h.r.toFixed(3)}"/>\n`;
        });
        svg += '</g>\n';
        
        // Draw percentage text if enabled
        if (showPercentage && panelStats.length > 0) {
            svg += '<g id="text" fill="#000000" font-family="Arial" font-size="10" text-anchor="middle">\n';
            panelStats.forEach((stat, idx) => {
                if (idx < sheetDefinitions.length && stat.panelArea > 0) {
                    const sheet = sheetDefinitions[idx];
                    const percentage = stat.panelArea > 0 ? ((stat.openArea / stat.panelArea) * 100).toFixed(1) : "0.0";
                    const textX = sheet.x + sheet.w / 2;
                    const textY = sheet.y + sheet.h / 2;
                    svg += `<text x="${textX.toFixed(3)}" y="${textY.toFixed(3)}">${percentage}%</text>\n`;
                }
            });
            svg += '</g>\n';
        }
        
        svg += '</g>\n';
        
        // Add footer statistics if enabled
        if (includeFooterStatsInDownload) {
            const stats = getFooterStatistics();
            const footerY = totalH + 20; // Position below the design
            svg += `<text x="${totalW / 2}" y="${footerY}" fill="#000000" font-family="Arial" font-size="8" text-anchor="middle">Panels: ${stats.panels} | Holes: ${stats.holes.toLocaleString()} | Opening: ${stats.opening} | Min Hole: ${stats.minHole}mm | Max Hole: ${stats.maxHole}mm | Spacing: ${stats.spacing}mm</text>\n`;
        }
        
        svg += '</svg>';
        
        const blob = new Blob([svg], { type: 'image/svg+xml' });
        const link = document.createElement('a');
        link.download = `${filename}.svg`;
        link.href = URL.createObjectURL(blob);
        link.click();
    }

    function downloadSpecs() {
        const filename = getDownloadFilename();
        const now = new Date();
        
        // Structured Text Content
        const content = 
`Perforated panel Designer Specification File
-----------------------------
Generated: ${now.toLocaleString()}
FileID: ${filename}

[Global Config]
TotalWidth: ${inputs.w.value}
TotalHeight: ${inputs.h.value}
Pitch: ${inputs.pitch.value}
Gap: ${inputs.edge.value}
MinHole: ${inputs.min.value}
MaxHole: ${inputs.max.value}
Invert: ${inputs.invert.checked}

[Layout]
SplitMode: ${splitMode.value}
SplitsW: ${inputs.splitW.value}
SplitsH: ${inputs.splitH.value}

[Margins]
MarginTop: ${inputs.mT.value}
MarginBottom: ${inputs.mB.value}
MarginLeft: ${inputs.mL.value}
MarginRight: ${inputs.mR.value}

[Image Settings]
ImageFit: ${imgFitMode.value}
ImageScale: ${inputs.imgScale.value}
ImagePanX: ${inputs.imgPanX.value}
ImagePanY: ${inputs.imgPanY.value}

[Stats]
TotalHoles: ${document.getElementById('statCount').innerText}
OpenArea: ${document.getElementById('statArea').innerText}
`;
        const blob = new Blob([content], { type: 'text/plain' });
        const textLink = document.createElement('a');
        textLink.download = `${filename}.txt`;
        textLink.href = URL.createObjectURL(blob);
        textLink.click();
    }
    
    // Helper function to get PNG as data URL
    function getPNGDataURL() {
        if (!sourceImage) return null;
        
        // Calculate footer height if needed
        const footerHeight = includeFooterStatsInDownload ? 50 : 0;
        
        // Create a temporary canvas to render with/without percentage
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height + footerHeight;
        const tempCtx = tempCanvas.getContext('2d');
        
        // Fill background
        tempCtx.fillStyle = '#ffffff';
        tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
        
        // Copy the main canvas
        tempCtx.drawImage(canvas, 0, 0);
        
        // Add percentage if "Show Opening % on Panels" is enabled
        if (showPercentage) {
            const pixelScale = canvas.width / parseFloat(inputs.w.value);
            drawPercentageOverlay(tempCtx, pixelScale, true);
        }
        
        // Add footer statistics if enabled
        if (includeFooterStatsInDownload) {
            const stats = getFooterStatistics();
            tempCtx.save();
            tempCtx.fillStyle = '#000000';
            tempCtx.font = '14px sans-serif';
            tempCtx.textAlign = 'center';
            tempCtx.textBaseline = 'top';
            const footerText = `Panels: ${stats.panels} | Holes: ${stats.holes.toLocaleString()} | Opening: ${stats.opening} | Min Hole: ${stats.minHole}mm | Max Hole: ${stats.maxHole}mm | Spacing: ${stats.spacing}mm`;
            tempCtx.fillText(footerText, tempCanvas.width / 2, canvas.height + 10);
            tempCtx.restore();
        }
        
        return tempCanvas.toDataURL('image/png');
    }
    
    // Helper function to get TXT content as string
    function getTXTContent() {
        const filename = getDownloadFilename();
        const now = new Date();
        
        return `Perforated panel Designer Specification File
-----------------------------
Generated: ${now.toLocaleString()}
FileID: ${filename}

[Global Config]
TotalWidth: ${inputs.w.value}
TotalHeight: ${inputs.h.value}
Pitch: ${inputs.pitch.value}
Gap: ${inputs.edge.value}
MinHole: ${inputs.min.value}
MaxHole: ${inputs.max.value}
Invert: ${inputs.invert.checked}

[Layout]
SplitMode: ${splitMode.value}
SplitsW: ${inputs.splitW.value}
SplitsH: ${inputs.splitH.value}

[Margins]
MarginTop: ${inputs.mT.value}
MarginBottom: ${inputs.mB.value}
MarginLeft: ${inputs.mL.value}
MarginRight: ${inputs.mR.value}

[Image Settings]
ImageFit: ${imgFitMode.value}
ImageScale: ${inputs.imgScale.value}
ImagePanX: ${inputs.imgPanX.value}
ImagePanY: ${inputs.imgPanY.value}

[Stats]
TotalHoles: ${document.getElementById('statCount').innerText}
OpenArea: ${document.getElementById('statArea').innerText}
`;
    }
    
    // Function to download shareable HTML file
    function downloadShareableHTML() {
        if (!sourceImage || generatedHoles.length === 0) {
            alert('Please upload an image and generate a pattern first.');
            return;
        }
        
        // Get image data
        const imageData = getPNGDataURL();
        if (!imageData) {
            alert('Failed to generate image. Please try again.');
            return;
        }
        
        // Get settings
        const settings = {
            projectName: projectNameInput ? projectNameInput.value : '',
            w: inputs.w.value,
            h: inputs.h.value,
            pitch: inputs.pitch.value,
            edge: inputs.edge.value,
            min: inputs.min.value,
            max: inputs.max.value,
            invert: inputs.invert.checked,
            splitW: inputs.splitW.value,
            splitH: inputs.splitH.value,
            mT: inputs.mT.value,
            mB: inputs.mB.value,
            mL: inputs.mL.value,
            mR: inputs.mR.value,
            imgFit: imgFitMode.value,
            imgScale: inputs.imgScale.value,
            imgPanX: inputs.imgPanX.value,
            imgPanY: inputs.imgPanY.value,
            splitMode: splitMode.value,
            lockRatio: lockRatioCheckbox.checked,
            lockMode: lockPitchRadio.checked ? 'pitch' : 'gap',
            panelAlignment: panelAlignment,
            showPercentage: showPercentage,
            percentageSize: percentageSize,
            includeFooterStatsInDownload: includeFooterStatsInDownload
        };
        
        // Create design data object
        const designData = {
            image: imageData,
            settings: settings
        };
        
        // Encode data for URL
        const encodedData = encodeURIComponent(btoa(JSON.stringify(designData)));
        const shareUrl = 'https://ppd.ehsanmo.me/?shared=' + encodedData;
        
        // Escape HTML attribute values (for value attribute in input)
        const escapeHtmlAttr = (str) => {
            return String(str)
                .replace(/&/g, '&amp;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');
        };
        
        // Create HTML content - build it piece by piece to avoid template literal issues
        const htmlParts = [];
        htmlParts.push('<!DOCTYPE html>');
        htmlParts.push('<html lang="en">');
        htmlParts.push('<head>');
        htmlParts.push('    <meta charset="UTF-8">');
        htmlParts.push('    <meta name="viewport" content="width=device-width, initial-scale=1.0">');
        htmlParts.push('    <title>Perforated Panel Design - Shareable File</title>');
        htmlParts.push('    <style>');
        htmlParts.push('        * { margin: 0; padding: 0; box-sizing: border-box; }');
        htmlParts.push('        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 20px; }');
        htmlParts.push('        .container { background: white; border-radius: 16px; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3); max-width: 600px; width: 100%; padding: 40px; text-align: center; }');
        htmlParts.push('        h1 { color: #333; margin-bottom: 20px; font-size: 24px; }');
        htmlParts.push('        .message { color: #666; margin-bottom: 30px; font-size: 16px; line-height: 1.6; }');
        htmlParts.push('        .preview { margin: 30px 0; border: 2px solid #e0e0e0; border-radius: 8px; overflow: hidden; max-width: 100%; }');
        htmlParts.push('        .preview img { width: 100%; height: auto; display: block; }');
        htmlParts.push('        .buttons { display: flex; gap: 15px; justify-content: center; margin-top: 30px; }');
        htmlParts.push('        button, a.btn-open { padding: 12px 30px; font-size: 16px; font-weight: 600; border: none; border-radius: 8px; cursor: pointer; transition: all 0.3s ease; text-decoration: none; display: inline-block; }');
        htmlParts.push('        .btn-open { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; }');
        htmlParts.push('        .btn-open:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4); }');
        htmlParts.push('        .btn-close { background: #f0f0f0; color: #333; }');
        htmlParts.push('        .btn-close:hover { background: #e0e0e0; }');
        htmlParts.push('        .url-section { margin-top: 20px; padding: 15px; background: #f5f5f5; border-radius: 8px; font-size: 12px; color: #666; }');
        htmlParts.push('        .url-section input { width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 11px; background: white; margin-top: 10px; }');
        htmlParts.push('        .url-section button { margin-top: 8px; padding: 6px 12px; background: #667eea; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px; }');
        htmlParts.push('    </style>');
        htmlParts.push('</head>');
        htmlParts.push('<body>');
        htmlParts.push('    <div class="container">');
        htmlParts.push('        <h1>Perforated Panel Design</h1>');
        htmlParts.push('        <p class="message">Do you want to open this file? You are navigating to <strong>https://ppd.ehsanmo.me/</strong></p>');
        htmlParts.push('        <div class="preview">');
        htmlParts.push('            <img src="' + imageData.replace(/"/g, '&quot;') + '" alt="Perforated Panel Design Preview">');
        htmlParts.push('        </div>');
        htmlParts.push('        <div class="buttons">');
        htmlParts.push('            <a href="' + shareUrl.replace(/"/g, '&quot;') + '" target="_blank" class="btn-open">Open</a>');
        htmlParts.push('            <button class="btn-close" onclick="window.close()">Close</button>');
        htmlParts.push('        </div>');
        htmlParts.push('        <div class="url-section">');
        htmlParts.push('            <p style="margin-bottom: 10px;"><strong>Note:</strong> If the button doesn\'t work, copy and paste this URL into your browser:</p>');
        htmlParts.push('            <input type="text" id="shareUrlInput" value="' + escapeHtmlAttr(shareUrl) + '" readonly onclick="this.select();">');
        htmlParts.push('            <button onclick="copyUrl()">Copy URL</button>');
        htmlParts.push('        </div>');
        htmlParts.push('    </div>');
        htmlParts.push('    <script>');
        htmlParts.push('        function copyUrl() {');
        htmlParts.push('            var input = document.getElementById("shareUrlInput");');
        htmlParts.push('            input.select();');
        htmlParts.push('            input.setSelectionRange(0, 99999);');
        htmlParts.push('            document.execCommand("copy");');
        htmlParts.push('            alert("URL copied to clipboard!");');
        htmlParts.push('        }');
        htmlParts.push('    <' + '/script>');
        htmlParts.push('</body>');
        htmlParts.push('</html>');
        
        const htmlContent = htmlParts.join('\n');
        
        // Create blob and download
        const blob = new Blob([htmlContent], { type: 'text/html' });
        const link = document.createElement('a');
        const filename = getDownloadFilename();
        link.download = `${filename}_shareable.html`;
        link.href = URL.createObjectURL(blob);
        link.click();
        
        // Track download if user is logged in
        if (authManager.currentUser) {
            authManager.trackDownload('html').catch(err => {
                console.warn('Failed to track download:', err);
            });
        }
    }
    
    // Helper function to get DXF content as string
    function getDXFContent() {
        if (generatedHoles.length === 0) return null;
        const totalH = parseFloat(inputs.h.value);
        const totalW = parseFloat(inputs.w.value);

        // Minimal DXF R12 format - simplest possible for maximum compatibility
        let dxf = "";
        
        // Header - minimal required
        dxf += "0\nSECTION\n2\nHEADER\n";
        dxf += "9\n$ACADVER\n1\nAC1009\n";
        dxf += "0\nENDSEC\n";
        
        // Tables - minimal required
        dxf += "0\nSECTION\n2\nTABLES\n";
        
        // Layer table - only layer 0 required
        dxf += "0\nTABLE\n2\nLAYER\n70\n1\n";
        dxf += "0\nLAYER\n2\n0\n70\n0\n62\n7\n6\nCONTINUOUS\n";
        dxf += "0\nENDTAB\n";
        
        dxf += "0\nENDSEC\n";

        // Entities section
        dxf += "0\nSECTION\n2\nENTITIES\n";

        // Draw panel boundaries as simple POLYLINE
        sheetDefinitions.forEach(s => {
            dxf += "0\nPOLYLINE\n8\n0\n66\n1\n70\n1\n";
            dxf += "0\nVERTEX\n8\n0\n10\n" + s.x.toFixed(3) + "\n20\n" + (totalH - s.y).toFixed(3) + "\n";
            dxf += "0\nVERTEX\n8\n0\n10\n" + (s.x + s.w).toFixed(3) + "\n20\n" + (totalH - s.y).toFixed(3) + "\n";
            dxf += "0\nVERTEX\n8\n0\n10\n" + (s.x + s.w).toFixed(3) + "\n20\n" + (totalH - (s.y + s.h)).toFixed(3) + "\n";
            dxf += "0\nVERTEX\n8\n0\n10\n" + s.x.toFixed(3) + "\n20\n" + (totalH - (s.y + s.h)).toFixed(3) + "\n";
            dxf += "0\nSEQEND\n8\n0\n";
        });
        
        // Draw holes as circles
        generatedHoles.forEach(h => {
            const dxfY = totalH - h.y;
            dxf += "0\nCIRCLE\n8\n0\n";
            dxf += "10\n" + h.x.toFixed(3) + "\n";
            dxf += "20\n" + dxfY.toFixed(3) + "\n";
            dxf += "30\n0.0\n";
            dxf += "40\n" + h.r.toFixed(3) + "\n";
        });
        
        // Draw percentage text if enabled
        if (showPercentage && panelStats.length > 0) {
            panelStats.forEach((stat, idx) => {
                if (idx < sheetDefinitions.length && stat.panelArea > 0) {
                    const sheet = sheetDefinitions[idx];
                    const percentage = stat.panelArea > 0 ? ((stat.openArea / stat.panelArea) * 100).toFixed(1) : "0.0";
                    const textX = sheet.x + sheet.w / 2;
                    const textY = totalH - (sheet.y + sheet.h / 2);
                    
                    dxf += "0\nTEXT\n8\n0\n";
                    dxf += "10\n" + textX.toFixed(3) + "\n";
                    dxf += "20\n" + textY.toFixed(3) + "\n";
                    dxf += "30\n0.0\n";
                    dxf += "40\n10.0\n";
                    dxf += "1\n" + percentage + "%\n";
                    dxf += "50\n0.0\n";
                }
            });
        }
        
        // Add footer statistics if enabled
        if (includeFooterStatsInDownload) {
            const stats = getFooterStatistics();
            const footerY = totalH + 20; // Position below the design
            const fontSize = 8.0;
            const startX = totalW / 2 - 100; // Center the text
            
            dxf += "0\nTEXT\n8\n0\n";
            dxf += "10\n" + startX.toFixed(3) + "\n";
            dxf += "20\n" + footerY.toFixed(3) + "\n";
            dxf += "30\n0.0\n";
            dxf += "40\n" + fontSize.toFixed(1) + "\n";
            dxf += "1\nPanels: " + stats.panels + " | Holes: " + stats.holes.toLocaleString() + " | Opening: " + stats.opening + " | Min Hole: " + stats.minHole + "mm | Max Hole: " + stats.maxHole + "mm | Spacing: " + stats.spacing + "mm\n";
            dxf += "50\n0.0\n";
        }

        dxf += "0\nENDSEC\n";
        dxf += "0\nEOF\n";
        
        return dxf;
    }
    
    // Helper function to get SVG content as string
    function getSVGContent() {
        if (generatedHoles.length === 0) return null;
        const totalH = parseFloat(inputs.h.value);
        const totalW = parseFloat(inputs.w.value);
        const footerHeight = includeFooterStatsInDownload ? 20 : 0;
        const svgHeight = totalH + footerHeight;
        
        let svg = '<?xml version="1.0" encoding="UTF-8"?>\n';
        svg += '<svg xmlns="http://www.w3.org/2000/svg" ';
        svg += `width="${totalW}mm" height="${svgHeight}mm" `;
        svg += `viewBox="0 0 ${totalW} ${svgHeight}">\n`;
        svg += '<g transform="translate(0,' + totalH + ') scale(1,-1)">\n'; // Flip Y axis
        
        // Draw panel boundaries
        svg += '<g id="panels" stroke="#0000FF" stroke-width="0.5" fill="none">\n';
        sheetDefinitions.forEach(s => {
            svg += `<rect x="${s.x}" y="${s.y}" width="${s.w}" height="${s.h}"/>\n`;
        });
        svg += '</g>\n';
        
        // Draw holes
        svg += '<g id="holes" fill="#000000">\n';
        generatedHoles.forEach(h => {
            svg += `<circle cx="${h.x.toFixed(3)}" cy="${h.y.toFixed(3)}" r="${h.r.toFixed(3)}"/>\n`;
        });
        svg += '</g>\n';
        
        // Draw percentage text if enabled
        if (showPercentage && panelStats.length > 0) {
            svg += '<g id="text" fill="#000000" font-family="Arial" font-size="10" text-anchor="middle">\n';
            panelStats.forEach((stat, idx) => {
                if (idx < sheetDefinitions.length && stat.panelArea > 0) {
                    const sheet = sheetDefinitions[idx];
                    const percentage = stat.panelArea > 0 ? ((stat.openArea / stat.panelArea) * 100).toFixed(1) : "0.0";
                    const textX = sheet.x + sheet.w / 2;
                    const textY = sheet.y + sheet.h / 2;
                    svg += `<text x="${textX.toFixed(3)}" y="${textY.toFixed(3)}">${percentage}%</text>\n`;
                }
            });
            svg += '</g>\n';
        }
        
        svg += '</g>\n';
        
        // Add footer statistics if enabled
        if (includeFooterStatsInDownload) {
            const stats = getFooterStatistics();
            const footerY = totalH + 20; // Position below the design
            svg += `<text x="${totalW / 2}" y="${footerY}" fill="#000000" font-family="Arial" font-size="8" text-anchor="middle">Panels: ${stats.panels} | Holes: ${stats.holes.toLocaleString()} | Opening: ${stats.opening} | Min Hole: ${stats.minHole}mm | Max Hole: ${stats.maxHole}mm | Spacing: ${stats.spacing}mm</text>\n`;
        }
        
        svg += '</svg>';
        
        return svg;
    }
    
    async function downloadZIP() {
        if (!sourceImage || generatedHoles.length === 0) {
            alert('Please generate a pattern first.');
            return;
        }
        
        if (typeof JSZip === 'undefined') {
            alert('ZIP library not loaded. Please refresh the page.');
            return;
        }
        
        const filename = getDownloadFilename();
        const zip = new JSZip();
        
        try {
            // Add PNG file
            const pngDataURL = getPNGDataURL();
            if (pngDataURL) {
                const pngBase64 = pngDataURL.split(',')[1];
                zip.file(`${filename}.png`, pngBase64, { base64: true });
            }
            
            // Add TXT file
            const txtContent = getTXTContent();
            zip.file(`${filename}.txt`, txtContent);
            
            // Add DXF file
            const dxfContent = getDXFContent();
            if (dxfContent) {
                zip.file(`${filename}.dxf`, dxfContent);
            }
            
            // Add SVG file
            const svgContent = getSVGContent();
            if (svgContent) {
                zip.file(`${filename}.svg`, svgContent);
            }
            
            // Generate zip file
            const zipBlob = await zip.generateAsync({ type: 'blob' });
            
            // Download
            const link = document.createElement('a');
            link.download = `${filename}.zip`;
            link.href = URL.createObjectURL(zipBlob);
            link.click();
            
            // Clean up
            URL.revokeObjectURL(link.href);
        } catch (error) {
            console.error('Error creating ZIP file:', error);
            alert('Error creating ZIP file. Please try again.');
        }
    }
    
    // ========== AUTHENTICATION SYSTEM ==========
    
    // Firebase Configuration - REPLACE WITH YOUR FIREBASE CONFIG
    const firebaseConfig = {
        apiKey: "AIzaSyDyaAtK5YBWpMedGCICayR-VJq2111SpgU",
        authDomain: "perforated-panel-designer.firebaseapp.com",
        projectId: "perforated-panel-designer",
        storageBucket: "perforated-panel-designer.firebasestorage.app",
        messagingSenderId: "203709637797",
        appId: "1:203709637797:web:544190529c7c874aaf994c"
    };
    
    // Initialize Firebase
    if (typeof firebase !== 'undefined') {
        try {
            firebase.initializeApp(firebaseConfig);
            console.log('Firebase initialized successfully');
        } catch (error) {
            console.error('Firebase initialization error:', error);
        }
    } else {
        console.error('Firebase SDK not loaded');
    }
    
    // Auth Manager
    const authManager = {
        auth: null,
        db: null,
        currentUser: null,
        isAdmin: false,
        adminUsername: 'admin', // Will be set from environment
        adminPassword: 'admin123', // Will be set from environment
        
        init() {
            if (typeof firebase === 'undefined') {
                console.warn('Firebase not loaded. Auth features disabled.');
                return;
            }
            
            this.auth = firebase.auth();
            this.db = firebase.firestore();
            
            // Check admin credentials from environment (Cloudflare Pages)
            // For now, using defaults - will be overridden by env vars in production
            if (window.ADMIN_USERNAME) this.adminUsername = window.ADMIN_USERNAME;
            if (window.ADMIN_PASSWORD) this.adminPassword = window.ADMIN_PASSWORD;
            
            // Listen for auth state changes
            this.auth.onAuthStateChanged((user) => {
                this.currentUser = user;
                this.checkAdminStatus();
                updateAuthUI();
            });
            
            // Check admin session
            this.checkAdminSession();
        },
        
        async checkAdminStatus() {
            if (!this.currentUser) {
                this.isAdmin = false;
                return;
            }
            try {
                const userDoc = await this.db.collection('users').doc(this.currentUser.uid).get();
                this.isAdmin = userDoc.exists && userDoc.data().isAdmin === true;
            } catch (e) {
                this.isAdmin = false;
            }
        },
        
        checkAdminSession() {
            const adminSession = sessionStorage.getItem('adminSession');
            if (adminSession === 'true') {
                this.isAdmin = true;
            }
        },
        
        async signInWithEmail(email, password) {
            try {
                await this.auth.signInWithEmailAndPassword(email, password);
                await this.trackLogin();
                return { success: true };
            } catch (error) {
                return { success: false, error: error.message };
            }
        },
        
        async signUpWithEmail(email, password) {
            try {
                const userCredential = await this.auth.createUserWithEmailAndPassword(email, password);
                await this.db.collection('users').doc(userCredential.user.uid).set({
                    email: email,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    isAdmin: false,
                    downloadCount: 0
                });
                await this.trackLogin();
                return { success: true };
            } catch (error) {
                return { success: false, error: error.message };
            }
        },
        
        async signInWithGoogle() {
            try {
                if (!this.auth) {
                    return { success: false, error: 'Firebase not initialized. Please refresh the page.' };
                }
                
                const provider = new firebase.auth.GoogleAuthProvider();
                // Add scopes if needed
                provider.addScope('profile');
                provider.addScope('email');
                
                // Set custom parameters
                provider.setCustomParameters({
                    prompt: 'select_account'
                });
                
                const userCredential = await this.auth.signInWithPopup(provider);
                
                // Try to update Firestore, but don't fail login if it doesn't work
                try {
                    if (this.db) {
                        // Check if user document exists, create if not
                        const userDoc = await this.db.collection('users').doc(userCredential.user.uid).get();
                        if (!userDoc.exists) {
                            await this.db.collection('users').doc(userCredential.user.uid).set({
                                email: userCredential.user.email,
                                displayName: userCredential.user.displayName || '',
                                photoURL: userCredential.user.photoURL || '',
                                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                                isAdmin: false,
                                downloadCount: 0
                            });
                        } else {
                            // Update last login
                            await this.db.collection('users').doc(userCredential.user.uid).update({
                                lastLogin: firebase.firestore.FieldValue.serverTimestamp()
                            });
                        }
                        
                        // Track login (non-blocking)
                        this.trackLogin().catch(err => {
                            console.warn('Failed to track login:', err);
                        });
                    }
                } catch (dbError) {
                    // Log but don't fail - authentication succeeded
                    console.warn('Firestore operation failed, but login succeeded:', dbError);
                    
                    // Provide helpful error message if it's a permissions issue
                    if (dbError.code === 'permission-denied' || dbError.message.includes('permission')) {
                        console.error('Firestore permission denied. Please check your Firestore security rules.');
                        // Don't show alert to user - login still succeeded
                    }
                    
                    // Try to track login in background
                    this.trackLogin().catch(err => {
                        console.warn('Failed to track login:', err);
                    });
                }
                
                return { success: true };
            } catch (error) {
                console.error('Google sign-in error:', error);
                let errorMessage = error.message;
                
                // Provide more helpful error messages
                if (error.code === 'auth/popup-blocked') {
                    errorMessage = 'Popup was blocked by your browser. Please allow popups for this site and try again.';
                } else if (error.code === 'auth/popup-closed-by-user') {
                    errorMessage = 'Sign-in popup was closed. Please try again.';
                } else if (error.code === 'auth/unauthorized-domain') {
                    errorMessage = 'This domain is not authorized for Google sign-in. Please contact support.';
                } else if (error.code === 'auth/operation-not-allowed') {
                    errorMessage = 'Google sign-in is not enabled. Please enable it in Firebase Console.';
                }
                
                return { success: false, error: errorMessage };
            }
        },
        
        async resetPassword(email) {
            try {
                await this.auth.sendPasswordResetEmail(email);
                return { success: true };
            } catch (error) {
                return { success: false, error: error.message };
            }
        },
        
        async signOut() {
            try {
                await this.auth.signOut();
                sessionStorage.removeItem('adminSession');
                this.currentUser = null;
                this.isAdmin = false;
                updateAuthUI();
                return { success: true };
            } catch (error) {
                return { success: false, error: error.message };
            }
        },
        
        async trackLogin() {
            if (!this.currentUser || !this.db) return;
            try {
                await this.db.collection('loginLogs').add({
                    userId: this.currentUser.uid,
                    email: this.currentUser.email,
                    timestamp: firebase.firestore.FieldValue.serverTimestamp()
                });
            } catch (e) {
                // Silently fail - don't block login if Firestore is unavailable
                console.warn('Failed to track login (non-critical):', e.message);
            }
        },
        
        async trackDownload(fileType) {
            if (!this.currentUser || !this.db) return;
            try {
                await this.db.collection('downloads').add({
                    userId: this.currentUser.uid,
                    email: this.currentUser.email,
                    fileType: fileType,
                    timestamp: firebase.firestore.FieldValue.serverTimestamp()
                });
                await this.db.collection('users').doc(this.currentUser.uid).update({
                    downloadCount: firebase.firestore.FieldValue.increment(1)
                });
            } catch (e) {
                // Silently fail - don't block downloads if Firestore is unavailable
                console.warn('Failed to track download (non-critical):', e.message);
            }
        },
        
        async adminLogin(username, password) {
            if (username === this.adminUsername && password === this.adminPassword) {
                sessionStorage.setItem('adminSession', 'true');
                this.isAdmin = true;
                updateAuthUI();
                return { success: true };
            }
            return { success: false, error: 'Invalid admin credentials' };
        },
        
        canDownload(fileType) {
            if (!this.currentUser) {
                return fileType === 'png' || fileType === 'txt';
            }
            return true;
        }
    };
    
    // Get superadmin email from config
    function getSuperAdminEmail() {
        // First try environment variable (set by Cloudflare Pages build process)
        if (window.SUPERADMIN_EMAIL) {
            return window.SUPERADMIN_EMAIL;
        }
        // Then try config file
        if (window.ADMIN_CONFIG && window.ADMIN_CONFIG.SUPERADMIN_EMAIL) {
            return window.ADMIN_CONFIG.SUPERADMIN_EMAIL;
        }
        return null;
    }
    
    // Auth UI Functions
    function updateAuthUI() {
        const userInfo = document.getElementById('userInfo');
        const guestInfo = document.getElementById('guestInfo');
        const userEmail = document.getElementById('userEmail');
        const adminBtn = document.getElementById('adminBtn');
        const adminPanelLink = document.getElementById('adminPanelLink');
        
        if (authManager.currentUser) {
            userInfo.classList.remove('hidden');
            userInfo.classList.add('flex');
            guestInfo.classList.add('hidden');
            guestInfo.classList.remove('flex');
            userEmail.textContent = authManager.currentUser.email;
            
            // Check if user is superadmin
            const superAdminEmail = getSuperAdminEmail();
            const isSuperAdmin = superAdminEmail && 
                authManager.currentUser.email.toLowerCase() === superAdminEmail.toLowerCase();
            
            // Show admin panel link in user menu if superadmin
            if (adminPanelLink) {
                if (isSuperAdmin) {
                    adminPanelLink.classList.remove('hidden');
                } else {
                    adminPanelLink.classList.add('hidden');
                }
            }
            
            // Show admin button in navbar if admin (legacy support)
            if (authManager.isAdmin) {
                adminBtn.classList.remove('hidden');
            } else {
                adminBtn.classList.add('hidden');
            }
        } else {
            userInfo.classList.add('hidden');
            userInfo.classList.remove('flex');
            guestInfo.classList.remove('hidden');
            guestInfo.classList.add('flex');
            adminBtn.classList.add('hidden');
            if (adminPanelLink) {
                adminPanelLink.classList.add('hidden');
            }
        }
        
        // Update download button visibility
        updateDownloadButtons();
    }
    
    // User Menu Toggle
    function toggleUserMenu() {
        const dropdown = document.getElementById('userMenuDropdown');
        dropdown.classList.toggle('hidden');
    }
    
    // Close user menu when clicking outside
    document.addEventListener('click', (e) => {
        const menuContainer = document.getElementById('userMenuContainer');
        const dropdown = document.getElementById('userMenuDropdown');
        if (menuContainer && !menuContainer.contains(e.target)) {
            dropdown.classList.add('hidden');
        }
    });
    
    // Check if user signed in with Google
    function isGoogleUser() {
        if (!authManager.currentUser) return false;
        const providers = authManager.currentUser.providerData || [];
        return providers.some(provider => provider.providerId === 'google.com');
    }
    
    // Change Password Functions
    function showChangePasswordModal() {
        document.getElementById('changePasswordModal').classList.add('active');
        document.getElementById('userMenuDropdown').classList.add('hidden');
        
        // Check if user is Google-authenticated
        const isGoogle = isGoogleUser();
        const currentPasswordGroup = document.getElementById('currentPasswordGroup');
        const currentPasswordLabel = document.getElementById('currentPasswordLabel');
        
        if (isGoogle) {
            // Hide current password field for Google users
            if (currentPasswordGroup) {
                currentPasswordGroup.style.display = 'none';
            }
            if (currentPasswordLabel) {
                currentPasswordLabel.textContent = 'Set Password (Google users can set a password)';
            }
        } else {
            // Show current password field for email/password users
            if (currentPasswordGroup) {
                currentPasswordGroup.style.display = 'block';
            }
            if (currentPasswordLabel) {
                currentPasswordLabel.textContent = 'Current Password';
            }
        }
        
        // Clear form
        document.getElementById('currentPassword').value = '';
        document.getElementById('newPassword').value = '';
        document.getElementById('confirmPassword').value = '';
        document.getElementById('changePasswordError').classList.remove('show');
        document.getElementById('changePasswordSuccess').classList.remove('show');
    }
    
    function closeChangePasswordModal() {
        document.getElementById('changePasswordModal').classList.remove('active');
    }
    
    async function handleChangePassword() {
        const currentPassword = document.getElementById('currentPassword').value;
        const newPassword = document.getElementById('newPassword').value;
        const confirmPassword = document.getElementById('confirmPassword').value;
        const errorEl = document.getElementById('changePasswordError');
        const successEl = document.getElementById('changePasswordSuccess');
        
        // Clear previous messages
        errorEl.classList.remove('show');
        successEl.classList.remove('show');
        
        // Check if user is Google-authenticated
        const isGoogle = isGoogleUser();
        
        // Validation - skip current password for Google users
        if (!isGoogle && !currentPassword) {
            errorEl.textContent = 'Current password is required';
            errorEl.classList.add('show');
            return;
        }
        
        if (!newPassword || !confirmPassword) {
            errorEl.textContent = 'New password fields are required';
            errorEl.classList.add('show');
            return;
        }
        
        if (newPassword.length < 6) {
            errorEl.textContent = 'New password must be at least 6 characters';
            errorEl.classList.add('show');
            return;
        }
        
        if (newPassword !== confirmPassword) {
            errorEl.textContent = 'New passwords do not match';
            errorEl.classList.add('show');
            return;
        }
        
        try {
            const user = authManager.currentUser;
            
            if (isGoogle) {
                // For Google users, we need to link email/password provider first
                // But Firebase requires re-authentication for security
                // For Google users setting password for the first time, we'll use updatePassword
                // which should work if the account has email/password linked, or we'll get an error
                try {
                    await user.updatePassword(newPassword);
                    successEl.textContent = 'Password set successfully! You can now use email/password to login.';
                } catch (updateError) {
                    if (updateError.code === 'auth/requires-recent-login') {
                        errorEl.textContent = 'For security, please sign out and sign in again, then set your password.';
                        errorEl.classList.add('show');
                        return;
                    } else {
                        // Try to link email/password provider
                        // This requires the user to have a password already set
                        errorEl.textContent = 'Unable to set password. Please contact support or try signing in with Google again.';
                        errorEl.classList.add('show');
                        return;
                    }
                }
            } else {
                // For email/password users, re-authenticate first
                const credential = firebase.auth.EmailAuthProvider.credential(
                    user.email,
                    currentPassword
                );
                await user.reauthenticateWithCredential(credential);
                await user.updatePassword(newPassword);
                successEl.textContent = 'Password changed successfully!';
            }
            
            successEl.classList.add('show');
            
            // Clear form
            document.getElementById('currentPassword').value = '';
            document.getElementById('newPassword').value = '';
            document.getElementById('confirmPassword').value = '';
            
            // Close modal after 2 seconds
            setTimeout(() => {
                closeChangePasswordModal();
            }, 2000);
            
        } catch (error) {
            errorEl.textContent = error.message || 'Failed to change password';
            errorEl.classList.add('show');
        }
    }
    
    function updateDownloadButtons() {
        // Update button styling and lock icons based on user permissions
        const dxfBtn = document.getElementById('downloadDxfBtn');
        const svgBtn = document.getElementById('downloadSvgBtn');
        const dxfLockIcon = document.getElementById('dxfLockIcon');
        const svgLockIcon = document.getElementById('svgLockIcon');
        const zipLockIcon = document.getElementById('zipLockIcon');
        
        // DXF Button - always visible, show lock for guests
        if (dxfBtn) {
            dxfBtn.style.display = 'flex';
            const canDownload = authManager.canDownload('dxf');
            if (dxfLockIcon) {
                dxfLockIcon.style.display = canDownload ? 'none' : 'block';
            }
            // Update button styling for locked state
            if (canDownload) {
                dxfBtn.classList.remove('opacity-60', 'cursor-not-allowed');
                dxfBtn.classList.add('cursor-pointer');
            } else {
                dxfBtn.classList.add('opacity-60', 'cursor-not-allowed');
                dxfBtn.classList.remove('cursor-pointer');
            }
        }
        
        // SVG Button - always visible, show lock for guests
        if (svgBtn) {
            svgBtn.style.display = 'flex';
            const canDownload = authManager.canDownload('svg');
            if (svgLockIcon) {
                svgLockIcon.style.display = canDownload ? 'none' : 'block';
            }
            // Update button styling for locked state
            if (canDownload) {
                svgBtn.classList.remove('opacity-60', 'cursor-not-allowed');
                svgBtn.classList.add('cursor-pointer');
            } else {
                svgBtn.classList.add('opacity-60', 'cursor-not-allowed');
                svgBtn.classList.remove('cursor-pointer');
            }
        }
        
        // ZIP Button - always visible, show lock for guests
        const zipBtn = document.getElementById('downloadZipBtn');
        if (zipBtn) {
            zipBtn.style.display = 'flex';
            const canDownloadZip = authManager.canDownload('zip');
            if (zipLockIcon) {
                zipLockIcon.style.display = canDownloadZip ? 'none' : 'block';
            }
            // Update button styling for locked state
            if (canDownloadZip) {
                zipBtn.classList.remove('opacity-60', 'cursor-not-allowed');
                zipBtn.classList.add('cursor-pointer');
            } else {
                zipBtn.classList.add('opacity-60', 'cursor-not-allowed');
                zipBtn.classList.remove('cursor-pointer');
            }
        }
        
        // Shareable HTML Button - only visible for registered users
        const shareableBtn = document.getElementById('downloadShareableBtn');
        if (shareableBtn) {
            if (authManager.currentUser) {
                shareableBtn.classList.remove('hidden');
                shareableBtn.style.display = 'flex';
            } else {
                shareableBtn.classList.add('hidden');
                shareableBtn.style.display = 'none';
            }
        }
        
    }
    
    // Handle download button clicks with permission check
    function handleDownloadClick(type) {
        if (!authManager.canDownload(type)) {
            alert('You need to register/login to download ' + type.toUpperCase() + ' files. Please sign up or login to access this feature.');
            showAuthModal();
            toggleDownloadsMenu(); // Close the dropdown
            return;
        }
        
        // User has permission, proceed with download using window functions for tracking
        if (type === 'dxf') {
            window.downloadDXF();
        } else if (type === 'svg') {
            window.downloadSVG();
        } else if (type === 'zip') {
            window.downloadZIP();
        }
        toggleDownloadsMenu(); // Close the dropdown after download
    }
    
    // Downloads Menu Toggle
    function toggleDownloadsMenu() {
        const dropdown = document.getElementById('downloadsMenuDropdown');
        dropdown.classList.toggle('hidden');
    }
    
    // Close downloads menu when clicking outside
    document.addEventListener('click', (e) => {
        const menuContainer = document.getElementById('downloadsMenuContainer');
        const dropdown = document.getElementById('downloadsMenuDropdown');
        if (menuContainer && !menuContainer.contains(e.target)) {
            dropdown.classList.add('hidden');
        }
    });
    
    function showAuthModal() {
        document.getElementById('authModal').classList.add('active');
        switchAuthTab('login');
    }
    
    function closeAuthModal() {
        document.getElementById('authModal').classList.remove('active');
    }
    
    function switchAuthTab(tab) {
        document.querySelectorAll('.auth-tab').forEach(t => t.classList.remove('active'));
        document.getElementById('loginForm').style.display = tab === 'login' ? 'block' : 'none';
        document.getElementById('registerForm').style.display = tab === 'register' ? 'block' : 'none';
        document.getElementById('forgotForm').style.display = tab === 'forgot' ? 'block' : 'none';
        
        if (tab === 'login') document.querySelectorAll('.auth-tab')[0].classList.add('active');
        if (tab === 'register') document.querySelectorAll('.auth-tab')[1].classList.add('active');
        
        // Clear errors
        document.querySelectorAll('.error-message').forEach(e => {
            e.classList.remove('show');
            e.textContent = '';
        });
    }
    
    async function handleLogin() {
        const email = document.getElementById('loginEmail').value;
        const password = document.getElementById('loginPassword').value;
        const errorEl = document.getElementById('loginError');
        
        const result = await authManager.signInWithEmail(email, password);
        if (result.success) {
            closeAuthModal();
        } else {
            errorEl.textContent = result.error;
            errorEl.classList.add('show');
        }
    }
    
    async function handleRegister() {
        const email = document.getElementById('registerEmail').value;
        const password = document.getElementById('registerPassword').value;
        const errorEl = document.getElementById('registerError');
        
        if (password.length < 6) {
            errorEl.textContent = 'Password must be at least 6 characters';
            errorEl.classList.add('show');
            return;
        }
        
        const result = await authManager.signUpWithEmail(email, password);
        if (result.success) {
            closeAuthModal();
        } else {
            errorEl.textContent = result.error;
            errorEl.classList.add('show');
        }
    }
    
    async function handleGoogleLogin() {
        const result = await authManager.signInWithGoogle();
        if (result.success) {
            closeAuthModal();
        } else {
            alert('Google login failed: ' + result.error);
        }
    }
    
    async function handleForgotPassword() {
        const email = document.getElementById('forgotEmail').value;
        const errorEl = document.getElementById('forgotError');
        const successEl = document.getElementById('forgotSuccess');
        
        const result = await authManager.resetPassword(email);
        if (result.success) {
            successEl.textContent = 'Password reset email sent!';
            successEl.classList.add('show');
            errorEl.classList.remove('show');
        } else {
            errorEl.textContent = result.error;
            errorEl.classList.add('show');
            successEl.classList.remove('show');
        }
    }
    
    // Admin Panel Functions
    function showAdminPanel() {
        document.getElementById('adminModal').classList.add('active');
        if (!authManager.isAdmin) {
            document.getElementById('adminLoginForm').style.display = 'block';
            document.getElementById('adminPanelContent').style.display = 'none';
        } else {
            loadAdminData();
        }
    }
    
    function closeAdminPanel() {
        document.getElementById('adminModal').classList.remove('active');
    }
    
    async function handleAdminLogin() {
        const username = document.getElementById('adminUsername').value;
        const password = document.getElementById('adminPassword').value;
        const errorEl = document.getElementById('adminLoginError');
        
        const result = await authManager.adminLogin(username, password);
        if (result.success) {
            document.getElementById('adminLoginForm').style.display = 'none';
            document.getElementById('adminPanelContent').style.display = 'block';
            loadAdminData();
        } else {
            errorEl.textContent = result.error;
            errorEl.classList.add('show');
        }
    }
    
    async function loadAdminData() {
        if (!authManager.isAdmin || !authManager.db) return;
        
        try {
            // Get total users
            const usersSnapshot = await authManager.db.collection('users').get();
            document.getElementById('totalUsers').textContent = usersSnapshot.size;
            
            // Get total downloads
            const downloadsSnapshot = await authManager.db.collection('downloads').get();
            document.getElementById('totalDownloads').textContent = downloadsSnapshot.size;
            
            // Get downloads today
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const todayDownloads = downloadsSnapshot.docs.filter(doc => {
                const timestamp = doc.data().timestamp;
                if (timestamp && timestamp.toDate) {
                    return timestamp.toDate() >= today;
                }
                return false;
            });
            document.getElementById('downloadsToday').textContent = todayDownloads.length;
            
            // Populate users table
            const tbody = document.getElementById('usersTableBody');
            tbody.innerHTML = '';
            usersSnapshot.forEach(doc => {
                const user = doc.data();
                const row = tbody.insertRow();
                row.insertCell(0).textContent = user.email || 'N/A';
                row.insertCell(1).textContent = user.downloadCount || 0;
                row.insertCell(2).textContent = user.lastLogin ? 
                    new Date(user.lastLogin.toDate()).toLocaleDateString() : 'Never';
            });
        } catch (e) {
            console.error('Failed to load admin data:', e);
        }
    }
    
    // Wrap download functions to check permissions and track downloads
    const originalDownloadImage = downloadImage;
    window.downloadImage = async function() {
        if (!authManager.canDownload('png')) {
            alert('Please login to download PNG files');
            showAuthModal();
            return;
        }
        if (authManager.currentUser) {
            await authManager.trackDownload('png');
        }
        // Check if there's content to download
        if (typeof originalDownloadImage === 'function') {
            originalDownloadImage();
        } else {
            alert('No image to download. Please upload an image and generate the pattern first.');
        }
    };
    
    const originalDownloadSpecs = downloadSpecs;
    window.downloadSpecs = async function() {
        if (!authManager.canDownload('txt')) {
            alert('Please login to download settings files');
            showAuthModal();
            return;
        }
        if (authManager.currentUser) {
            await authManager.trackDownload('txt');
        }
        // Check if there's content to download
        if (typeof originalDownloadSpecs === 'function') {
            originalDownloadSpecs();
        } else {
            alert('No settings to download. Please configure and generate a pattern first.');
        }
    };
    
    const originalDownloadDXF = downloadDXF;
    window.downloadDXF = async function() {
        if (!authManager.canDownload('dxf')) {
            alert('Please register/login to download DXF files');
            showAuthModal();
            return;
        }
        await authManager.trackDownload('dxf');
        // Check if there's content to download
        if (typeof originalDownloadDXF === 'function') {
            originalDownloadDXF();
        } else {
            alert('No pattern to download. Please generate a pattern first.');
        }
    };
    
    const originalDownloadSVG = downloadSVG;
    window.downloadSVG = async function() {
        if (!authManager.canDownload('svg')) {
            alert('Please register/login to download SVG files');
            showAuthModal();
            return;
        }
        await authManager.trackDownload('svg');
        // Check if there's content to download
        if (typeof originalDownloadSVG === 'function') {
            originalDownloadSVG();
        } else {
            alert('No pattern to download. Please generate a pattern first.');
        }
    };
    
    const originalDownloadZIP = downloadZIP;
    window.downloadZIP = async function() {
        if (!authManager.canDownload('zip')) {
            alert('Please register/login to download ZIP files');
            showAuthModal();
            return;
        }
        await authManager.trackDownload('zip');
        // Check if there's content to download
        if (typeof originalDownloadZIP === 'function') {
            await originalDownloadZIP();
        } else {
            alert('No pattern to download. Please generate a pattern first.');
        }
    };
    
    // Initialize auth on page load
    if (typeof firebase !== 'undefined') {
        authManager.init();
    } else {
        // Wait for Firebase to load
        window.addEventListener('load', () => {
            if (typeof firebase !== 'undefined') {
                authManager.init();
            }
        });
    }
    
    // Make authManager globally available
    window.authManager = authManager;
    window.updateAuthUI = updateAuthUI;
    window.showAuthModal = showAuthModal;
    window.closeAuthModal = closeAuthModal;
    window.switchAuthTab = switchAuthTab;
    window.handleLogin = handleLogin;
    window.handleRegister = handleRegister;
    window.handleGoogleLogin = handleGoogleLogin;
    window.handleForgotPassword = handleForgotPassword;
    window.showAdminPanel = showAdminPanel;
    window.closeAdminPanel = closeAdminPanel;
    window.handleAdminLogin = handleAdminLogin;
    window.toggleUserMenu = toggleUserMenu;
    window.showChangePasswordModal = showChangePasswordModal;
    window.closeChangePasswordModal = closeChangePasswordModal;
    window.handleChangePassword = handleChangePassword;
    window.toggleDownloadsMenu = toggleDownloadsMenu;
    window.handleDownloadClick = handleDownloadClick;
</script>

</div> <!-- End main-wrapper -->

<footer class="bg-white border-t border-gray-200 py-2 text-center text-sm text-gray-600">
    <div style="display: flex; justify-content: space-around; align-items: center; max-width: 1200px; margin: 0 auto; padding: 0 20px; gap: 40px;">
        <div style="padding: 0 10px;">
            <strong>Panels:</strong> <span id="footerPanels">0</span>
        </div>
        <div style="padding: 0 10px;">
            <strong>Holes:</strong> <span id="footerHoles">0</span>
        </div>
        <div style="padding: 0 10px;">
            <strong>Opening:</strong> <span id="footerOpening">0%</span>
        </div>
        <div style="padding: 0 10px;">
            <strong>Min Hole:</strong> <span id="footerMinHole">0</span>mm
        </div>
        <div style="padding: 0 10px;">
            <strong>Max Hole:</strong> <span id="footerMaxHole">0</span>mm
        </div>
        <div style="padding: 0 10px;">
            <strong>Spacing:</strong> <span id="footerSpacing">0</span>mm
        </div>
        <div style="margin-left: auto; padding: 0 10px;">
            Designed by Ehsan Mokhtary
        </div>
    </div>
</footer>

</body></html>