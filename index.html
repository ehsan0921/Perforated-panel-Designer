<!-- 
    Perforated Panel Designer
    Generated by Ehsan Mokhtary
    Email: Ehsan0921@gmail.com
-->
<html lang="en"><head><script>(function(firebaseConfig, initialAuthToken, appId) {
        window.__firebase_config = firebaseConfig;
        window.__initial_auth_token = initialAuthToken;
        window.__app_id = appId;
            })("\n{\n  \"apiKey\": \"AIzaSyCqyCcs2R2e7AegGjvFAwG98wlamtbHvZY\",\n  \"authDomain\": \"bard-frontend.firebaseapp.com\",\n  \"projectId\": \"bard-frontend\",\n  \"storageBucket\": \"bard-frontend.firebasestorage.app\",\n  \"messagingSenderId\": \"175205271074\",\n  \"appId\": \"1:175205271074:web:2b7bd4d34d33bf38e6ec7b\"\n}\n","eyJhbGciOiJSUzI1NiIsImtpZCI6ImQ1OTQzZDdlNWZhYTIxZjcyOTJjMzI3MGY3ZDBjNWJmNDE5MjJmOTciLCJ0eXAiOiJKV1QifQ.eyJzdWIiOiJmaXJlYmFzZS1hZG1pbnNkay1mYnN2Y0BiYXJkLWZyb250ZW5kLmlhbS5nc2VydmljZWFjY291bnQuY29tIiwiYXVkIjoiaHR0cHM6Ly9pZGVudGl0eXRvb2xraXQuZ29vZ2xlYXBpcy5jb20vZ29vZ2xlLmlkZW50aXR5LmlkZW50aXR5dG9vbGtpdC52MS5JZGVudGl0eVRvb2xraXQiLCJ1aWQiOiIwMjA4MjI3NjA1MjU3NzkzMzk0OSIsImlzcyI6ImZpcmViYXNlLWFkbWluc2RrLWZic3ZjQGJhcmQtZnJvbnRlbmQuaWFtLmdzZXJ2aWNlYWNjb3VudC5jb20iLCJjbGFpbXMiOnsiYXBwSWQiOiJjXzJiMTk3NGEzMGI3M2ZhNzBfaW5kZXguaHRtbC05NCJ9LCJleHAiOjE3NzAzNDAzMDksImlhdCI6MTc3MDMzNjcwOSwiYWxnIjoiUlMyNTYifQ.lzfQS4YlmwqJVA3NlHIWYS4DG741f2Px5kGIZab4nyosg7zfxzJJOnA_2lvb4G0aHUQ39WYpI9x3jsCUCJdk4QNjZM8a7T8rjQCCLYMMdO7b__AZUsq7Plp-WoR_a5lkfPYvIqKQzPFC1PZPdzkvTBZULB6A7NqyqIRXse9PHMqDbJekbHcmgs4a-JazGS6SjrKPJHYrEymiow-uljTglw8B_TVFNLMIKhTJJkLoSNdVpIGZ_6wv2ktacUhCAa0mesNUduX5wx36rYmlnN4E788XyGtgeDwLYZl_1OXjL0sXeWwWG_nO7b_DsqKKXN7ttJ3l7T1cbN5eFjGg6ZRxXQ","c_2b1974a30b73fa70_index.html-94")</script><script>'use strict';var h=typeof Object.defineProperties=="function"?Object.defineProperty:function(a,b,d){if(a==Array.prototype||a==Object.prototype)return a;a[b]=d.value;return a};function l(a){a=["object"==typeof globalThis&&globalThis,a,"object"==typeof window&&window,"object"==typeof self&&self,"object"==typeof global&&global];for(var b=0;b<a.length;++b){var d=a[b];if(d&&d.Math==Math)return d}throw Error("Cannot find global object");}var n=l(this);
function p(a,b){if(b)a:{var d=n;a=a.split(".");for(var c=0;c<a.length-1;c++){var e=a[c];if(!(e in d))break a;d=d[e]}a=a[a.length-1];c=d[a];b=b(c);b!=c&&b!=null&&h(d,a,{configurable:!0,writable:!0,value:b})}}function r(a){function b(c){return a.next(c)}function d(c){return a.throw(c)}return new Promise(function(c,e){function f(g){g.done?c(g.value):Promise.resolve(g.value).then(b,d).then(f,e)}f(a.next())})}function t(a){return r(a())}
p("Object.values",function(a){return a?a:function(b){var d=[],c;for(c in b)Object.prototype.hasOwnProperty.call(b,c)&&d.push(b[c]);return d}});p("Array.prototype.includes",function(a){return a?a:function(b,d){var c=this;c instanceof String&&(c=String(c));var e=c.length;d=d||0;for(d<0&&(d=Math.max(d+e,0));d<e;d++){var f=c[d];if(f===b||Object.is(f,b))return!0}return!1}});/*

 MIT License

 Copyright (c) 2017-2023 W.Y.

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.

*/
function u(a,b){const d=a.style;b.backgroundColor&&(d.backgroundColor=b.backgroundColor);b.width&&(d.width=`${b.width}px`);b.height&&(d.height=`${b.height}px`);const c=b.style;c!=null&&Object.keys(c).forEach(e=>{d[e]=c[e]})};var v=(()=>{let a=0;return()=>{a+=1;return`u${`0000${(Math.random()*1679616<<0).toString(36)}`.slice(-4)}${a}`}})();function w(a){const b=[];for(let d=0,c=a.length;d<c;d++)b.push(a[d]);return b}let x=null;function y(a={}){return x?x:a.l?x=a.l:x=w(window.getComputedStyle(document.documentElement))}function z(a,b){return(a=(a.ownerDocument.defaultView||window).getComputedStyle(a).getPropertyValue(b))?parseFloat(a.replace("px","")):0}
function A(a,b={}){var d;if(!(d=b.width)){d=z(a,"border-left-width");var c=z(a,"border-right-width");d=a.clientWidth+d+c}(b=b.height)||(b=z(a,"border-top-width"),c=z(a,"border-bottom-width"),b=a.clientHeight+b+c);return{width:d,height:b}}function B(a){return new Promise((b,d)=>{const c=new Image;c.onload=()=>{c.decode().then(()=>{requestAnimationFrame(()=>b(c))})};c.onerror=d;c.crossOrigin="anonymous";c.decoding="async";c.src=a})}
function C(a){return t(function*(){return Promise.resolve().then(()=>(new XMLSerializer).serializeToString(a)).then(encodeURIComponent).then(b=>`data:image/svg+xml;charset=utf-8,${b}`)})}
function D(a,b,d){return t(function*(){const c=document.createElementNS("http://www.w3.org/2000/svg","svg"),e=document.createElementNS("http://www.w3.org/2000/svg","foreignObject");c.setAttribute("width",`${b}`);c.setAttribute("height",`${d}`);c.setAttribute("viewBox",`0 0 ${b} ${d}`);e.setAttribute("width","100%");e.setAttribute("height","100%");e.setAttribute("x","0");e.setAttribute("y","0");e.setAttribute("externalResourcesRequired","true");c.appendChild(e);e.appendChild(a);return C(c)})}
var E=(a,b)=>{if(a instanceof b)return!0;a=Object.getPrototypeOf(a);return a===null?!1:a.constructor.name===b.name||E(a,b)};function F(a,b){return y(b).map(d=>{const c=a.getPropertyValue(d),e=a.getPropertyPriority(d);return`${d}: ${c}${e?" !important":""};`}).join(" ")}
function G(a,b,d,c){a=window.getComputedStyle(a,d);var e=a.getPropertyValue("content");if(e!==""&&e!=="none"){var f=v();try{b.className=`${b.className} ${f}`}catch(k){return}e=document.createElement("style");var g=e.appendChild;d=`.${f}:${d}`;a.cssText?(c=a.getPropertyValue("content"),c=`${a.cssText} content: '${c.replace(/'|"/g,"")}';`):c=F(a,c);g.call(e,document.createTextNode(`${d}{${c}}`));b.appendChild(e)}};function H(a){return a.search(/^(data:)/)!==-1}function I(a,b,d){return t(function*(){const c=yield fetch(a,b);if(c.status===404)throw Error(`Resource "${c.url}" not found`);const e=yield c.blob();return new Promise((f,g)=>{const k=new FileReader;k.onerror=g;k.onloadend=()=>{try{f(d({o:c,result:k.result}))}catch(m){g(m)}};k.readAsDataURL(e)})})}const J={};function K(a,b,d){let c=a.replace(/\?.*/,"");d&&(c=a);/ttf|otf|eot|woff2?/i.test(c)&&(c=c.replace(/.*\//,""));return b?`[${b}]${c}`:c}
function L(a,b,d){return t(function*(){const c=K(a,b,d.C);if(J[c]!=null)return J[c];d.u&&(a+=(/\?/.test(a)?"&":"?")+(new Date).getTime());let e;try{const f=yield I(a,d.i,({o:g,result:k})=>{b||(b=g.headers.get("Content-Type")||"");return k.split(/,/)[1]});e=`data:${b};base64,${f}`}catch(f){e=d.B||""}return J[c]=e})};const M={P:"application/font-woff",R:"application/font-woff",N:"application/font-truetype",v:"application/vnd.ms-fontobject",H:"image/png",F:"image/jpeg",D:"image/jpeg",A:"image/gif",M:"image/tiff",L:"image/svg+xml",O:"image/webp"};function N(a){return(a=/\.([^./]*?)$/g.exec(a))?a[1]:""};function O(a){return t(function*(){const b=a.toDataURL();return b==="data:,"?a.cloneNode(!1):B(b)})}function aa(a,b){return t(function*(){if(a.currentSrc){var d=document.createElement("canvas");const c=d.getContext("2d");d.width=a.clientWidth;d.height=a.clientHeight;c==null||c.drawImage(a,0,0,d.width,d.height);d=d.toDataURL();return B(d)}d=a.poster;d=yield L(d,M[N(d).toLowerCase()]||"",b);return B(d)})}
function ba(a,b){return t(function*(){try{let d;if(a==null?0:(d=a.contentDocument)==null?0:d.body)return yield P(a.contentDocument.body,b,!0)}catch(d){}return a.cloneNode(!1)})}function ca(a,b){return t(function*(){return E(a,HTMLCanvasElement)?O(a):E(a,HTMLVideoElement)?aa(a,b):E(a,HTMLIFrameElement)?ba(a,b):a.cloneNode(a.tagName!=null&&a.tagName.toUpperCase()==="SVG")})}
function da(a,b,d){return t(function*(){if(b.tagName!=null&&b.tagName.toUpperCase()==="SVG")return b;let c=[];if(a.tagName!=null&&a.tagName.toUpperCase()==="SLOT"&&a.assignedNodes)c=w(a.assignedNodes());else{let e;if(E(a,HTMLIFrameElement)&&((e=a.contentDocument)==null?0:e.body))c=w(a.contentDocument.body.childNodes);else{let f;c=w(((f=a.shadowRoot)!=null?f:a).childNodes)}}if(c.length===0||E(a,HTMLVideoElement))return b;yield c.reduce((e,f)=>e.then(()=>P(f,d)).then(g=>{g&&b.appendChild(g)}),Promise.resolve());
return b})}function ea(a,b,d){const c=b.style;if(c){var e=window.getComputedStyle(a);e.cssText?(c.cssText=e.cssText,c.transformOrigin=e.transformOrigin):y(d).forEach(f=>{let g=e.getPropertyValue(f);f==="font-size"&&g.endsWith("px")&&(g=`${Math.floor(parseFloat(g.substring(0,g.length-2)))-.1}px`);E(a,HTMLIFrameElement)&&f==="display"&&g==="inline"&&(g="block");f==="d"&&b.getAttribute("d")&&(g=`path(${b.getAttribute("d")})`);c.setProperty(f,g,e.getPropertyPriority(f))})}}
function fa(a,b){E(a,HTMLSelectElement)&&(b=Array.from(b.children).find(d=>a.value===d.getAttribute("value")))&&b.setAttribute("selected","")}
function ha(a,b){return t(function*(){var d=a.querySelectorAll?a.querySelectorAll("use"):[];if(d.length===0)return a;var c={};for(var e=0;e<d.length;e++){var f=d[e].getAttribute("xlink:href");if(f){const g=document.querySelector(f);a.querySelector(f)||!g||c[f]||(c[f]=yield P(g,b,!0))}}d=Object.values(c);if(d.length){c=document.createElementNS("http://www.w3.org/1999/xhtml","svg");c.setAttribute("xmlns","http://www.w3.org/1999/xhtml");c.style.position="absolute";c.style.width="0";c.style.height="0";
c.style.overflow="hidden";c.style.display="none";e=document.createElementNS("http://www.w3.org/1999/xhtml","defs");c.appendChild(e);for(f=0;f<d.length;f++)e.appendChild(d[f]);a.appendChild(c)}return a})}
function P(a,b,d){return t(function*(){return d||!b.filter||b.filter(a)?Promise.resolve(a).then(c=>ca(c,b)).then(c=>da(a,c,b)).then(c=>{E(c,Element)&&(ea(a,c,b),G(a,c,":before",b),G(a,c,":after",b),E(a,HTMLTextAreaElement)&&(c.textContent=a.value),E(a,HTMLInputElement)&&c.setAttribute("value",a.value),fa(a,c));return c}).then(c=>ha(c,b)):null})};const Q=/url\((['"]?)([^'"]+?)\1\)/g,ia=/url\([^)]+\)\s*format\((["']?)([^"']+)\1\)/g,ja=/src:\s*(?:url\([^)]+\)\s*format\([^)]+\)[,;]\s*)+/g;function ka(a){const b=[];a.replace(Q,(d,c,e)=>{b.push(e);return d});return b.filter(d=>!H(d))}
function la(a,b,d,c){return t(function*(){try{const e=d?(new URL(b,d||void 0)).toString():b;let f;f=yield L(e,M[N(b).toLowerCase()]||"",c);return a.replace(new RegExp(`(url\\(['"]?)(${b.replace(/([.*+?^${}()|\[\]\/\\])/g,"\\$1")})(['"]?\\))`,"g"),`$1${f}$3`)}catch(e){}return a})}function ma(a,{I:b}){return b?a.replace(ja,d=>{for(;;){const [c,,e]=ia.exec(d)||[],f=c,g=e;if(!g)return"";if(g===b)return`src: ${f};`}}):a}
function R(a,b,d){return t(function*(){if(a.search(Q)===-1)return a;const c=ma(a,d);return ka(c).reduce((e,f)=>e.then(g=>la(g,f,b,d)),Promise.resolve(c))})};function S(a,b,d){return t(function*(){var c;const e=(c=b.style)==null?void 0:c.getPropertyValue(a);return e?(c=yield R(e,null,d),b.style.setProperty(a,c,b.style.getPropertyPriority(a)),!0):!1})}function na(a,b){return t(function*(){(yield S("background",a,b))||(yield S("background-image",a,b));(yield S("mask",a,b))||(yield S("-webkit-mask",a,b))||(yield S("mask-image",a,b))||(yield S("-webkit-mask-image",a,b))})}
function oa(a,b){return t(function*(){const d=E(a,HTMLImageElement);if(d&&!H(a.src)||E(a,SVGImageElement)&&!H(a.href.baseVal)){var c=d?a.src:a.href.baseVal,e=yield L(c,M[N(c).toLowerCase()]||"",b);yield new Promise((f,g)=>{a.onload=f;a.onerror=b.m?(...k)=>{try{f(b.m(...k))}catch(m){g(m)}}:g;a.decode&&(a.decode=f);a.loading==="lazy"&&(a.loading="eager");d?(a.srcset="",a.src=e):a.href.baseVal=e})}})}
function pa(a,b){return t(function*(){const d=w(a.childNodes).map(c=>T(c,b));yield Promise.all(d).then(()=>a)})}function T(a,b){return t(function*(){E(a,Element)&&(yield na(a,b),yield oa(a,b),yield pa(a,b))})};const U={};function V(a){return t(function*(){var b=U[a];if(b!=null)return b;b=yield(yield fetch(a)).text();b={url:a,cssText:b};return U[a]=b})}function W(a,b){return t(function*(){let d=a.cssText;const c=/url\(["']?([^"')]+)["']?\)/g,e=(d.match(/url\([^)]+\)/g)||[]).map(f=>t(function*(){let g=f.replace(c,"$1");g.startsWith("https://")||(g=(new URL(g,a.url)).href);return I(g,b.i,({result:k})=>{d=d.replace(f,`url(${k})`);return[f,k]})}));return Promise.all(e).then(()=>d)})}
function X(a){if(a==null)return[];const b=[];a=a.replace(/(\/\*[\s\S]*?\*\/)/gi,"");for(var d=RegExp("((@.*?keyframes [\\s\\S]*?){([\\s\\S]*?}\\s*?)})","gi");;){var c=d.exec(a);if(c===null)break;b.push(c[0])}a=a.replace(d,"");d=/@import[\s\S]*?url\([^)]*\)[\s\S]*?;/gi;for(c=RegExp("((\\s*?(?:\\/\\*[\\s\\S]*?\\*\\/)?\\s*?@media[\\s\\S]*?){([\\s\\S]*?)}\\s*?})|(([\\s\\S]*?){([\\s\\S]*?)})","gi");;){let e=d.exec(a);if(e===null)if(e=c.exec(a),e===null)break;else d.lastIndex=c.lastIndex;else c.lastIndex=
d.lastIndex;b.push(e[0])}return b}
function qa(a,b){return t(function*(){const d=[],c=[];a.forEach(e=>{if("cssRules"in e)try{w(e.cssRules||[]).forEach((f,g)=>{if(f.type===CSSRule.IMPORT_RULE){let k=g+1;f=V(f.href).then(m=>W(m,b)).then(m=>X(m).forEach(q=>{try{e.insertRule(q,q.startsWith("@import")?k+=1:e.cssRules.length)}catch(Da){}})).catch(()=>{});c.push(f)}})}catch(f){const g=a.find(k=>k.href==null)||document.styleSheets[0];e.href!=null&&c.push(V(e.href).then(k=>W(k,b)).then(k=>X(k).forEach(m=>{g.insertRule(m,g.cssRules.length)})).catch(()=>
{}))}});return Promise.all(c).then(()=>{a.forEach(e=>{if("cssRules"in e)try{w(e.cssRules||[]).forEach(f=>{d.push(f)})}catch(f){}});return d})})}function ra(a){return a.filter(b=>b.type===CSSRule.FONT_FACE_RULE).filter(b=>b.style.getPropertyValue("src").search(Q)!==-1)}function sa(a,b){return t(function*(){if(a.ownerDocument==null)throw Error("Provided element is not within a Document");var d=w(a.ownerDocument.styleSheets);d=yield qa(d,b);return ra(d)})}
function ta(a){function b(c){(c.style.fontFamily||getComputedStyle(c).fontFamily).split(",").forEach(e=>{d.add(e.trim().replace(/["']/g,""))});Array.from(c.children).forEach(e=>{e instanceof HTMLElement&&b(e)})}const d=new Set;b(a);return d}function ua(a,b){return t(function*(){const d=yield sa(a,b),c=ta(a);return(yield Promise.all(d.filter(e=>c.has(e.style.fontFamily.trim().replace(/["']/g,""))).map(e=>R(e.cssText,e.parentStyleSheet?e.parentStyleSheet.href:null,b)))).join("\n")})}
function va(a,b){return t(function*(){const d=b.j!=null?b.j:b.K?null:yield ua(a,b);if(d){const c=document.createElement("style");c.appendChild(document.createTextNode(d));a.firstChild?a.insertBefore(c,a.firstChild):a.appendChild(c)}})};function wa(a,b={}){return t(function*(){const {width:d,height:c}=A(a,b),e=yield P(a,b,!0);yield va(e,b);yield T(e,b);u(e,b);return yield D(e,d,c)})}
function xa(a,b={}){return t(function*(){const {width:d,height:c}=A(a,b);var e=yield wa(a,b);e=yield B(e);const f=document.createElement("canvas"),g=f.getContext("2d"),k=b.G||window.devicePixelRatio||1,m=b.h||d,q=b.g||c;f.width=m*k;f.height=q*k;!b.J&&(f.width>16384||f.height>16384)&&(f.width>16384&&f.height>16384?f.width>f.height?(f.height*=16384/f.width,f.width=16384):(f.width*=16384/f.height,f.height=16384):f.width>16384?(f.height*=16384/f.width,f.width=16384):(f.width*=16384/f.height,f.height=
16384));f.style.width=`${m}`;f.style.height=`${q}`;b.backgroundColor&&(g.fillStyle=b.backgroundColor,g.fillRect(0,0,f.width,f.height));g.drawImage(e,0,0,f.width,f.height);return f})}function ya(a,b={}){return t(function*(){return(yield xa(a,b)).toDataURL()})};const za=["gemini.google.com","corp.google.com","proxy.googlers.com"];function Y(){return document.body.querySelectorAll('[class*="animate"]').length>0}function Z(a){return t(function*(){try{return yield ya(a,{h:a.offsetWidth,g:a.offsetHeight})}catch(d){var b=a.offsetHeight;const c=document.createElement("canvas");c.width=a.offsetWidth;c.height=b;return c.toDataURL("image/png")}})}
function Aa(){return t(function*(){const a=document.body.offsetWidth,b=document.body.offsetHeight,d=document.body.cloneNode(!0);d.querySelectorAll('[class*="animate"]').forEach(c=>{c.classList.remove(...Array.from(c.classList).filter(e=>e.startsWith("animate")))});d.style.width=`${a}px`;d.style.height=`${b}px`;return d})}
function Ba(a){return t(function*(){let b=document.body;if(Y()){var d=yield Aa();b=d;document.body.appendChild(d)}d=yield Z(b);Y()&&document.body.removeChild(b);window.parent.postMessage({type:"SEND_SCREENSHOT",image:d,topOffset:document.documentElement.scrollTop},a.origin)})}function Ca(a){return t(function*(){const b={type:"SEND_SCREENSHOT_FOR_DATA_VISUALIZATION",image:yield Z(document.body),topOffset:0};window.parent.postMessage(b,a.origin)})}
window.addEventListener("message",a=>t(function*(){if(za.some(d=>a.origin.includes(d))){var b=a.data;b&&(b.type==="MAKE_SCREENSHOT"&&(yield Ba(a)),b.type==="MAKE_SCREENSHOT_FOR_DATA_VISUALIZATION"&&(yield Ca(a)))}}));
</script><script>(function() {
  // Ensure this script is executed only once
  if (window.firebaseAuthBridgeScriptLoaded) {
    return;
  }
  window.firebaseAuthBridgeScriptLoaded = true;

  let nextTokenPromiseId = 0;

  // Stores { resolve, reject } for ongoing token requests
  const pendingTokenPromises = {};

  // Listen for messages from the Host Application
  window.addEventListener('message', function(event) {

    const messageData = event.data;

  if (messageData && messageData.type === 'RESOLVE_NEW_FIREBASE_TOKEN') {
      const { success, token, error, promiseId } = messageData ?? {};
      if (pendingTokenPromises[promiseId]) {
        if (success) {
          pendingTokenPromises[promiseId].resolve(token);
        } else {
          pendingTokenPromises[promiseId].reject(new Error(error || 'Token refresh failed from host.'));
        }
        delete pendingTokenPromises[promiseId];
      }
    }
  });

  // Expose a function for the Generated App to request a new Firebase token
  window.requestNewFirebaseToken = function() {
    const currentPromiseId = nextTokenPromiseId++;
    const promise = new Promise((resolve, reject) => {
      pendingTokenPromises[currentPromiseId] = { resolve, reject };
    });
    if (window.parent && window.parent !== window) {
      window.parent.postMessage({
        type: 'REQUEST_NEW_FIREBASE_TOKEN',
        promiseId: currentPromiseId
      }, '*');
    } else {
      pendingTokenPromises[currentPromiseId].reject(new Error('No parent window to request token from.'));
      delete pendingTokenPromises[currentPromiseId];
    }
    return promise;
  };
})();</script><script>
let realOriginalGetUserMedia = null;
if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
  realOriginalGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
}

(function() {
  if (navigator.mediaDevices && navigator.mediaDevices.__proto__) {
    try {
      Object.defineProperty(navigator.mediaDevices.__proto__, 'getUserMedia', {
        get: function() {
          return undefined; // Or throw an error
        },
        configurable: false
      });
    } catch (error) {
      console.error("Error defining prototype getter:", error);
    }
  }
})();

(function() {
  const pendingMediaResolvers = {};
  let nextMediaPromiseId = 0;

  function requestMediaPermissions(constraints) {
    const mediaPromiseId = nextMediaPromiseId++;
    const promise = new Promise((resolve, reject) => {
      pendingMediaResolvers[mediaPromiseId] = (granted) => {
        delete pendingMediaResolvers[mediaPromiseId];
        resolve(granted);
      };
    });

    window.parent.postMessage({
      type: 'requestMediaPermission',
      constraints: constraints,
      promiseId: mediaPromiseId,
    }, '*');

    return promise;
  }

  let originalGetUserMedia = realOriginalGetUserMedia;

  function interceptGetUserMedia() {
    if (navigator.mediaDevices) {
      Object.defineProperty(navigator.mediaDevices, 'getUserMedia', {
        value: function(constraints) {
          return requestMediaPermissions(constraints).then((granted) => {
            if (granted) {
              if (originalGetUserMedia) {
                return originalGetUserMedia(constraints);
              } else {
                throw new Error("Original getUserMedia not available.");
              }
            } else {
              throw new DOMException('Permission denied', 'NotAllowedError');
            }
          });
        },
        writable: false,
        configurable: false
      });
    }
  }

  interceptGetUserMedia();

  const observer = new MutationObserver(function(mutationsList, observer) {
    for (const mutation of mutationsList) {
      if (mutation.type === 'reconfigured' && mutation.name === 'getUserMedia' && mutation.object === navigator.mediaDevices) {
        interceptGetUserMedia();
      } else if (mutation.type === 'attributes' && mutation.attributeName === 'getUserMedia' && mutation.target === navigator.mediaDevices) {
        interceptGetUserMedia();
      } else if (mutation.type === 'childList' && mutation.addedNodes) {
        mutation.addedNodes.forEach(node => {
          if (node === navigator.mediaDevices) {
            interceptGetUserMedia();
          }
        });
      }
    }
  });

  function interceptSpeechRecognition() {
    if (!window.SpeechRecognition && !window.webkitSpeechRecognition) {
      return;
    }

    const OriginalSpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

    const SpeechRecognitionWrapper = function(...args) {
      const recognizer = new OriginalSpeechRecognition(...args);
      const originalStart = recognizer.start.bind(recognizer);

      recognizer.start = function() {
        requestMediaPermissions({ audio: true }).then(granted => {
          if (granted) {
            originalStart();
          } else {
            const errorEvent = new SpeechRecognitionErrorEvent('error');
            errorEvent.error = 'not-allowed'; // This is the standard error for permission denial.
            recognizer.dispatchEvent(errorEvent);
          }
        });
      };

      return recognizer;
    };

    SpeechRecognitionWrapper.prototype = OriginalSpeechRecognition.prototype;
    SpeechRecognitionWrapper.prototype.constructor = SpeechRecognitionWrapper;

    if (window.SpeechRecognition) {
      window.SpeechRecognition = SpeechRecognitionWrapper;
    }
    if (window.webkitSpeechRecognition) {
      window.webkitSpeechRecognition = SpeechRecognitionWrapper;
    }
  }

  interceptSpeechRecognition();

  window.addEventListener('message', function(event) {
    if (event.data) {
      if (event.data.type === 'resolveMediaPermission') {
        const { promiseId, granted } = event.data;
        if (pendingMediaResolvers[promiseId]) {
          pendingMediaResolvers[promiseId](granted);
        }
      }
    }
  });

})();</script><script>((function(modelInformation) {
  const originalFetch = window.fetch;
  // TODO: b/421908508 - Move these out of the script and match all generative AI model calls.
  let googleLlmBaseApiUrls = [
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.textModelName + ':streamGenerateContent',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.textModelName + ':generateContent',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.imageModelName + ':predict',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.imageModelName + ':predictLongRunning',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.imageEditModelName + ':generateContent',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.imageTransformModelName + ':generateContent',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.videoModelName + ':predict',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.videoModelName + ':predictLongRunning',
    'https://generativelanguage.googleapis.com/v1beta/models/' + modelInformation.ttsModelName + ':generateContent',
  ];
  modelInformation.deprecatedTextModelNames.forEach((modelName) => {
    googleLlmBaseApiUrls.push(
      'https://generativelanguage.googleapis.com/v1beta/models/' + modelName + ':streamGenerateContent',
      'https://generativelanguage.googleapis.com/v1beta/models/' + modelName + ':generateContent',
    );
  });
  modelInformation.deprecatedImageModelNames.forEach((modelName) => {
    googleLlmBaseApiUrls.push(
      'https://generativelanguage.googleapis.com/v1beta/models/' + modelName + ':predict',
      'https://generativelanguage.googleapis.com/v1beta/models/' + modelName + ':predictLongRunning',
    );
  });

  const pendingFetchResolvers = {};
  let nextPromiseId = 0;

  function handleStringInput(input, optionsArgument) {
    const actualUrl = input;
    const fetchCallArgs = [actualUrl, optionsArgument];
    const effectiveOptions = optionsArgument || {};
    const bodyForApiKeyCheck = effectiveOptions.body;
    const bodyForPostMessage = effectiveOptions.body;
    return { actualUrl, fetchCallArgs, effectiveOptions, bodyForApiKeyCheck, bodyForPostMessage };
  }

  function handleRequestInput(input, optionsArgument) {
    const actualUrl = input.url;
    const fetchCallArgs = [input, optionsArgument];
    const effectiveOptions = { method: input.method, headers: new Headers(input.headers) };
    let bodyForApiKeyCheck;
    let bodyForPostMessage;

    if (optionsArgument) {
      if (optionsArgument.method) effectiveOptions.method = optionsArgument.method;
      if (optionsArgument.headers) effectiveOptions.headers = new Headers(optionsArgument.headers);
      if ('body' in optionsArgument) {
        bodyForApiKeyCheck = optionsArgument.body;
        bodyForPostMessage = optionsArgument.body;
      } else {
        bodyForApiKeyCheck = undefined;
        bodyForPostMessage = input.body;
      }
    } else {
      bodyForApiKeyCheck = undefined;
      bodyForPostMessage = input.body;
    }
    return { actualUrl, fetchCallArgs, effectiveOptions, bodyForApiKeyCheck, bodyForPostMessage };
  }

  window.fetch = function(input, optionsArgument) {
    let actualUrl;
    let fetchCallArgs;
    let effectiveOptions = {};
    let bodyForApiKeyCheck;
    let bodyForPostMessage;

    if (typeof input === 'string') {
      ({actualUrl, fetchCallArgs, effectiveOptions, bodyForApiKeyCheck, bodyForPostMessage} = handleStringInput(input, optionsArgument));
    } else if (input instanceof Request) {
      ({actualUrl, fetchCallArgs, effectiveOptions, bodyForApiKeyCheck, bodyForPostMessage} = handleRequestInput(input, optionsArgument));
    } else {
      return originalFetch.apply(window, [input, optionsArgument]);
    }

    effectiveOptions.method = effectiveOptions.method || 'GET';
    if (!effectiveOptions.headers) {
      effectiveOptions.headers = new Headers();
    }


    if (typeof actualUrl === 'string' && googleLlmBaseApiUrls.some((url) => actualUrl.startsWith(url))) {
      let apiKeyIsNull = true;

      const regex = new RegExp("models/([^:]+)");
      const modelNameMatch = actualUrl.match(regex);
      const modelName = modelNameMatch ? modelNameMatch[1] : 'unspecified';


      try {
        const urlObject = new URL(actualUrl);  // Use URL object for robust parsing
        const apiKeyParam = urlObject.searchParams.get('key');
        if (apiKeyParam) {
          apiKeyIsNull = false;
        }
      } catch (e) {
        // Continue checks even if URL parsing fails
      }

      if (apiKeyIsNull && effectiveOptions.headers) {
        const h = new Headers(effectiveOptions.headers);
        const apiKeyHeaderValue = h.get('X-API-Key') || h.get('x-api-key');
        if (apiKeyHeaderValue) {
          apiKeyIsNull = false;
          return originalFetch.apply(window, fetchCallArgs);
        }
      }

      if (apiKeyIsNull && effectiveOptions.method && ['POST', 'PUT', 'PATCH'].includes(effectiveOptions.method.toUpperCase()) && typeof bodyForApiKeyCheck === 'string') {
        try {
          const bodyData = JSON.parse(bodyForApiKeyCheck);
          if (bodyData && bodyData.apiKey) {
            apiKeyIsNull = false;
            return originalFetch.apply(window, fetchCallArgs);
          }
        } catch (e) {
          // Ignore JSON parsing errors
        }
      }

      if(apiKeyIsNull) {
        const promiseId = nextPromiseId++;
        const promise = new Promise((resolve) => {
          pendingFetchResolvers[promiseId] = (resolvedResponse) => {
            delete pendingFetchResolvers[promiseId];
            resolve(resolvedResponse);
          };
        });

        let serializedBodyForPostMessage;
        if (typeof bodyForPostMessage === 'string' || bodyForPostMessage == null) {
            serializedBodyForPostMessage = bodyForPostMessage;
        } else if (bodyForPostMessage instanceof ReadableStream) {
            serializedBodyForPostMessage = null;
        } else {
            try {
                serializedBodyForPostMessage = JSON.stringify(bodyForPostMessage);
            } catch (e) {
                serializedBodyForPostMessage = null;
            }
        }

        const messageOptions = {
            method: effectiveOptions.method,
            headers: Object.fromEntries(new Headers(effectiveOptions.headers).entries()),
            body: serializedBodyForPostMessage
        };

        window.parent.postMessage({
          type: 'requestFetch',
          url: actualUrl,
          modelName: modelName,
          options: messageOptions,
          promiseId: promiseId,
        }, '*');

        return promise;
      }
      return originalFetch.apply(window, fetchCallArgs);
    }
    return originalFetch.apply(window, fetchCallArgs);
  };

  window.addEventListener('message', function(event) {
    if (event.data && event.data.type === 'resolveFetch') {
      const { promiseId, response } = event.data;
      if (pendingFetchResolvers[promiseId]) {
        try {
          const reconstructedResponse = new Response(response.body, {
            status: response.status,
            statusText: response.statusText,
            headers: new Headers(response.headers),
          });
          pendingFetchResolvers[promiseId](reconstructedResponse);
        } catch (error) {
          pendingFetchResolvers[promiseId](new Response(null, { status: 500, statusText: "Interceptor Response Reconstruction Error" }));
        }
      }
    }
  });

}))({"textModelName":"gemini-2.5-flash-preview-09-2025","imageModelName":"imagen-4.0-generate-001","imageEditModelName":"gemini-2.5-flash-image-preview","imageTransformModelName":"gemini-3-pro-image-preview-11-2025","videoModelName":"veo-2.0-generate-001","ttsModelName":"gemini-2.5-flash-preview-tts","deprecatedTextModelNames":["gemini-2.0-flash","gemini-2.5-flash-preview-04-17","gemini-2.5-flash-preview-05-20"],"deprecatedImageModelNames":["imagen-3.0-generate-001","imagen-3.0-generate-002"]})</script><script>(function() {
  const originalConsoleLog = console.log;
  const originalConsoleError = console.error;

    /**
   * Normalizes an error event or a promise rejection reason into a structured error object.
   * @param {*} errorEventOrReason The error object or reason.
   * @return {object} Structured error data { message, name, stack }.
   */
  function getErrorObject(errorEventOrReason) {
    if (errorEventOrReason instanceof Error) {
      return {
        message: errorEventOrReason.message,
        name: errorEventOrReason.name,
        stack: errorEventOrReason.stack,
      };
    }
    // Fallback for non-Error objects.
    try {
      return {
        message: JSON.stringify(errorEventOrReason),
        name: 'UnknownErrorType',
        stack: null,
      };
    } catch (e) {
      return {
        message: String(errorEventOrReason),
        name: 'UnknownErrorTypeNonStringifiable',
        stack: null,
      };
    }
  }

  /**
   * Converts an array of arguments (from log/error) into a single string.
   * Handles Error objects specially to include their message and stack.
   * @param {Array<*>} args - Arguments passed to console methods.
   * @return {string} A string representation of the arguments.
   */
  function stringifyArgs(args) {
    return args
      .map((arg) => {
        if (arg instanceof Error) {
          const {message, stack} = arg;
          return `Error: ${message}${stack ? ('\nStack: ' + stack) : ''}`;
        }
        if (typeof arg === 'object' && arg !== null) {
          try {
            return JSON.stringify(arg);
          } catch (error) {
            return '[Circular Object]';
          }
        } else {
          return String(arg);
        }
      })
      .join(' ');
  }

  console.log = function(...args) {
    const logString = stringifyArgs(args);
    window.parent.postMessage({ type: 'log', message: logString }, '*');
    originalConsoleLog.apply(console, args);
  };

  console.error = function(...args) {
    let errorData;
    if (args.length > 0 && args[0] instanceof Error) {
      const err = args[0];
      // If the first arg is an Error, capture its details.
      errorData = {
        type: 'error',
        source: 'CONSOLE_ERROR',
        ...getErrorObject(err),
        rawArgsString: stringifyArgs(args.slice(1)),
        timestamp: new Date().toISOString(),
      };
    } else {
      // If not an Error object, treat all args as a general error message.
      errorData = {
        type: 'error',
        source: 'CONSOLE_ERROR',
        message: stringifyArgs(args),
        name: 'ConsoleLoggedError',
        stack: null,
        timestamp: new Date().toISOString(),
      };
    }
    window.parent.postMessage(errorData, '*');
    originalConsoleError.apply(console, args);
  };

  // Listen for global unhandled synchronous errors.
  window.addEventListener('error', function(event) {
    const errorDetails = event.error ? getErrorObject(event.error) : {
      message: event.message,
      name: 'GlobalError',
      stack: null,
      filename: event.filename,
      lineno: event.lineno,
      colno: event.colno,
    };

    window.parent.postMessage({
      type: 'error',
      source: 'global',
      ...errorDetails,
      message: errorDetails.message || event.message,
      timestamp: new Date().toISOString(),
    }, '*');
  });

  // Listen for unhandled promise rejections (asynchronous errors).
  window.addEventListener('unhandledrejection', function(event) {
    const errorDetails = getErrorObject(event.reason);

    window.parent.postMessage({
      type: 'error',
      source: 'unhandledrejection',
      ...errorDetails,
      message: errorDetails.message || 'Unhandled Promise Rejection',
      timestamp: new Date().toISOString(),
    }, '*');
  });

})();</script>
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <!-- Admin Config - Load before main script (for superadmin email) -->
    <script src="/admin-config.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Perforated panel Designer</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --primary: #2563eb;
            --primary-hover: #1d4ed8;
            --bg: #f1f5f9;
            --panel-bg: #ffffff;
            --text: #0f172a;
            --border: #e2e8f0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: var(--bg);
            color: var(--text);
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }
        
        /* Main content wrapper to account for header */
        .main-wrapper {
            display: flex;
            flex: 1;
            overflow: hidden;
            margin-top: 0;
        }

        /* Sidebar Layout - z-index above footer so sidebar sits on top of footer */
        aside {
            width: 360px;
            background: var(--panel-bg);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            padding: 20px;
            overflow-y: auto;
            flex-shrink: 0;
            box-shadow: 4px 0 24px rgba(0,0,0,0.05);
            z-index: 110;
        }

        h1 {
            font-size: 1.25rem;
            margin-top: 0;
            margin-bottom: 20px;
            color: var(--primary);
            font-weight: 800;
        }

        h2 {
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #64748b;
            margin-top: 24px;
            margin-bottom: 12px;
            border-bottom: 1px solid var(--border);
            padding-bottom: 5px;
            font-weight: 700;
        }

        /* Form Elements */
        .control-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            font-size: 0.85rem;
            font-weight: 600;
            margin-bottom: 5px;
            color: #334155;
        }

        input[type="number"], 
        input[type="text"],
        select {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid #cbd5e1;
            border-radius: 6px;
            font-size: 0.9rem;
            box-sizing: border-box; 
            font-family: inherit;
        }
        
        select {
            background-color: white;
        }

        input[type="file"] {
            font-size: 0.85rem;
            width: 100%;
        }

        .row {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .row input {
            width: 100%;
        }

        .checkbox-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 10px;
            cursor: pointer;
        }
        
        input[type="checkbox"] {
            width: 16px; 
            height: 16px;
            margin: 0;
        }

        /* Lock Controls */
        .lock-wrapper {
            position: relative;
        }
        .lock-toggle {
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            width: 24px;
            height: 24px;
            border-radius: 4px;
            color: #cbd5e1;
        }
        .lock-toggle:hover {
            color: #94a3b8;
        }
        .lock-toggle input {
            display: none;
        }
        .lock-toggle input:checked + svg {
            fill: var(--primary);
            color: var(--primary);
        }
        .lock-icon {
            width: 16px;
            height: 16px;
            fill: currentColor;
        }

        /* Buttons */
        button {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
            font-size: 0.95rem;
            margin-top: 10px;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
            box-shadow: 0 4px 6px -1px rgba(37, 99, 235, 0.2);
        }

        .btn-primary:hover {
            background: var(--primary-hover);
        }

        .btn-secondary {
            background: white;
            border: 1px solid #cbd5e1;
            color: #334155;
            margin-top: 0;
        }

        .btn-secondary:hover {
            background: #f8fafc;
            border-color: #94a3b8;
        }
        
        .btn-secondary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .btn-small {
            padding: 6px 12px;
            font-size: 0.8rem;
            margin-top: 0;
            width: auto;
        }

        /* Stats Panel */
        #stats {
            background: #f0f9ff;
            border: 1px solid #bae6fd;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            display: none; /* Hidden by default */
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 0.9rem;
        }

        .stat-value {
            font-weight: 700;
            color: var(--primary);
        }
        
        .error-text {
            color: #ef4444;
            font-size: 0.75rem;
            margin-top: 4px;
            display: none;
        }

        /* Main Preview Area */
        main {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #cbd5e1; /* Darker background for contrast */
            position: relative;
            overflow: hidden; 
            cursor: grab;
        }
        
        main:active {
            cursor: grabbing;
        }
        
        /* Pattern Background behind canvas to show transparency if needed */
        main::before {
            content: "";
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            opacity: 0.1;
            background-image: radial-gradient(#64748b 1px, transparent 1px);
            background-size: 20px 20px;
            pointer-events: none;
            z-index: 0;
        }

        #canvas-container {
            /* Container doesn't scroll natively anymore, we use transform for pan */
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center; 
            align-items: center;
            z-index: 1;
            transform-origin: center;
        }

        canvas {
            display: block;
            background: white;
            box-shadow: 0 20px 50px -12px rgba(0, 0, 0, 0.25);
            /* Remove transition for direct pan control */
        }

        small {
            color: #64748b;
            font-size: 0.75rem;
            margin-top: 4px;
            display: block;
        }

        /* Floating Zoom Controls */
        .zoom-controls {
            position: absolute;
            bottom: 30px;
            right: 30px;
            display: flex;
            gap: 8px;
            background: white;
            padding: 8px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 20;
        }

        .zoom-btn {
            width: 40px;
            height: 40px;
            border-radius: 6px;
            background: #f1f5f9;
            color: #334155;
            border: 1px solid #e2e8f0;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0;
            padding: 0;
        }
        
        .zoom-btn:hover {
            background: #e2e8f0;
            color: #0f172a;
        }

        .zoom-btn svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }
        
        .sub-control-panel {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            padding: 10px;
            border-radius: 6px;
            margin-top: 5px;
        }
        
        /* Grid for Download Buttons */
        .download-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 20px;
        }
        
        .download-grid button {
            margin-top: 0;
        }

        .full-width {
            grid-column: span 2;
        }
        
        /* Download Toggle */
        .download-with-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .download-toggle {
            position: relative;
            width: 36px;
            height: 20px;
            background: #cbd5e1;
            border-radius: 10px;
            cursor: pointer;
            transition: background 0.2s;
            flex-shrink: 0;
        }
        
        .download-toggle.active {
            background: var(--primary);
        }
        
        .download-toggle::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: transform 0.2s;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        
        .download-toggle.active::after {
            transform: translateX(16px);
        }
        
        .download-toggle-label {
            font-size: 0.7rem;
            color: #64748b;
            margin-top: 2px;
        }
        
        /* Auth UI Styles - Using Tailwind, keeping modal styles */
        
        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            align-items: center;
            justify-content: center;
        }
        
        .modal.active {
            display: flex;
        }
        
        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 8px;
            max-width: 400px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .modal-header {
            margin-bottom: 20px;
        }
        
        .modal-header h2 {
            margin: 0;
            font-size: 1.5rem;
        }
        
        .modal-close {
            float: right;
            font-size: 1.5rem;
            cursor: pointer;
            color: #64748b;
        }

        /* Navbar buttons â€“ uniform size and style */
        .nav-btn {
            height: 40px;
            padding: 0 1rem;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            border-radius: 8px;
            font-size: 0.875rem;
            font-weight: 500;
            transition: all 0.2s ease;
            white-space: nowrap;
            border: none;
            cursor: pointer;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }
        .nav-btn:hover { box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .nav-btn-primary { background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); color: #fff; }
        .nav-btn-primary:hover { background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%); }
        .nav-btn-secondary { background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%); color: #475569; border: 1px solid #cbd5e1; }
        .nav-btn-secondary:hover { background: linear-gradient(135deg, #e2e8f0 0%, #cbd5e1 100%); }
        .nav-btn-accent { background: linear-gradient(135deg, #6366f1 0%, #4f46e5 100%); color: #fff; }
        .nav-btn-accent:hover { background: linear-gradient(135deg, #4f46e5 0%, #4338ca 100%); }
        .nav-btn-success { background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%); color: #fff; }
        .nav-btn-success:hover { background: linear-gradient(135deg, #16a34a 0%, #15803d 100%); }
        .nav-btn-admin { background: linear-gradient(135deg, #a855f7 0%, #9333ea 100%); color: #fff; }
        .nav-btn-admin:hover { background: linear-gradient(135deg, #9333ea 0%, #7e22ce 100%); }
        .nav-btn-icon { width: 40px; padding: 0; border-radius: 50%; background: #fff; border: 1px solid #e2e8f0; color: #475569; }
        .nav-btn-icon:hover { background: #f8fafc; border-color: #cbd5e1; }

        /* Toast notification */
        #toastContainer {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 8px;
            pointer-events: none;
        }
        .toast {
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 500;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            animation: toastIn 0.3s ease;
            pointer-events: auto;
        }
        .toast.success { background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: #fff; }
        .toast.error { background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); color: #fff; }
        .toast.info { background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); color: #fff; }
        @keyframes toastIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9rem;
            font-weight: 600;
        }
        
        .form-group input {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--border);
            border-radius: 4px;
            font-size: 0.9rem;
            box-sizing: border-box;
        }
        
        .error-message {
            color: #ef4444;
            font-size: 0.8rem;
            margin-top: 5px;
            display: none;
        }
        
        .error-message.show {
            display: block;
        }
        
        .auth-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid var(--border);
        }
        
        .auth-tab {
            padding: 10px 20px;
            cursor: pointer;
            border: none;
            background: none;
            font-size: 0.9rem;
            color: #64748b;
            border-bottom: 2px solid transparent;
            margin-bottom: -2px;
        }
        
        .auth-tab.active {
            color: var(--primary);
            border-bottom-color: var(--primary);
            font-weight: 600;
        }
        
        .admin-panel {
            max-width: 800px;
            width: 90%;
        }
        
        .admin-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .stat-card {
            background: #f8fafc;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid var(--border);
        }
        
        .stat-card h3 {
            margin: 0 0 10px 0;
            font-size: 0.9rem;
            color: #64748b;
        }
        
        .stat-card .value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--primary);
        }
        
        .users-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        
        .users-table th,
        .users-table td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }
        
        .users-table th {
            background: #f8fafc;
            font-weight: 600;
        }
        
        /* Footer Styles - full width; sidebar (z-index 110) sits on top of footer */
        footer {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--panel-bg);
            border-top: 1px solid var(--border);
            padding: 12px 20px;
            z-index: 100;
            text-align: center;
            font-size: 0.85rem;
            color: #64748b;
            line-height: 1.5;
            min-height: 3em;
            overflow: visible;
            box-sizing: border-box;
        }
        /* Footer progress bar */
        .footer-progress-wrap {
            max-width: 1200px;
            margin: 0 auto 8px auto;
            padding: 0 20px;
        }
        .footer-progress-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
            font-size: 0.75rem;
            color: #64748b;
        }
        .footer-progress-bar {
            height: 6px;
            background: #e2e8f0;
            border-radius: 4px;
            overflow: hidden;
        }
        .footer-progress-fill {
            height: 100%;
            width: 0%;
            border-radius: 4px;
            background: linear-gradient(90deg, #3b82f6, #60a5fa);
            transition: width 0.4s ease-out;
        }
        .footer-progress-bar.indeterminate .footer-progress-fill {
            width: 40% !important;
            animation: footer-progress-shimmer 1.2s ease-in-out infinite;
        }
        @keyframes footer-progress-shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(350%); }
        }
        .footer-progress-bar.done .footer-progress-fill {
            width: 100% !important;
            background: linear-gradient(90deg, #10b981, #34d399);
        }
        .footer-one-line {
            display: flex;
            flex-wrap: nowrap;
            align-items: center;
            max-width: 100%;
            margin: 0 auto;
            padding: 0 20px;
            gap: 20px;
            font-size: 0.85rem;
            color: #64748b;
            overflow-x: auto;
            line-height: 1.5;
            min-height: 1.5em;
        }
        .footer-stats-left {
            display: flex;
            flex-wrap: nowrap;
            align-items: center;
            gap: 20px;
            min-width: 0;
        }
        .footer-stats-left > span {
            white-space: nowrap;
        }
        .footer-one-line > span {
            white-space: nowrap;
            flex-shrink: 0;
        }
        .footer-credit {
            flex-shrink: 0;
            margin-left: auto;
            visibility: visible !important;
            min-width: max-content;
            position: sticky;
            right: 0;
            background: #f1f5f9;
            padding: 4px 10px;
            border-radius: 4px;
            border-left: 1px solid #e2e8f0;
        }
        .footer-progress-inline {
            display: inline-flex !important;
            align-items: center;
            gap: 8px;
            min-width: 0;
            margin-right: auto;
        }
        .footer-progress-inline #footerProgressBar {
            background: #e2e8f0;
            border-radius: 2px;
            overflow: hidden;
            width: 110px;
            height: 5px;
        }
        .footer-progress-inline .footer-progress-fill {
            display: block !important;
            height: 5px;
            border-radius: 2px;
        }
        .footer-progress-bar-inline {
            height: 4px;
        }
        
        /* Slider Styles */
        .slider-container {
            margin-top: 10px;
        }
        
        .slider-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
            font-size: 0.85rem;
        }
        
        .slider-value {
            font-weight: 600;
            color: var(--primary);
            min-width: 40px;
            text-align: right;
        }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #e2e8f0;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        input[type="range"]:hover::-webkit-slider-thumb {
            background: var(--primary-hover);
        }
        
        input[type="range"]:hover::-moz-range-thumb {
            background: var(--primary-hover);
        }
        
        /* Alignment Controls */
        .alignment-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 4px;
            margin-top: 10px;
        }
        
        .align-btn {
            width: 100%;
            padding: 8px;
            border: 1px solid #cbd5e1;
            border-radius: 4px;
            background: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            transition: all 0.2s;
        }
        
        .align-btn:hover {
            background: #f1f5f9;
            border-color: var(--primary);
        }
        
        .align-btn.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }
        
        .align-btn svg {
            width: 18px;
            height: 18px;
            fill: currentColor;
        }
        
        .align-center {
            grid-column: 2;
            grid-row: 2;
        }
        
        .toggle-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 10px;
        }
        
        .toggle-switch {
            position: relative;
            width: 44px;
            height: 24px;
            background: #cbd5e1;
            border-radius: 12px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .toggle-switch.active {
            background: var(--primary);
        }
        
        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: transform 0.2s;
        }
        
        .toggle-switch.active::after {
            transform: translateX(20px);
        }

    </style>
</head>
<body>

<!-- Header with Auth -->
<header class="bg-white border-b border-gray-200 shadow-sm sticky top-0 z-50">
    <div class="max-w-full mx-auto px-4 sm:px-6 lg:px-8">
        <div class="flex justify-between items-center h-16">
            <!-- Logo/Title + Project Name & Reset -->
            <div class="flex items-center gap-4 flex-wrap">
                <h1 class="text-xl font-bold text-blue-600">Perforated panel Designer</h1>
                <div class="flex items-center gap-2">
                    <input type="text" id="projectName" name="projectName" placeholder="Enter project name" autocomplete="off" data-form-type="other" class="nav-project-input" style="min-width:140px; max-width:200px; height:40px; padding:0 10px; border:1px solid #e2e8f0; border-radius:6px; font-size:0.875rem;">
                    <button type="button" id="resetSettingsBtn" class="nav-btn nav-btn-secondary" title="Clear stored settings">Reset Settings</button>
                </div>
            </div>

            <!-- Right Side: Actions & Auth -->
            <div class="flex items-center gap-3 ml-auto">
                <!-- Upload Photo -->
                <button type="button" onclick="document.getElementById('fileInput').click()" class="nav-btn nav-btn-primary" title="Upload image">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg>
                    Upload Photo
                </button>

                <!-- View raw photo (input image only) -->
                <button type="button" id="viewRawPhotoBtn" onclick="window.openRawPhotoModal && window.openRawPhotoModal()" class="nav-btn nav-btn-secondary" title="View uploaded image before pattern">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg>
                    View raw photo
                </button>
                
                <!-- Import Settings -->
                <button type="button" onclick="document.getElementById('importFile').click()" class="nav-btn nav-btn-secondary" title="Import settings from file">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path></svg>
                    Import Settings
                </button>
                
                <!-- Downloads Dropdown -->
                <div class="relative" id="downloadsMenuContainer">
                    <button type="button" onclick="toggleDownloadsMenu()" class="nav-btn nav-btn-accent" title="Download files">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path></svg>
                        Downloads
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                    </button>
                    
                    <!-- Downloads Dropdown Menu -->
                    <div id="downloadsMenuDropdown" class="hidden absolute right-0 mt-2 w-52 bg-white rounded-lg shadow-xl border border-gray-200 py-1 z-50">
                        <button id="downloadImgBtn" onclick="window.downloadImage(); toggleDownloadsMenu();" class="w-full text-left px-4 py-2.5 text-sm text-gray-700 hover:bg-blue-50 hover:text-blue-700 transition-colors flex items-center gap-3" disabled>
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
                            </svg>
                            <span class="font-medium">Map (.png)</span>
                        </button>
                        <button id="downloadTxtBtn" onclick="window.downloadSpecs(); toggleDownloadsMenu();" class="w-full text-left px-4 py-2.5 text-sm text-gray-700 hover:bg-blue-50 hover:text-blue-700 transition-colors flex items-center gap-3" disabled>
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                            </svg>
                            <span class="font-medium">Settings (.txt)</span>
                        </button>
                        <button id="downloadDxfBtn" onclick="handleDownloadClick('dxf');" class="w-full text-left px-4 py-2.5 text-sm text-gray-700 hover:bg-blue-50 hover:text-blue-700 transition-colors flex items-center gap-3" disabled>
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                            </svg>
                            <span class="font-medium flex-1">CAD (.dxf)</span>
                            <svg id="dxfLockIcon" class="w-4 h-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" style="display:none;">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"></path>
                            </svg>
                        </button>
                        <button id="downloadSvgBtn" onclick="handleDownloadClick('svg');" class="w-full text-left px-4 py-2.5 text-sm text-gray-700 hover:bg-blue-50 hover:text-blue-700 transition-colors flex items-center gap-3" disabled>
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                            </svg>
                            <span class="font-medium flex-1">Vector (.svg)</span>
                            <svg id="svgLockIcon" class="w-4 h-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" style="display:none;">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"></path>
                            </svg>
                        </button>
                        <button id="downloadZipBtn" onclick="handleDownloadClick('zip');" class="w-full text-left px-4 py-2.5 text-sm text-gray-700 hover:bg-blue-50 hover:text-blue-700 transition-colors flex items-center gap-3" disabled>
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                            </svg>
                            <span class="font-medium flex-1">All Files (.zip)</span>
                            <svg id="zipLockIcon" class="w-4 h-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" style="display:none;">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"></path>
                            </svg>
                        </button>
                    </div>
                </div>
                
                <!-- Auth Section -->
                <div class="flex items-center gap-3 border-l border-gray-300 pl-3 ml-3">
                    <!-- Guest User - Login Button -->
                    <div id="guestInfo" class="flex items-center gap-3">
                        <button type="button" onclick="showAuthModal()" class="nav-btn nav-btn-success">Login / Register</button>
                    </div>
                    
                    <!-- Logged In User - User Menu -->
                    <div id="userInfo" class="hidden flex items-center gap-3">
                        <span id="userEmail" class="text-sm text-gray-600 hidden sm:inline font-medium"></span>
                        
                        <!-- User Icon Dropdown -->
                        <div class="relative" id="userMenuContainer">
                            <button type="button" onclick="toggleUserMenu()" class="nav-btn nav-btn-icon" id="userMenuButton" title="Account menu">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path></svg>
                            </button>
                            
                            <!-- Dropdown Menu -->
                            <div id="userMenuDropdown" class="hidden absolute right-0 mt-2 w-48 bg-white rounded-lg shadow-xl border border-gray-200 py-1 z-50">
                                <a href="#" onclick="showChangePasswordModal(); return false;" class="block px-4 py-2.5 text-sm text-gray-700 hover:bg-blue-50 hover:text-blue-700 transition-colors flex items-center gap-3">
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 7a2 2 0 012 2m4 0a6 6 0 01-7.743 5.743L11 17H9v2H7v2H4a1 1 0 01-1-1v-2.586a1 1 0 01.293-.707l5.964-5.964A6 6 0 1121 9z"></path>
                                    </svg>
                                    <span class="font-medium">Change Password</span>
                                </a>
                                <a id="adminPanelLink" href="/adminpanel" class="hidden block px-4 py-2.5 text-sm text-gray-700 hover:bg-purple-50 hover:text-purple-700 transition-colors flex items-center gap-3 border-t border-gray-200 mt-1 pt-1">
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z"></path>
                                    </svg>
                                    <span class="font-medium">Admin Panel</span>
                                </a>
                                <a href="#" onclick="authManager.signOut(); return false;" class="block px-4 py-2.5 text-sm text-gray-700 hover:bg-red-50 hover:text-red-700 transition-colors flex items-center gap-3 border-t border-gray-200 mt-1 pt-1">
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1"></path>
                                    </svg>
                                    <span class="font-medium">Logout</span>
                                </a>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Admin Button -->
                    <button type="button" id="adminBtn" onclick="showAdminPanel()" class="hidden nav-btn nav-btn-admin">Admin Panel</button>
                </div>
            </div>
        </div>
    </div>
</header>

<div id="toastContainer" aria-live="polite"></div>

        <!-- Change Password Modal -->
<div id="changePasswordModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2>Change Password</h2>
            <span class="modal-close" onclick="closeChangePasswordModal()">&times;</span>
        </div>
        <div class="form-group" id="currentPasswordGroup">
            <label id="currentPasswordLabel">Current Password</label>
            <input type="password" id="currentPassword" placeholder="Enter current password">
        </div>
        <div class="form-group">
            <label>New Password</label>
            <input type="password" id="newPassword" placeholder="Min 6 characters">
        </div>
        <div class="form-group">
            <label>Confirm New Password</label>
            <input type="password" id="confirmPassword" placeholder="Confirm new password">
        </div>
        <div class="error-message" id="changePasswordError"></div>
        <div class="error-message" id="changePasswordSuccess" style="color:green;"></div>
        <button class="btn-primary" style="width:100%; margin-top:10px;" onclick="handleChangePassword()">Change Password</button>
        <button class="btn-secondary" style="width:100%; margin-top:10px;" onclick="closeChangePasswordModal()">Cancel</button>
    </div>
</div>

        <!-- Auth Modal -->
<div id="authModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2>Authentication</h2>
            <span class="modal-close" onclick="closeAuthModal()">&times;</span>
        </div>
        <div class="auth-tabs">
            <button class="auth-tab active" onclick="switchAuthTab('login')">Login</button>
            <button class="auth-tab" onclick="switchAuthTab('register')">Register</button>
        </div>
        <div id="loginForm">
            <div class="form-group">
                <label>Email</label>
                <input type="email" id="loginEmail" placeholder="your@email.com">
            </div>
            <div class="form-group">
                <label>Password</label>
                <input type="password" id="loginPassword" placeholder="Password">
            </div>
            <div class="error-message" id="loginError"></div>
            <button class="btn-primary" style="width:100%; margin-top:10px;" onclick="handleLogin()">Login</button>
            <button class="btn-secondary" style="width:100%; margin-top:10px;" onclick="handleGoogleLogin()">Login with Google</button>
            <button class="link-btn" style="width:100%; margin-top:10px; text-align:center;" onclick="switchAuthTab('forgot')">Forgot Password?</button>
        </div>
        <div id="registerForm" style="display:none;">
            <div class="form-group">
                <label>Email</label>
                <input type="email" id="registerEmail" placeholder="your@email.com">
            </div>
            <div class="form-group">
                <label>Password</label>
                <input type="password" id="registerPassword" placeholder="Min 6 characters">
            </div>
            <div class="error-message" id="registerError"></div>
            <button class="btn-primary" style="width:100%; margin-top:10px;" onclick="handleRegister()">Register</button>
            <button class="btn-secondary" style="width:100%; margin-top:10px;" onclick="handleGoogleLogin()">Register with Google</button>
        </div>
        <div id="forgotForm" style="display:none;">
            <div class="form-group">
                <label>Email</label>
                <input type="email" id="forgotEmail" placeholder="your@email.com">
            </div>
            <div class="error-message" id="forgotError"></div>
            <div class="error-message" id="forgotSuccess" style="color:green;"></div>
            <button class="btn-primary" style="width:100%; margin-top:10px;" onclick="handleForgotPassword()">Send Reset Link</button>
            <button class="link-btn" style="width:100%; margin-top:10px; text-align:center;" onclick="switchAuthTab('login')">Back to Login</button>
        </div>
    </div>
</div>

<!-- Admin Panel Modal -->
<div id="adminModal" class="modal">
    <div class="modal-content admin-panel">
        <div class="modal-header">
            <h2>Admin Panel</h2>
            <span class="modal-close" onclick="closeAdminPanel()">&times;</span>
        </div>
        <div id="adminLoginForm">
            <div class="form-group">
                <label>Admin Username</label>
                <input type="text" id="adminUsername" placeholder="Username">
            </div>
            <div class="form-group">
                <label>Admin Password</label>
                <input type="password" id="adminPassword" placeholder="Password">
            </div>
            <div class="error-message" id="adminLoginError"></div>
            <button class="btn-primary" style="width:100%;" onclick="handleAdminLogin()">Login</button>
        </div>
        <div id="adminPanelContent" style="display:none;">
            <div class="admin-stats">
                <div class="stat-card">
                    <h3>Total Users</h3>
                    <div class="value" id="totalUsers">0</div>
                </div>
                <div class="stat-card">
                    <h3>Total Downloads</h3>
                    <div class="value" id="totalDownloads">0</div>
                </div>
                <div class="stat-card">
                    <h3>Downloads Today</h3>
                    <div class="value" id="downloadsToday">0</div>
                </div>
            </div>
            <h3>Users</h3>
            <table class="users-table">
                <thead>
                    <tr>
                        <th>Email</th>
                        <th>Downloads</th>
                        <th>Last Login</th>
                    </tr>
                </thead>
                <tbody id="usersTableBody">
                </tbody>
            </table>
        </div>
    </div>
</div>

<!-- Confirm modal (replaces browser confirm) -->
<div id="confirmModal" class="modal">
    <div class="modal-content" style="max-width:400px;">
        <div class="modal-header">
            <h2 id="confirmModalTitle">Confirm</h2>
        </div>
        <p id="confirmModalMessage" style="margin:0 0 20px 0; color:#475569;"></p>
        <div style="display:flex; gap:10px; justify-content:flex-end;">
            <button type="button" id="confirmModalCancel" class="btn-secondary">Cancel</button>
            <button type="button" id="confirmModalOk" class="btn-primary">Proceed</button>
        </div>
    </div>
</div>

<!-- Raw photo modal (input image only, no pattern) -->
<div id="rawPhotoModal" class="modal">
    <div class="modal-content" style="max-width:90vw; max-height:90vh; display:flex; flex-direction:column;">
        <div class="modal-header">
            <h2>Raw photo (input only)</h2>
            <span class="modal-close" onclick="window.closeRawPhotoModal && window.closeRawPhotoModal()">&times;</span>
        </div>
        <div style="flex:1; min-height:200px; display:flex; align-items:center; justify-content:center; background:#f1f5f9; border-radius:8px;">
            <canvas id="rawPhotoCanvas" style="max-width:100%; max-height:75vh; object-fit:contain;"></canvas>
            <p id="rawPhotoPlaceholder" style="display:none; color:#64748b;">No image loaded. Upload a photo first.</p>
        </div>
    </div>
</div>

<!-- Main Content Wrapper -->
<div class="main-wrapper">
<!-- Hidden file inputs for navbar buttons -->
<input type="file" id="fileInput" accept="image/*" style="display:none">
        <input type="file" id="importFile" accept=".txt" style="display:none">

<aside>
    <div style="margin-bottom:20px;">
        <h2 style="margin:0; font-size:1.2rem;">Design Controls</h2>
    </div>

    <div class="control-group sub-control-panel">
        <label style="margin-bottom:8px">Image Fit &amp; Placement</label>
        <select id="imgFitMode" style="margin-bottom:8px">
            <option value="stretch">Stretch to Fit (Default)</option>
            <option value="ratio">Keep Ratio (Center)</option>
        </select>
        
        <div id="imgPlacementControls" style="display:none;">
            <div class="row" style="margin-bottom:5px">
                <div>
                    <label style="font-size:0.75rem;">Scale (x)</label>
                    <input type="number" id="imgScale" value="1.0" step="0.1">
                </div>
            </div>
            <div class="row">
                <div>
                    <label style="font-size:0.75rem;">Pan X (mm)</label>
                    <input type="number" id="imgPanX" value="0">
                </div>
                <div>
                    <label style="font-size:0.75rem;">Pan Y (mm)</label>
                    <input type="number" id="imgPanY" value="0">
                </div>
            </div>
        </div>
    </div>

    <h2>Global Geometry (mm)</h2>
    <div class="control-group">
        <label class="checkbox-row" style="margin-bottom: 12px; color: var(--primary); background: #eff6ff; padding: 8px; border-radius: 4px;">
            <input type="checkbox" id="lockRatio" checked="">
            <span>Link Dimensions to Image Ratio</span>
        </label>

        <div class="row">
            <div>
                <label>Total Width</label>
                <input type="number" id="panelW" value="1000">
            </div>
            <div>
                <label>Total Height</label>
                <input type="number" id="panelH" value="2000">
            </div>
        </div>
        <small id="ratioDisplay" style="margin-top:5px; font-style: italic;"></small>
    </div>
    
    <h2>Sheet Layout (Subdivision)</h2>
    <div class="control-group">
        <label>Split Logic</label>
        <select id="splitMode">
            <option value="strict">Strict (Show Error if mismatch)</option>
            <option value="fill">Fill Remainder (Auto-add panel)</option>
            <option value="update">Update Total (Resize Global)</option>
        </select>
    </div>

    <div class="control-group">
        <label>Vertical Splits (Left-to-Right)</label>
        <input type="text" id="splitW" placeholder="e.g. 1000, 1000">
        <div id="errSplitW" class="error-text"></div>
    </div>
    <div class="control-group">
        <label>Horizontal Splits (Top-to-Bottom)</label>
        <input type="text" id="splitH" placeholder="e.g. 2000">
        <div id="errSplitH" class="error-text"></div>
    </div>
    
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
        <h2 style="margin-bottom: 0;">Margins Per Sheet (mm)</h2>
        <button id="lockMarginsBtn" type="button" title="Lock all margins" style="background: none; border: none; cursor: pointer; color: #64748b; padding: 4px;">
            <svg viewBox="0 0 24 24" width="18" height="18" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                <path d="M7 11V7a5 5 0 0 1 9.9-1"></path>
            </svg>
        </button>
    </div>
    <div class="control-group">
         <div class="row">
            <div>
                <label>Top/Bottom</label>
                <input type="number" id="marginTop" value="20" placeholder="T">
                <input type="number" id="marginBottom" value="20" placeholder="B" style="margin-top:5px">
            </div>
            <div>
                <label>Left/Right</label>
                <input type="number" id="marginLeft" value="20" placeholder="L">
                <input type="number" id="marginRight" value="20" placeholder="R" style="margin-top:5px">
            </div>
        </div>
        <small>Safe zone applied to each split.</small>
    </div>

    <h2>Perforation Specs (mm)</h2>
    <div class="control-group">
        <div class="row" style="align-items:flex-end;">
            <div>
                <label>Min Hole Ã˜</label>
                <input type="number" id="minHole" value="2">
            </div>
            <div>
                <label>Max Hole Ã˜</label>
                <input type="number" id="maxHole" value="18">
            </div>
            <div style="display:flex; flex-direction:column; gap:4px; margin-bottom:0;">
                <label style="font-size:0.75rem; color:#64748b; margin:0;">Both</label>
                <div style="display:flex; gap:4px;">
                    <button type="button" id="holeSizeDecBtn" title="Decrease both" style="width:36px; height:32px; padding:0; border:1px solid #e2e8f0; border-radius:4px; background:#f8fafc; font-size:1.2rem; line-height:1; cursor:pointer;">âˆ’</button>
                    <button type="button" id="holeSizeIncBtn" title="Increase both" style="width:36px; height:32px; padding:0; border:1px solid #e2e8f0; border-radius:4px; background:#f8fafc; font-size:1.2rem; line-height:1; cursor:pointer;">+</button>
                </div>
            </div>
        </div>
    </div>

    <div class="control-group">
        <label>Spacing Control</label>
        <div class="row">
            <div style="flex:1">
                <div style="display:flex; justify-content:space-between; align-items:center;">
                    <label style="font-size:0.75rem; color:#64748b; margin:0;">Pitch (C-C)</label>
                    <label class="lock-toggle" title="Lock Pitch">
                        <input type="radio" name="lockMode" id="lockPitch" checked="">
                        <svg class="lock-icon" viewBox="0 0 24 24"><path d="M12 17c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm6-9h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zM9 6c0-1.66 1.34-3 3-3s3 1.34 3 3v2H9V6z"></path></svg>
                    </label>
                </div>
                <input type="number" id="pitch" value="20" min="1">
            </div>
            
            <div style="text-align:center; padding-top:18px; color:#94a3b8; font-size:0.8rem;">=</div>
            
            <div style="flex:1">
                <div style="display:flex; justify-content:space-between; align-items:center;">
                    <label style="font-size:0.75rem; color:#64748b; margin:0;">Gap (Edge)</label>
                    <label class="lock-toggle" title="Lock Gap">
                        <input type="radio" name="lockMode" id="lockGap">
                        <svg class="lock-icon" viewBox="0 0 24 24"><path d="M12 17c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm6-9h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zM9 6c0-1.66 1.34-3 3-3s3 1.34 3 3v2H9V6z"></path></svg>
                    </label>
                </div>
                <input type="number" id="edgeGap" value="2">
            </div>
        </div>
    </div>

    <div class="control-group">
        <label class="checkbox-row">
            <input type="checkbox" id="invertColors">
            <span>Invert (Darker = Smaller Hole)</span>
        </label>
    </div>

    <div class="control-group">
        <label>Colors</label>
        <div class="row">
            <div>
                <label style="font-size:0.75rem;">Hole Color</label>
                <input type="color" id="holeColor" value="#000000" style="width:100%;">
            </div>
            <div>
                <label style="font-size:0.75rem;">Panel Color</label>
                <input type="color" id="panelColor" value="#ffffff" style="width:100%;">
            </div>
        </div>
        <div class="toggle-group" style="margin-top:8px;">
            <label style="margin:0; flex:1;">Invert colors (swap hole &amp; panel)</label>
            <div class="toggle-switch" id="swapColorsToggle"></div>
        </div>
        <small>Invert above only affects hole size mapping. Use this to swap hole/panel colors.</small>
    </div>
    
    <h2>Panel Alignment</h2>
    <div class="control-group">
        <label>Hole Pattern Alignment</label>
        <div class="alignment-controls">
            <button class="align-btn" data-align="top-left" title="Top Left">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="12" y1="2" x2="12" y2="8"/>
                    <polyline points="8 6 12 2 16 6"/>
                    <line x1="2" y1="12" x2="8" y2="12"/>
                    <polyline points="6 8 2 12 6 16"/>
                </svg>
            </button>
            <button class="align-btn" data-align="top" title="Top">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="12" y1="2" x2="12" y2="8"/>
                    <polyline points="8 6 12 2 16 6"/>
                </svg>
            </button>
            <button class="align-btn" data-align="top-right" title="Top Right">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="12" y1="2" x2="12" y2="8"/>
                    <polyline points="8 6 12 2 16 6"/>
                    <line x1="16" y1="12" x2="22" y2="12"/>
                    <polyline points="18 8 22 12 18 16"/>
                </svg>
            </button>
            <button class="align-btn" data-align="left" title="Left">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="2" y1="12" x2="8" y2="12"/>
                    <polyline points="6 8 2 12 6 16"/>
                </svg>
            </button>
            <button class="align-btn align-center active" data-align="center" title="Center">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="3"/>
                </svg>
            </button>
            <button class="align-btn" data-align="right" title="Right">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="16" y1="12" x2="22" y2="12"/>
                    <polyline points="18 8 22 12 18 16"/>
                </svg>
            </button>
            <button class="align-btn" data-align="bottom-left" title="Bottom Left">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="12" y1="16" x2="12" y2="22"/>
                    <polyline points="8 18 12 22 16 18"/>
                    <line x1="2" y1="12" x2="8" y2="12"/>
                    <polyline points="6 8 2 12 6 16"/>
                </svg>
            </button>
            <button class="align-btn" data-align="bottom" title="Bottom">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="12" y1="16" x2="12" y2="22"/>
                    <polyline points="8 18 12 22 16 18"/>
                </svg>
            </button>
            <button class="align-btn" data-align="bottom-right" title="Bottom Right">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="12" y1="16" x2="12" y2="22"/>
                    <polyline points="8 18 12 22 16 18"/>
                    <line x1="16" y1="12" x2="22" y2="12"/>
                    <polyline points="18 8 22 12 18 16"/>
                </svg>
            </button>
        </div>
        <small>Adjust starting point for hole pattern in each panel</small>
    </div>
    
    <h2>Display Options</h2>
    <div class="control-group">
        <div class="toggle-group">
            <label style="margin:0; flex:1;">Show Opening % on Panels</label>
            <div class="toggle-switch" id="showPercentageToggle"></div>
        </div>
        <div class="slider-container" id="percentageSizeContainer" style="display:none;">
            <div class="slider-label">
                <label style="margin:0;">Text Size</label>
                <span class="slider-value" id="percentageSizeValue">100%</span>
            </div>
            <input type="range" id="percentageSizeSlider" min="50" max="1000" value="100" step="10">
        </div>
        <small>Display opening percentage overlay on each subdivided panel</small>
    </div>
    <div class="control-group">
        <div class="toggle-group">
            <label style="margin:0; flex:1;">Include Footer Statistics in Downloads</label>
            <div class="toggle-switch" id="includeFooterStatsToggle"></div>
        </div>
        <small>Add panel count, hole count, and opening percentage below the image in downloaded files</small>
    </div>

    <button id="generateBtn" class="btn-primary">Generate Pattern</button>
    
    <div id="stats">
        <div class="stat-item">
            <span>Hole Count:</span>
            <span class="stat-value" id="statCount">0</span>
        </div>
        <div class="stat-item">
            <span>Open Area:</span>
            <span class="stat-value" id="statArea">0%</span>
        </div>
        <div class="stat-item" id="warningMsg" style="display:none; color: #ef4444; margin-top:5px; font-size:0.8rem;">
            Warning: High hole count. Rendering might be slow.
        </div>
    </div>
    
</aside>

<main id="mainViewport" style="cursor: grab; flex: 1;">
    <div id="canvas-container">
        <canvas id="previewCanvas"></canvas>
    </div>
    
    <!-- Zoom Controls -->
    <div class="zoom-controls">
        <button class="zoom-btn" id="zoomOut" title="Zoom Out">-</button>
        <button class="zoom-btn" id="zoomFit" title="Zoom Extent (Fit)">
            <svg viewBox="0 0 24 24"><path d="M4 4h6v2H6v4H4V4zm10 0h6v6h-2V6h-4V4zm6 10h-2v4h-4v2h6v-6zM4 14h2v4h4v2H4v-6z"></path></svg>
        </button>
        <button class="zoom-btn" id="zoomIn" title="Zoom In">+</button>
    </div>
</main>

<script>
    // State
    const CONFIG = {
        baseScale: 2, // Desired Pixels per MM
        maxCanvasDimension: 4096 // Hard limit
    };
    
    let sourceImage = null;
    let imageAspectRatio = 0;
    
    // Unique ID for current generation
    let currentFileID = null;

    // Viewport State
    let scale = 1;
    let panX = 0;
    let panY = 0;
    let isDragging = false;
    let dragStartX = 0;
    let dragStartY = 0;

    // Elements
    const canvas = document.getElementById('previewCanvas');
    const mainViewport = document.getElementById('mainViewport');
    const container = document.getElementById('canvas-container'); // Holds the canvas, is transformed
    const ctx = canvas.getContext('2d');
    
    const fileInput = document.getElementById('fileInput');
    const importFile = document.getElementById('importFile');
    const generateBtn = document.getElementById('generateBtn');
    
    const downloadImgBtn = document.getElementById('downloadImgBtn');
    const downloadTxtBtn = document.getElementById('downloadTxtBtn');
    const downloadDxfBtn = document.getElementById('downloadDxfBtn');
    const downloadSvgBtn = document.getElementById('downloadSvgBtn');
    const downloadZipBtn = document.getElementById('downloadZipBtn');
    
    const statsPanel = document.getElementById('stats');
    const ratioDisplay = document.getElementById('ratioDisplay');
    const lockRatioCheckbox = document.getElementById('lockRatio');
    const warningMsg = document.getElementById('warningMsg');
    
    const lockPitchRadio = document.getElementById('lockPitch');
    const lockGapRadio = document.getElementById('lockGap');
    
    // New Elements
    const imgFitMode = document.getElementById('imgFitMode');
    const imgPlacementControls = document.getElementById('imgPlacementControls');
    const splitMode = document.getElementById('splitMode');
    const errSplitW = document.getElementById('errSplitW');
    const errSplitH = document.getElementById('errSplitH');
    
    // Zoom Buttons
    const btnZoomIn = document.getElementById('zoomIn');
    const btnZoomOut = document.getElementById('zoomOut');
    const btnZoomFit = document.getElementById('zoomFit');
    
    // Alignment and Display Controls
    const alignmentButtons = document.querySelectorAll('.align-btn');
    const showPercentageToggle = document.getElementById('showPercentageToggle');
    const includeFooterStatsToggle = document.getElementById('includeFooterStatsToggle');
    const swapColorsToggle = document.getElementById('swapColorsToggle');
    const percentageSizeSlider = document.getElementById('percentageSizeSlider');
    const percentageSizeValue = document.getElementById('percentageSizeValue');
    const percentageSizeContainer = document.getElementById('percentageSizeContainer');

    // Project Name & Color Controls
    const projectNameInput = document.getElementById('projectName');
    const resetSettingsBtn = document.getElementById('resetSettingsBtn');
    const holeColorInput = document.getElementById('holeColor');
    const panelColorInput = document.getElementById('panelColor');

    // Inputs
    const inputs = {
        w: document.getElementById('panelW'),
        h: document.getElementById('panelH'),
        pitch: document.getElementById('pitch'),
        edge: document.getElementById('edgeGap'),
        min: document.getElementById('minHole'),
        max: document.getElementById('maxHole'),
        invert: document.getElementById('invertColors'),
        splitW: document.getElementById('splitW'),
        splitH: document.getElementById('splitH'),
        mT: document.getElementById('marginTop'),
        mB: document.getElementById('marginBottom'),
        mL: document.getElementById('marginLeft'),
        mR: document.getElementById('marginRight'),
        // Image mapping inputs
        imgScale: document.getElementById('imgScale'),
        imgPanX: document.getElementById('imgPanX'),
        imgPanY: document.getElementById('imgPanY'),
    };
    
    // Holes data cache for DXF export
    let generatedHoles = []; 
    let sheetDefinitions = []; 
    
    // Panel alignment and display state
    let panelAlignment = 'center'; // 'center', 'top-left', 'top', 'top-right', 'left', 'right', 'bottom-left', 'bottom', 'bottom-right'
    let showPercentage = false;
    let percentageSize = 100; // Percentage size multiplier (50-200%)
    let panelStats = []; // Store stats per panel: [{sheetIndex, holeCount, openArea, bounds}]
    let includeFooterStatsInDownload = false; // Include footer statistics in downloaded files 
    let swapHolePanelColors = false; // Swap hole and panel colors for display/export

    const DEFAULT_PROJECT_NAME = 'Untitled'; // Avoid empty field so Chrome doesn't treat it as username

    // --- LOCAL STORAGE ---
    function saveSettings() {
        const settings = {
            projectName: projectNameInput ? (projectNameInput.value.trim() || DEFAULT_PROJECT_NAME) : DEFAULT_PROJECT_NAME,
            w: inputs.w.value,
            h: inputs.h.value,
            pitch: inputs.pitch.value,
            edge: inputs.edge.value,
            min: inputs.min.value,
            max: inputs.max.value,
            invert: inputs.invert.checked,
            splitW: inputs.splitW.value,
            splitH: inputs.splitH.value,
            mT: inputs.mT.value,
            mB: inputs.mB.value,
            mL: inputs.mL.value,
            mR: inputs.mR.value,
            imgFit: imgFitMode.value,
            imgScale: inputs.imgScale.value,
            imgPanX: inputs.imgPanX.value,
            imgPanY: inputs.imgPanY.value,
            splitMode: splitMode.value,
            lockRatio: lockRatioCheckbox.checked,
            lockMode: lockPitchRadio.checked ? 'pitch' : 'gap',
            panelAlignment: panelAlignment,
            showPercentage: showPercentage,
            percentageSize: percentageSize,
            includeFooterStatsInDownload: includeFooterStatsInDownload,
            swapHolePanelColors: swapHolePanelColors,
            holeColor: holeColorInput && holeColorInput.value ? holeColorInput.value : '#000000',
            panelColor: panelColorInput && panelColorInput.value ? panelColorInput.value : '#ffffff'
        };
        localStorage.setItem('holemapper_settings_v3', JSON.stringify(settings));
    }

    function loadSettings() {
        const saved = localStorage.getItem('holemapper_settings_v3');
        if (saved) {
            try {
                const s = JSON.parse(saved);
                if(projectNameInput) projectNameInput.value = (s.projectName && s.projectName.trim()) ? s.projectName.trim() : DEFAULT_PROJECT_NAME;
                if(s.w) inputs.w.value = s.w;
                if(s.h) inputs.h.value = s.h;
                if(s.pitch) inputs.pitch.value = s.pitch;
                if(s.edge) inputs.edge.value = s.edge;
                if(s.min) inputs.min.value = s.min;
                if(s.max) inputs.max.value = s.max;
                if(s.invert !== undefined) inputs.invert.checked = s.invert;
                if(s.splitW !== undefined) inputs.splitW.value = s.splitW;
                if(s.splitH !== undefined) inputs.splitH.value = s.splitH;
                if(s.mT !== undefined) inputs.mT.value = s.mT;
                if(s.mB !== undefined) inputs.mB.value = s.mB;
                if(s.mL !== undefined) inputs.mL.value = s.mL;
                if(s.mR !== undefined) inputs.mR.value = s.mR;
                if(s.holeColor && holeColorInput) holeColorInput.value = s.holeColor;
                if(s.panelColor && panelColorInput) panelColorInput.value = s.panelColor;
                if(s.imgFit) imgFitMode.value = s.imgFit;
                if(s.imgScale) inputs.imgScale.value = s.imgScale;
                if(s.imgPanX) inputs.imgPanX.value = s.imgPanX;
                if(s.imgPanY) inputs.imgPanY.value = s.imgPanY;
                if(s.splitMode) splitMode.value = s.splitMode;
                if(s.lockRatio !== undefined) lockRatioCheckbox.checked = s.lockRatio;
                
                if(s.lockMode === 'gap') lockGapRadio.checked = true;
                else lockPitchRadio.checked = true;
                
                if(s.panelAlignment) {
                    panelAlignment = s.panelAlignment;
                    if (alignmentButtons && alignmentButtons.length > 0) {
                        alignmentButtons.forEach(btn => {
                            btn.classList.toggle('active', btn.dataset.align === panelAlignment);
                        });
                    }
                }
                
                if(s.showPercentage !== undefined) {
                    showPercentage = s.showPercentage;
                    if (showPercentageToggle) {
                        showPercentageToggle.classList.toggle('active', showPercentage);
                    }
                    if (percentageSizeContainer) {
                        percentageSizeContainer.style.display = showPercentage ? 'block' : 'none';
                    }
                }
                
                if(s.percentageSize !== undefined) {
                    percentageSize = s.percentageSize;
                    if (percentageSizeSlider) {
                        percentageSizeSlider.value = percentageSize;
                    }
                    if (percentageSizeValue) {
                        percentageSizeValue.textContent = percentageSize + '%';
                    }
                }
                
                if(s.includeFooterStatsInDownload !== undefined) {
                    includeFooterStatsInDownload = s.includeFooterStatsInDownload;
                    if (includeFooterStatsToggle) {
                        includeFooterStatsToggle.classList.toggle('active', includeFooterStatsInDownload);
                    }
                }
                if(s.swapHolePanelColors !== undefined) {
                    swapHolePanelColors = s.swapHolePanelColors;
                    if (swapColorsToggle) {
                        swapColorsToggle.classList.toggle('active', swapHolePanelColors);
                    }
                }
                if (typeof ensureValidGap === 'function') ensureValidGap();
                toggleImgControls();
            } catch(e) { console.error(e); }
        }
    }
    
    function resetSettingsAndClearStorage() {
        // Clear saved settings in local storage
        try {
            localStorage.removeItem('holemapper_settings_v3');
        } catch (e) {
            console.error('Error clearing saved settings', e);
        }

        // Reset project name (use default to avoid empty field / Chrome username autofill)
        if (projectNameInput) {
            projectNameInput.value = DEFAULT_PROJECT_NAME;
        }

        // Reset main numeric/text inputs back to their original defaults
        if (inputs.w) inputs.w.value = inputs.w.defaultValue;
        if (inputs.h) inputs.h.value = inputs.h.defaultValue;
        if (inputs.pitch) inputs.pitch.value = inputs.pitch.defaultValue;
        if (inputs.edge) inputs.edge.value = inputs.edge.defaultValue;
        if (inputs.min) inputs.min.value = inputs.min.defaultValue;
        if (inputs.max) inputs.max.value = inputs.max.defaultValue;
        if (inputs.splitW) inputs.splitW.value = inputs.splitW.defaultValue;
        if (inputs.splitH) inputs.splitH.value = inputs.splitH.defaultValue;
        if (inputs.mT) inputs.mT.value = inputs.mT.defaultValue;
        if (inputs.mB) inputs.mB.value = inputs.mB.defaultValue;
        if (inputs.mL) inputs.mL.value = inputs.mL.defaultValue;
        if (inputs.mR) inputs.mR.value = inputs.mR.defaultValue;
        if (inputs.imgScale) inputs.imgScale.value = inputs.imgScale.defaultValue;
        if (inputs.imgPanX) inputs.imgPanX.value = inputs.imgPanX.defaultValue;
        if (inputs.imgPanY) inputs.imgPanY.value = inputs.imgPanY.defaultValue;

        // Reset colors to defaults
        if (holeColorInput) holeColorInput.value = '#000000';
        if (panelColorInput) panelColorInput.value = '#ffffff';

        // Reset colors to defaults
        if (holeColorInput) holeColorInput.value = '#000000';
        if (panelColorInput) panelColorInput.value = '#ffffff';

        // Reset invert checkbox
        if (inputs.invert) {
            inputs.invert.checked = inputs.invert.defaultChecked;
        }

        // Reset split mode select
        if (splitMode && splitMode.options && splitMode.options.length > 0) {
            splitMode.value = splitMode.options[0].value;
        }

        // Reset lock options
        if (lockRatioCheckbox) {
            lockRatioCheckbox.checked = true;
        }
        if (lockPitchRadio && lockGapRadio) {
            lockPitchRadio.checked = true;
            lockGapRadio.checked = false;
        }

        // Reset display options
        showPercentage = false;
        if (showPercentageToggle) {
            showPercentageToggle.classList.remove('active');
        }
        if (percentageSizeContainer) {
            percentageSizeContainer.style.display = 'none';
        }
        percentageSize = 100;
        if (percentageSizeSlider) {
            percentageSizeSlider.value = 100;
        }
        if (percentageSizeValue) {
            percentageSizeValue.textContent = '100%';
        }

        // Reset footer stats inclusion
        includeFooterStatsInDownload = false;
        if (includeFooterStatsToggle) {
            includeFooterStatsToggle.classList.remove('active');
        }

        // Reset swap colors
        swapHolePanelColors = false;
        if (swapColorsToggle) {
            swapColorsToggle.classList.remove('active');
        }

        // Reset alignment to center
        panelAlignment = 'center';
        if (alignmentButtons && alignmentButtons.length > 0) {
            alignmentButtons.forEach(function(btn) {
                btn.classList.toggle('active', btn.dataset.align === panelAlignment);
            });
        }

        // Clear split errors
        if (errSplitW) errSplitW.textContent = '';
        if (errSplitH) errSplitH.textContent = '';

        // Clear footer height preference
        try {
            localStorage.removeItem('footerHeight');
        } catch(e) {}
        const footerReset = document.querySelector('footer');
        if (footerReset) {
            footerReset.style.height = ''; 
            const content = footerReset.querySelector('.footer-one-line');
            if (content) {
                content.style.fontSize = ''; 
                content.style.gap = ''; 
                const stats = content.querySelector('.footer-stats-left');
                if (stats) stats.style.gap = '';
                const progBar = document.getElementById('footerProgressBar');
                if (progBar) {
                    progBar.style.width = '110px';
                    progBar.style.height = '5px';
                }
            }
        }

        // Re-apply image control visibility
        toggleImgControls();

        // Re-generate pattern if an image is already loaded
        if (sourceImage) {
            generatePerforation();
        }
    }
    
    function toggleImgControls() {
        if(imgFitMode.value === 'ratio') {
            imgPlacementControls.style.display = 'block';
        } else {
            imgPlacementControls.style.display = 'none';
        }
    }
    
    function generateUniqueID() {
        // Generate a random 8-character string, e.g., HM-A1B2C3D4
        const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
        let result = "";
        for (let i = 0; i < 8; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        return "HM-" + result;
    }
    
    function getDownloadFilename() {
        const projectName = (projectNameInput && projectNameInput.value.trim()) ? projectNameInput.value.trim() : DEFAULT_PROJECT_NAME;
        const uniqueId = currentFileID || generateUniqueID();
        const sanitizedName = projectName.replace(/[^a-z0-9_-]/gi, '_').substring(0, 50);
        return sanitizedName ? `${sanitizedName}_${uniqueId}` : uniqueId;
    }

    // Load shared design from URL (if opened from shareable HTML)
    function loadSharedDesign() {
        const urlParams = new URLSearchParams(window.location.search);
        const sharedData = urlParams.get('shared');
        
        if (sharedData) {
            try {
                const decoded = atob(decodeURIComponent(sharedData));
                const designData = JSON.parse(decoded);
                
                if (designData.image && designData.settings) {
                    // Load image
                    const img = new Image();
                    img.onload = () => {
                        sourceImage = img;
                        imageAspectRatio = img.naturalWidth / img.naturalHeight;
                        ratioDisplay.innerText = `Image Ratio: ${imageAspectRatio.toFixed(3)}`;
                        
                        // Load settings
                        const s = designData.settings;
                        if(s.w) inputs.w.value = s.w;
                        if(s.h) inputs.h.value = s.h;
                        if(s.pitch) inputs.pitch.value = s.pitch;
                        if(s.edge) inputs.edge.value = s.edge;
                        if(s.min) inputs.min.value = s.min;
                        if(s.max) inputs.max.value = s.max;
                        if(s.invert !== undefined) inputs.invert.checked = s.invert;
                        if(s.splitW !== undefined) inputs.splitW.value = s.splitW;
                        if(s.splitH !== undefined) inputs.splitH.value = s.splitH;
                        if(s.mT !== undefined) inputs.mT.value = s.mT;
                        if(s.mB !== undefined) inputs.mB.value = s.mB;
                        if(s.mL !== undefined) inputs.mL.value = s.mL;
                        if(s.mR !== undefined) inputs.mR.value = s.mR;
                        if(s.imgFit) imgFitMode.value = s.imgFit;
                        if(s.imgScale) inputs.imgScale.value = s.imgScale;
                        if(s.imgPanX) inputs.imgPanX.value = s.imgPanX;
                        if(s.imgPanY) inputs.imgPanY.value = s.imgPanY;
                        if(s.splitMode) splitMode.value = s.splitMode;
                        if(s.lockRatio !== undefined) lockRatioCheckbox.checked = s.lockRatio;
                        if(s.lockMode === 'gap') lockGapRadio.checked = true;
                        else lockPitchRadio.checked = true;
                        if(s.panelAlignment) {
                            panelAlignment = s.panelAlignment;
                            if (alignmentButtons && alignmentButtons.length > 0) {
                                alignmentButtons.forEach(btn => {
                                    btn.classList.toggle('active', btn.dataset.align === panelAlignment);
                                });
                            }
                        }
                        if(s.showPercentage !== undefined) {
                            showPercentage = s.showPercentage;
                            if (showPercentageToggle) {
                                showPercentageToggle.classList.toggle('active', showPercentage);
                            }
                            if (percentageSizeContainer) {
                                percentageSizeContainer.style.display = showPercentage ? 'block' : 'none';
                            }
                        }
                        if(s.percentageSize !== undefined) {
                            percentageSize = s.percentageSize;
                            if (percentageSizeSlider) {
                                percentageSizeSlider.value = percentageSize;
                            }
                            if (percentageSizeValue) {
                                percentageSizeValue.textContent = percentageSize + '%';
                            }
                        }
                        toggleImgControls();
                        saveSettings();
                        generateBtn.innerText = "Generate Pattern";
                        generatePerforation();
                        
                        // Clean URL
                        window.history.replaceState({}, document.title, window.location.pathname);
                    };
                    img.src = designData.image;
                }
            } catch (e) {
                console.error('Failed to load shared design:', e);
                if (typeof showNotification === 'function') showNotification('Failed to load shared design. Please check the file and try again.', 'error');
            }
        }
    }

    // Initialize
    loadSettings();
    loadSharedDesign();
    // Prevent browser from autofilling project name; only our stored value (loadSettings) should fill it
    if (projectNameInput) {
        projectNameInput.setAttribute('autocomplete', 'off');
        if (!projectNameInput.value.trim()) projectNameInput.value = DEFAULT_PROJECT_NAME;
    }

    // Event Listeners
    if (fileInput) {
        fileInput.addEventListener('change', handleImageUpload);
    } else {
        console.error('fileInput not found');
    }

    if (importFile) {
        importFile.addEventListener('change', handleImportConfig);
    } else {
        console.error('importFile not found');
    }

    if (generateBtn) {
        generateBtn.addEventListener('click', generatePerforation);
    }
    
    // Download buttons - these are now in navbar dropdown with onclick handlers
    // Event listeners are optional since onclick is already set
    if (downloadImgBtn) {
        // Remove duplicate listener if onclick is already set
        // downloadImgBtn.addEventListener('click', () => downloadImage());
    }
    if (downloadTxtBtn) {
        // downloadTxtBtn.addEventListener('click', () => downloadSpecs());
    }
    if (downloadDxfBtn) {
        // downloadDxfBtn.addEventListener('click', () => downloadDXF());
    }
    if (downloadSvgBtn) {
        // downloadSvgBtn.addEventListener('click', () => downloadSVG());
    }
    
    imgFitMode.addEventListener('change', () => {
        toggleImgControls();
        saveSettings();
        generatePerforation(); // Immediate redraw on mode change
    });
    
    // Canvas Pan/Zoom Interaction
    mainViewport.addEventListener('wheel', handleWheel, { passive: false });
    mainViewport.addEventListener('mousedown', startDrag);
    window.addEventListener('mousemove', drag);
    window.addEventListener('mouseup', endDrag);
    
    btnZoomIn.addEventListener('click', () => applyZoom(scale * 1.2));
    btnZoomOut.addEventListener('click', () => applyZoom(scale * 0.8));
    btnZoomFit.addEventListener('click', zoomFit);
    
    // Alignment button handlers
    if (alignmentButtons && alignmentButtons.length > 0) {
        alignmentButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                alignmentButtons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                panelAlignment = btn.dataset.align;
                saveSettings();
                if (sourceImage) generatePerforation();
            });
        });
    }
    
    // Show percentage toggle
    if (showPercentageToggle) {
        showPercentageToggle.addEventListener('click', () => {
            showPercentage = !showPercentage;
            showPercentageToggle.classList.toggle('active', showPercentage);
            if (percentageSizeContainer) {
                percentageSizeContainer.style.display = showPercentage ? 'block' : 'none';
            }
            saveSettings();
            if (sourceImage) generatePerforation();
        });
    }
    
    // Reset settings button
    if (resetSettingsBtn) {
        resetSettingsBtn.addEventListener('click', resetSettingsAndClearStorage);
    }
    
    // Project name: save to storage as user types (debounced), so only our stored value autofills on load
    let projectNameSaveTimeout = null;
    if (projectNameInput) {
        projectNameInput.addEventListener('input', () => {
            if (projectNameSaveTimeout) clearTimeout(projectNameSaveTimeout);
            projectNameSaveTimeout = setTimeout(() => {
                saveSettings();
                projectNameSaveTimeout = null;
            }, 400);
        });
        projectNameInput.addEventListener('change', () => {
            if (projectNameSaveTimeout) clearTimeout(projectNameSaveTimeout);
            if (!projectNameInput.value.trim()) projectNameInput.value = DEFAULT_PROJECT_NAME;
            saveSettings();
        });
    }
    
    // Include footer stats in download toggle
    if (includeFooterStatsToggle) {
        includeFooterStatsToggle.addEventListener('click', () => {
            includeFooterStatsInDownload = !includeFooterStatsInDownload;
            includeFooterStatsToggle.classList.toggle('active', includeFooterStatsInDownload);
            saveSettings();
        });
    }

    // Swap hole/panel colors toggle
    if (swapColorsToggle) {
        swapColorsToggle.addEventListener('click', () => {
            swapHolePanelColors = !swapHolePanelColors;
            swapColorsToggle.classList.toggle('active', swapHolePanelColors);
            saveSettings();
            if (sourceImage) generatePerforation();
        });
    }
    
    // Percentage size slider
    if (percentageSizeSlider && percentageSizeValue) {
        percentageSizeSlider.addEventListener('input', (e) => {
            percentageSize = parseInt(e.target.value);
            percentageSizeValue.textContent = percentageSize + '%';
            saveSettings();
            if (sourceImage && showPercentage) generatePerforation();
        });
    }
    
    // Sync Inputs
    inputs.h.addEventListener('input', () => {
        if (lockRatioCheckbox.checked && imageAspectRatio > 0) {
            const h = parseFloat(inputs.h.value);
            if (!isNaN(h)) inputs.w.value = Math.round(h * imageAspectRatio);
        }
        saveSettings();
    });
    inputs.w.addEventListener('input', () => {
        if (lockRatioCheckbox.checked && imageAspectRatio > 0) {
            const w = parseFloat(inputs.w.value);
            if (!isNaN(w)) inputs.h.value = Math.round(w / imageAspectRatio);
        }
        saveSettings();
    });

    // Minimum gap between holes (mm) - gap must be > 0
    const MIN_GAP = 0.01;
    function ensureValidGap() {
        const e = parseFloat(inputs.edge.value);
        if (isNaN(e) || e < MIN_GAP) {
            const m = parseFloat(inputs.max.value) || 0;
            const newEdge = Math.max(MIN_GAP, e);
            inputs.edge.value = parseFloat(newEdge.toFixed(2));
            inputs.pitch.value = parseFloat((newEdge + m).toFixed(2));
            if (typeof showNotification === 'function') showNotification('Gap cannot be 0 or less. Increased to minimum.', 'error');
            saveSettings();
        }
    }

    // Pitch/Gap Sync
    inputs.pitch.addEventListener('input', () => {
        const p = parseFloat(inputs.pitch.value) || 0;
        const m = parseFloat(inputs.max.value) || 0;
        const newEdge = p - m;
        if (newEdge < MIN_GAP) {
            inputs.pitch.value = parseFloat((m + MIN_GAP).toFixed(2));
            inputs.edge.value = parseFloat(MIN_GAP.toFixed(2));
            if (typeof showNotification === 'function') showNotification('Gap cannot be 0 or less. Pitch increased.', 'error');
        } else {
            inputs.edge.value = parseFloat(newEdge.toFixed(2));
        }
        saveSettings();
    });
    inputs.edge.addEventListener('input', () => {
        const e = parseFloat(inputs.edge.value) || 0;
        const m = parseFloat(inputs.max.value) || 0;
        if (e < MIN_GAP) {
            inputs.edge.value = parseFloat(MIN_GAP.toFixed(2));
            inputs.pitch.value = parseFloat((MIN_GAP + m).toFixed(2));
            if (typeof showNotification === 'function') showNotification('Gap cannot be 0 or less. Reverted to minimum.', 'error');
        } else {
            inputs.pitch.value = parseFloat((e + m).toFixed(2));
        }
        saveSettings();
    });
    inputs.max.addEventListener('input', () => {
        if (lockPitchRadio.checked) {
            const p = parseFloat(inputs.pitch.value) || 0;
            const m = parseFloat(inputs.max.value) || 0;
            const newEdge = p - m;
            if (newEdge < MIN_GAP) {
                inputs.max.value = parseFloat((p - MIN_GAP).toFixed(2));
                inputs.edge.value = parseFloat(MIN_GAP.toFixed(2));
                if (typeof showNotification === 'function') showNotification('Gap cannot be 0 or less. Max hole reduced.', 'error');
            } else {
                inputs.edge.value = parseFloat(newEdge.toFixed(2));
            }
        } else {
            const e = parseFloat(inputs.edge.value) || 0;
            const m = parseFloat(inputs.max.value) || 0;
            inputs.pitch.value = parseFloat((e + m).toFixed(2));
        }
        saveSettings();
    });

    // Keep Max Hole >= Min Hole on blur or Enter (so typing e.g. 32â†’30 doesn't change min mid-edit)
    function applyMinMaxOrder() {
        const minVal = parseFloat(inputs.min.value);
        const maxVal = parseFloat(inputs.max.value);
        if (isNaN(minVal) || isNaN(maxVal)) return;
        
        let changed = false;
        if (minVal > maxVal) {
            inputs.max.value = minVal;
            inputs.max.dispatchEvent(new Event('input', {bubbles: true}));
            changed = true;
        }
        if (maxVal < minVal) {
            inputs.min.value = maxVal;
            inputs.min.dispatchEvent(new Event('input', {bubbles: true}));
            changed = true;
        }
        
        if (changed) {
            // Trigger change to save settings and regenerate
            inputs.min.dispatchEvent(new Event('change', {bubbles: true}));
            inputs.max.dispatchEvent(new Event('change', {bubbles: true}));
        }
    }
    inputs.min.addEventListener('blur', applyMinMaxOrder);
    inputs.max.addEventListener('blur', applyMinMaxOrder);
    inputs.min.addEventListener('keydown', (e) => { if (e.key === 'Enter') { applyMinMaxOrder(); inputs.min.blur(); } });
    inputs.max.addEventListener('keydown', (e) => { if (e.key === 'Enter') { applyMinMaxOrder(); inputs.max.blur(); } });

    // --- Margin Lock Logic ---
    let marginsLocked = false;
    const lockMarginsBtn = document.getElementById('lockMarginsBtn');
    
    function updateMarginsLockUI() {
        if (!lockMarginsBtn) return;
        lockMarginsBtn.innerHTML = marginsLocked
            ? '<svg viewBox="0 0 24 24" width="18" height="18" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path></svg>'
            : '<svg viewBox="0 0 24 24" width="18" height="18" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 9.9-1"></path></svg>';
        lockMarginsBtn.style.color = marginsLocked ? '#2563eb' : '#64748b';
        lockMarginsBtn.setAttribute('title', marginsLocked ? 'Unlock margins' : 'Lock margins (sync all)');
    }

    if (lockMarginsBtn) {
        lockMarginsBtn.addEventListener('click', () => {
            marginsLocked = !marginsLocked;
            updateMarginsLockUI();
            if (marginsLocked) {
                // Sync all to Top margin as base
                const val = inputs.mT.value;
                inputs.mB.value = val;
                inputs.mL.value = val;
                inputs.mR.value = val;
                saveSettings();
                setTimeout(generatePerforation, 10);
            }
        });
    }

    // Sync margins on input if locked
    const marginInputs = [inputs.mT, inputs.mB, inputs.mL, inputs.mR];
    marginInputs.forEach(inp => {
        inp.addEventListener('input', (e) => {
            if (marginsLocked) {
                const val = e.target.value;
                marginInputs.forEach(other => {
                    if (other !== e.target) other.value = val;
                });
            }
        });
    });

    // Min/Max hole size step buttons (+ / âˆ’)
    const holeSizeDecBtn = document.getElementById('holeSizeDecBtn');
    const holeSizeIncBtn = document.getElementById('holeSizeIncBtn');
    const holeSizeStep = 1;
    if (holeSizeDecBtn) {
        holeSizeDecBtn.addEventListener('click', () => {
            let minVal = parseFloat(inputs.min.value) || 0;
            let maxVal = parseFloat(inputs.max.value) || 0;
            minVal = Math.max(0.5, minVal - holeSizeStep);
            maxVal = Math.max(minVal, maxVal - holeSizeStep);
            inputs.min.value = minVal;
            inputs.max.value = maxVal;
            ensureValidGap();
            // Force trigger input and change events so all handlers (including pitch sync) see the new values
            inputs.min.dispatchEvent(new Event('input', {bubbles: true}));
            inputs.max.dispatchEvent(new Event('input', {bubbles: true}));
            inputs.min.dispatchEvent(new Event('change', {bubbles: true}));
            inputs.max.dispatchEvent(new Event('change', {bubbles: true}));
            saveSettings();
            // Explicitly trigger regeneration to update footer
            if (sourceImage) setTimeout(() => generatePerforation(), 20);
        });
    }
    if (holeSizeIncBtn) {
        holeSizeIncBtn.addEventListener('click', () => {
            let minVal = parseFloat(inputs.min.value) || 0;
            let maxVal = parseFloat(inputs.max.value) || 0;
            minVal += holeSizeStep;
            maxVal = Math.max(minVal, maxVal + holeSizeStep);
            inputs.min.value = minVal;
            inputs.max.value = maxVal;
            ensureValidGap();
            // Force trigger input and change events so all handlers (including pitch sync) see the new values
            inputs.min.dispatchEvent(new Event('input', {bubbles: true}));
            inputs.max.dispatchEvent(new Event('input', {bubbles: true}));
            inputs.min.dispatchEvent(new Event('change', {bubbles: true}));
            inputs.max.dispatchEvent(new Event('change', {bubbles: true}));
            saveSettings();
            // Explicitly trigger regeneration to update footer
            if (sourceImage) setTimeout(() => generatePerforation(), 20);
        });
    }

    // Auto-save & Refresh triggers
    const allInputs = Object.values(inputs);
    allInputs.push(lockRatioCheckbox, lockPitchRadio, lockGapRadio, splitMode);
    if (holeColorInput) allInputs.push(holeColorInput);
    if (panelColorInput) allInputs.push(panelColorInput);
    
    allInputs.forEach(el => {
        el.addEventListener('change', () => {
            saveSettings();
            setTimeout(generatePerforation, 10);
        });
    });

    // --- CANVAS VIEWPORT LOGIC ---
    function updateTransform() {
        container.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
    }

    function handleWheel(e) {
        if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            const factor = e.deltaY < 0 ? 1.1 : 0.9;
            applyZoom(scale * factor);
        }
    }
    
    function applyZoom(newScale) {
        if (newScale < 0.05) newScale = 0.05;
        if (newScale > 20) newScale = 20;
        scale = newScale;
        updateTransform();
    }
    
    function zoomFit() {
        if (canvas.width === 0) return;
        panX = 0; 
        panY = 0;
        const vw = mainViewport.clientWidth - 40;
        const vh = mainViewport.clientHeight - 40;
        const fitScale = Math.min(vw / canvas.width, vh / canvas.height);
        applyZoom(fitScale * 0.9);
    }

    function startDrag(e) {
        isDragging = true;
        dragStartX = e.clientX - panX;
        dragStartY = e.clientY - panY;
        mainViewport.style.cursor = 'grabbing';
    }

    function drag(e) {
        if (!isDragging) return;
        e.preventDefault();
        panX = e.clientX - dragStartX;
        panY = e.clientY - dragStartY;
        updateTransform();
    }

    function endDrag() {
        isDragging = false;
        mainViewport.style.cursor = 'grab';
    }

    // --- IMPORT / EXPORT LOGIC ---

    function handleImportConfig(e) {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (ev) => {
            const text = ev.target.result;
            // Simple parser for "Key: Value" lines
            const lines = text.split('\n');
            const config = {};
            lines.forEach(line => {
                const parts = line.split(':');
                if (parts.length >= 2) {
                    const key = parts[0].trim();
                    const val = parts.slice(1).join(':').trim();
                    config[key] = val;
                }
            });

            // Map back to inputs
            if(config['TotalWidth']) inputs.w.value = config['TotalWidth'].replace('mm','').trim();
            if(config['TotalHeight']) inputs.h.value = config['TotalHeight'].replace('mm','').trim();
            if(config['Pitch']) inputs.pitch.value = config['Pitch'].replace('mm','').trim();
            if(config['Gap']) inputs.edge.value = config['Gap'].replace('mm','').trim();
            if(config['MinHole']) inputs.min.value = config['MinHole'].replace('mm','').trim();
            if(config['MaxHole']) inputs.max.value = config['MaxHole'].replace('mm','').trim();
            
            // Layout
            if(config['SplitsW']) inputs.splitW.value = config['SplitsW'];
            if(config['SplitsH']) inputs.splitH.value = config['SplitsH'];
            
            // Margins
            if(config['MarginTop']) inputs.mT.value = config['MarginTop'];
            if(config['MarginBottom']) inputs.mB.value = config['MarginBottom'];
            if(config['MarginLeft']) inputs.mL.value = config['MarginLeft'];
            if(config['MarginRight']) inputs.mR.value = config['MarginRight'];
            
            // Image Settings
            if(config['ImageFit']) imgFitMode.value = config['ImageFit'];
            if(config['ImageScale']) inputs.imgScale.value = config['ImageScale'];
            if(config['ImagePanX']) inputs.imgPanX.value = config['ImagePanX'];
            if(config['ImagePanY']) inputs.imgPanY.value = config['ImagePanY'];
            
            if (typeof ensureValidGap === 'function') ensureValidGap();
            toggleImgControls();
            saveSettings();
            generatePerforation();
            if (typeof showNotification === 'function') showNotification('Settings imported!', 'success');
        };
        reader.readAsText(file);
        // Reset input
        e.target.value = '';
    }

    // --- GENERATION LOGIC ---

    function handleImageUpload(e) {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (event) => {
            const img = new Image();
            img.onload = () => {
                sourceImage = img;
                imageAspectRatio = img.naturalWidth / img.naturalHeight;
                ratioDisplay.innerText = `Image Ratio: ${imageAspectRatio.toFixed(3)}`;

                // When a new photo loads, keep and re-apply the last saved settings
                if (typeof loadSettings === 'function') {
                    loadSettings();
                }
                
                if (lockRatioCheckbox.checked) {
                    const currentH = parseFloat(inputs.h.value) || 2000;
                    inputs.w.value = Math.round(currentH * imageAspectRatio);
                }
                generateBtn.innerText = "Generate Pattern";
                generatePerforation();
            };
            img.src = event.target.result;
        };
        reader.readAsDataURL(file);
    }

    function parseSplits(str, total, errEl, axis) {
        const mode = splitMode.value;
        let parts = [];
        
        if (str && str.trim() !== "") {
            parts = str.split(',').map(s => parseFloat(s.trim())).filter(n => !isNaN(n) && n > 0);
        }

        if (parts.length === 0) return [total];

        const sum = parts.reduce((a, b) => a + b, 0);
        const diff = total - sum;

        // Logic based on mode
        if (mode === 'strict') {
            if (Math.abs(diff) > 1) {
                errEl.style.display = 'block';
                errEl.innerText = `Sum (${sum}) â‰  Total (${total})`;
                return [total]; // Fallback
            } else {
                errEl.style.display = 'none';
                return parts;
            }
        } 
        else if (mode === 'fill') {
            errEl.style.display = 'none';
            if (diff > 1) {
                // Add remainder panel
                parts.push(parseFloat(diff.toFixed(2)));
            }
            return parts;
        }
        else if (mode === 'update') {
            errEl.style.display = 'none';
            // We use the parts exactly. If they don't sum to total, we update Total.
            if (Math.abs(diff) > 1) {
                // Trigger update of global inputs
                if(axis === 'w') inputs.w.value = sum;
                if(axis === 'h') inputs.h.value = sum;
            }
            return parts;
        }

        return [total];
    }

    // Calculate alignment offset for a panel (usable area after margins)
    function getAlignmentOffset(usableW, usableH, pitch, alignment) {
        // Calculate how many complete holes fit in each direction
        const colsInPanel = Math.floor(usableW / pitch);
        const rowsInPanel = Math.floor(usableH / pitch);
        
        // Calculate the "remainder" space that needs to be distributed for alignment
        const remainderX = usableW - (colsInPanel * pitch);
        const remainderY = usableH - (rowsInPanel * pitch);
        
        let offsetX = 0;
        let offsetY = 0;
        
        switch(alignment) {
            case 'top-left':
                offsetX = 0;
                offsetY = 0;
                break;
            case 'top':
                offsetX = remainderX / 2;
                offsetY = 0;
                break;
            case 'top-right':
                offsetX = remainderX;
                offsetY = 0;
                break;
            case 'left':
                offsetX = 0;
                offsetY = remainderY / 2;
                break;
            case 'center':
                offsetX = remainderX / 2;
                offsetY = remainderY / 2;
                break;
            case 'right':
                offsetX = remainderX;
                offsetY = remainderY / 2;
                break;
            case 'bottom-left':
                offsetX = 0;
                offsetY = remainderY;
                break;
            case 'bottom':
                offsetX = remainderX / 2;
                offsetY = remainderY;
                break;
            case 'bottom-right':
                offsetX = remainderX;
                offsetY = remainderY;
                break;
            default:
                offsetX = remainderX / 2;
                offsetY = remainderY / 2;
        }
        
        return { offsetX, offsetY };
    }

    function getEffectiveColors(swapColors) {
        const defaultHole = '#000000';
        const defaultPanel = '#ffffff';
        const hole = (holeColorInput && holeColorInput.value) ? holeColorInput.value : defaultHole;
        const panel = (panelColorInput && panelColorInput.value) ? panelColorInput.value : defaultPanel;
        return swapColors
            ? { holeColor: panel, panelColor: hole }
            : { holeColor: hole, panelColor: panel };
    }

    function showNotification(message, type) {
        type = type || 'info';
        const container = document.getElementById('toastContainer');
        if (!container) return;
        const toast = document.createElement('div');
        toast.className = 'toast ' + type;
        toast.textContent = message;
        container.appendChild(toast);
        setTimeout(function() {
            if (toast.parentNode) toast.parentNode.removeChild(toast);
        }, 3000);
    }

    function showConfirmModal(message, onConfirm) {
        const modal = document.getElementById('confirmModal');
        const msgEl = document.getElementById('confirmModalMessage');
        const proceedBtn = document.getElementById('confirmModalOk');
        const cancelBtn = document.getElementById('confirmModalCancel');
        if (!modal || !msgEl) return;
        msgEl.textContent = message;
        modal.classList.add('active');
        function close() {
            modal.classList.remove('active');
            document.removeEventListener('keydown', onKeydown);
            var p = document.getElementById('confirmModalOk');
            var c = document.getElementById('confirmModalCancel');
            if (p) p.replaceWith(p.cloneNode(true));
            if (c) c.replaceWith(c.cloneNode(true));
        }
        function onProceed() {
            close();
            if (typeof onConfirm === 'function') onConfirm();
        }
        function onCancel() {
            close();
        }
        function onKeydown(e) {
            if (e.key === 'Enter') { e.preventDefault(); onProceed(); }
            if (e.key === 'Escape') { e.preventDefault(); onCancel(); }
        }
        document.addEventListener('keydown', onKeydown);
        var p = document.getElementById('confirmModalOk');
        var c = document.getElementById('confirmModalCancel');
        if (p) p.addEventListener('click', onProceed);
        if (c) c.addEventListener('click', onCancel);
    }

    function openRawPhotoModal() {
        const modal = document.getElementById('rawPhotoModal');
        const rawCanvas = document.getElementById('rawPhotoCanvas');
        const placeholder = document.getElementById('rawPhotoPlaceholder');
        if (!modal || !rawCanvas || !placeholder) return;
        if (!sourceImage) {
            showNotification('No image loaded. Upload a photo first.', 'info');
            return;
        }
        const w = sourceImage.naturalWidth;
        const h = sourceImage.naturalHeight;
        rawCanvas.width = w;
        rawCanvas.height = h;
        const rctx = rawCanvas.getContext('2d');
        rctx.drawImage(sourceImage, 0, 0);
        placeholder.style.display = 'none';
        rawCanvas.style.display = 'block';
        modal.classList.add('active');
    }

    function closeRawPhotoModal() {
        const modal = document.getElementById('rawPhotoModal');
        if (modal) modal.classList.remove('active');
    }

    function startFooterProgress() {
        const wrap = document.getElementById('footerProgressWrap');
        const bar = document.getElementById('footerProgressBar');
        const fill = document.getElementById('footerProgressFill');
        const status = document.getElementById('footerProgressStatus');
        const timeEl = document.getElementById('footerProgressTime');
        if (wrap && bar && fill && status) {
            wrap.style.display = 'inline-flex';
            status.textContent = 'Generatingâ€¦';
            if (timeEl) timeEl.textContent = '';
            bar.classList.remove('done');
            bar.classList.add('indeterminate');
            fill.style.width = '0%';
        }
    }
    function endFooterProgress(elapsedMs) {
        const wrap = document.getElementById('footerProgressWrap');
        const bar = document.getElementById('footerProgressBar');
        const fill = document.getElementById('footerProgressFill');
        const status = document.getElementById('footerProgressStatus');
        const timeEl = document.getElementById('footerProgressTime');
        if (!wrap || !bar || !fill || !status) return;
        bar.classList.remove('indeterminate');
        bar.classList.add('done');
        fill.style.width = '100%';
        status.textContent = 'Done';
        if (timeEl) {
            if (elapsedMs >= 1000) timeEl.textContent = (elapsedMs / 1000).toFixed(2) + ' s';
            else timeEl.textContent = elapsedMs.toFixed(0) + ' ms';
        }
        setTimeout(function() {
            bar.classList.remove('done');
            fill.style.width = '0%';
            if (status) status.textContent = 'Ready';
        }, 2200);
    }
    function generatePerforation() {
        if (!sourceImage) return;

        // Generate new ID for this run
        currentFileID = generateUniqueID();

        const w = parseFloat(inputs.w.value);
        const h = parseFloat(inputs.h.value);
        const pitch = parseFloat(inputs.pitch.value);
        const minDia = parseFloat(inputs.min.value);
        const maxDia = parseFloat(inputs.max.value);
        const invert = inputs.invert.checked;
        
        // Parsing subdivisions
        const widths = parseSplits(inputs.splitW.value, w, errSplitW, 'w');
        const heights = parseSplits(inputs.splitH.value, h, errSplitH, 'h');
        
        // Refresh W/H in case 'update' mode changed them
        const finalW = parseFloat(inputs.w.value);
        const finalH = parseFloat(inputs.h.value);
        
        // Calculate Sheet Definitions
        sheetDefinitions = [];
        let currY = 0;
        for (let sh of heights) {
            let currX = 0;
            for (let sw of widths) {
                sheetDefinitions.push({
                    x: currX, y: currY, w: sw, h: sh
                });
                currX += sw;
            }
            currY += sh;
        }

        // Safety Check
        const estTotal = (finalW / pitch) * (finalH / pitch);
        if (estTotal > 300000) {
            showConfirmModal('Warning: ~' + Math.floor(estTotal).toLocaleString() + ' holes. Proceed?\n\nPress Enter to continue, Esc to cancel.', function() {
                warningMsg.style.display = estTotal > 50000 ? 'block' : 'none';
                generateBtn.innerText = "Processing...";
                startFooterProgress();
                setTimeout(function() {
                    const t0 = performance.now();
                    render(finalW, finalH, pitch, minDia, maxDia, invert);
                    updateFooterFromLastRender();
                    endFooterProgress(performance.now() - t0);
                    generateBtn.innerText = "Update Pattern";
                }, 50);
            });
            return;
        }
        warningMsg.style.display = estTotal > 50000 ? 'block' : 'none';

        generateBtn.innerText = "Processing...";
        startFooterProgress();
        setTimeout(() => {
            const t0 = performance.now();
            render(finalW, finalH, pitch, minDia, maxDia, invert);
            updateFooterFromLastRender();
            endFooterProgress(performance.now() - t0);
            generateBtn.innerText = "Update Pattern";
        }, 50);
    }

    function render(w, h, pitch, minDia, maxDia, invert) {
        const colors = getEffectiveColors(swapHolePanelColors);
        // Canvas setup
        let pixelScale = CONFIG.baseScale;
        const targetW = w * pixelScale;
        const targetH = h * pixelScale;
        
        if (targetW > CONFIG.maxCanvasDimension || targetH > CONFIG.maxCanvasDimension) {
            const maxSide = Math.max(targetW, targetH);
            pixelScale = pixelScale * (CONFIG.maxCanvasDimension / maxSide);
        }

        canvas.width = w * pixelScale;
        canvas.height = h * pixelScale;

        // Draw Panel Background
        ctx.fillStyle = colors.panelColor; 
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Visual Sheets
        ctx.strokeStyle = "#e2e8f0";
        ctx.lineWidth = 2;
        sheetDefinitions.forEach(sheet => {
            ctx.strokeRect(sheet.x * pixelScale, sheet.y * pixelScale, sheet.w * pixelScale, sheet.h * pixelScale);
        });

        // --- IMAGE PROCESSING (WITH OFFSET/SCALE) ---
        const cols = Math.floor(w / pitch);
        const rows = Math.floor(h / pitch);

        const analysisCanvas = document.createElement('canvas');
        analysisCanvas.width = cols;
        analysisCanvas.height = rows;
        const actx = analysisCanvas.getContext('2d');
        
        // Logic for Image Drawing based on mode
        if (imgFitMode.value === 'stretch') {
            actx.drawImage(sourceImage, 0, 0, cols, rows);
        } else {
            // Keep Ratio logic
            // 1. Calculate aspect ratios
            const canvasRatio = cols / rows;
            const imgRatio = sourceImage.naturalWidth / sourceImage.naturalHeight;
            
            // 2. Base fit
            let drawW = cols;
            let drawH = cols / imgRatio;
            
            // User scale override
            const userScale = parseFloat(inputs.imgScale.value) || 1.0;
            drawW *= userScale;
            drawH *= userScale;
            
            // Center the image initially
            let drawX = (cols - drawW) / 2;
            let drawY = (rows - drawH) / 2;
            
            // Apply User Pan (Convert mm to grid units)
            const panXGrid = (parseFloat(inputs.imgPanX.value) || 0) / pitch;
            const panYGrid = (parseFloat(inputs.imgPanY.value) || 0) / pitch;
            
            drawX += panXGrid;
            drawY += panYGrid;
            
            // Clear background for analysis
            actx.fillStyle = "white"; 
            actx.fillRect(0,0, cols, rows);
            
            actx.drawImage(sourceImage, drawX, drawY, drawW, drawH);
        }
        
        const pixels = actx.getImageData(0, 0, cols, rows).data;

        // Margins
        const mT = parseFloat(inputs.mT.value) || 0;
        const mB = parseFloat(inputs.mB.value) || 0;
        const mL = parseFloat(inputs.mL.value) || 0;
        const mR = parseFloat(inputs.mR.value) || 0;

        ctx.fillStyle = colors.holeColor;
        
        let count = 0;
        let totalHoleArea = 0;
        generatedHoles = []; 
        panelStats = []; // Reset panel stats
        
        // Initialize panel stats
        sheetDefinitions.forEach((sheet, idx) => {
            panelStats.push({
                sheetIndex: idx,
                holeCount: 0,
                openArea: 0,
                panelArea: sheet.w * sheet.h
            });
        });

        // Process each panel separately with its own alignment
        sheetDefinitions.forEach((activeSheet, sheetIndex) => {
            // Calculate usable area (after margins)
            const usableW = activeSheet.w - mL - mR;
            const usableH = activeSheet.h - mT - mB;
            
            if (usableW <= 0 || usableH <= 0) return; // Skip if no usable area
            
            // Calculate alignment offset for the usable area
            const alignOffset = getAlignmentOffset(usableW, usableH, pitch, panelAlignment);
            
            // Calculate how many holes fit in this panel
            const colsInPanel = Math.floor(usableW / pitch);
            const rowsInPanel = Math.floor(usableH / pitch);
            
            // Starting position for first hole in this panel (with alignment)
            const startX = activeSheet.x + mL + alignOffset.offsetX + (pitch / 2);
            const startY = activeSheet.y + mT + alignOffset.offsetY + (pitch / 2);
            
            // Generate holes for this panel
            for (let py = 0; py < rowsInPanel; py++) {
                for (let px = 0; px < colsInPanel; px++) {
                    const cx = startX + (px * pitch);
                    const cy = startY + (py * pitch);
                    
                    // Verify hole is within panel bounds
                    if (cx < activeSheet.x + mL || cx > activeSheet.x + activeSheet.w - mR) continue;
                    if (cy < activeSheet.y + mT || cy > activeSheet.y + activeSheet.h - mB) continue;
                    
                    // Get image pixel for this position
                    const gridX = Math.floor((cx / w) * cols);
                    const gridY = Math.floor((cy / h) * rows);
                    
                    if (gridX < 0 || gridX >= cols || gridY < 0 || gridY >= rows) continue;
                    
                    const idx = (gridY * cols + gridX) * 4;
                const bVal = (pixels[idx] + pixels[idx+1] + pixels[idx+2]) / 3;
                const norm = bVal / 255;
                const sizeFactor = invert ? norm : (1.0 - norm);
                const diameter = minDia + (sizeFactor * (maxDia - minDia));
                const r = diameter / 2;

                const drawX = cx * pixelScale;
                const drawY = cy * pixelScale;
                const drawR = r * pixelScale;

                ctx.beginPath();
                ctx.arc(drawX, drawY, drawR, 0, Math.PI * 2);
                ctx.fill();

                generatedHoles.push({x: cx, y: cy, r: r});
                
                    const holeArea = Math.PI * Math.pow(r, 2);
                    totalHoleArea += holeArea;
                count++;
                    
                    // Update panel stats
                    if (sheetIndex < panelStats.length) {
                        panelStats[sheetIndex].holeCount++;
                        panelStats[sheetIndex].openArea += holeArea;
            }
        }
            }
        });
        
        
        ctx.strokeStyle = "rgba(239, 68, 68, 0.3)";
        ctx.lineWidth = 1;
        sheetDefinitions.forEach(sheet => {
            const sx = (sheet.x + mL) * pixelScale;
            const sy = (sheet.y + mT) * pixelScale;
            const sw = (sheet.w - mL - mR) * pixelScale;
            const sh = (sheet.h - mT - mB) * pixelScale;
            if (sw > 0 && sh > 0) ctx.strokeRect(sx, sy, sw, sh);
        });
        
        // Draw opening percentage overlay for each panel (if enabled for display)
        drawPercentageOverlay(ctx, pixelScale, showPercentage);

        document.getElementById('statCount').innerText = count.toLocaleString();
        document.getElementById('statArea').innerText = ((totalHoleArea / (w*h)) * 100).toFixed(2) + "%";
        
        // Update footer statistics - force direct updates to ensure they happen
        const footerPanels = document.getElementById('footerPanels');
        const footerHoles = document.getElementById('footerHoles');
        const footerOpening = document.getElementById('footerOpening');
        const footerMinHole = document.getElementById('footerMinHole');
        const footerMaxHole = document.getElementById('footerMaxHole');
        const footerSpacing = document.getElementById('footerSpacing');
        
        if (footerPanels) footerPanels.textContent = sheetDefinitions.length.toString();
        if (footerHoles) {
            footerHoles.textContent = count.toLocaleString();
            footerHoles.setAttribute('data-count', count); // Force DOM update
        }
        if (footerOpening) footerOpening.textContent = ((totalHoleArea / (w*h)) * 100).toFixed(2) + "%";
        if (footerMinHole) footerMinHole.textContent = inputs.min.value || "0";
        if (footerMaxHole) footerMaxHole.textContent = inputs.max.value || "0";
        if (footerSpacing) footerSpacing.textContent = inputs.pitch.value || "0";
        
        downloadImgBtn.disabled = false;
        downloadTxtBtn.disabled = false;
        downloadDxfBtn.disabled = false;
        downloadSvgBtn.disabled = false;
        if (downloadZipBtn) downloadZipBtn.disabled = false;
        
        if (scale === 1 && panX === 0) zoomFit();
    }

    // --- EXPORT FUNCTIONS ---

    // Update full footer from last render state (call after render so +/- and Update Pattern always refresh holes)
    function updateFooterFromLastRender() {
        const footerPanels = document.getElementById('footerPanels');
        const footerHoles = document.getElementById('footerHoles');
        const footerOpening = document.getElementById('footerOpening');
        const footerMinHole = document.getElementById('footerMinHole');
        const footerMaxHole = document.getElementById('footerMaxHole');
        const footerSpacing = document.getElementById('footerSpacing');
        if (footerPanels) footerPanels.textContent = sheetDefinitions.length.toString();
        if (footerHoles) {
            const holeCount = generatedHoles.length;
            footerHoles.textContent = holeCount.toLocaleString();
            footerHoles.setAttribute('data-count', holeCount);
            // Force repaint
            footerHoles.style.opacity = '0.99';
            setTimeout(() => { if (footerHoles) footerHoles.style.opacity = '1'; }, 0);
        }
        const w = parseFloat(inputs.w.value) || 0;
        const h = parseFloat(inputs.h.value) || 0;
        if (w > 0 && h > 0 && footerOpening) {
            let totalHoleArea = 0;
            generatedHoles.forEach(ho => { totalHoleArea += Math.PI * Math.pow(ho.r, 2); });
            footerOpening.textContent = ((totalHoleArea / (w * h)) * 100).toFixed(2) + "%";
        }
        if (footerMinHole) footerMinHole.textContent = inputs.min.value || "0";
        if (footerMaxHole) footerMaxHole.textContent = inputs.max.value || "0";
        if (footerSpacing) footerSpacing.textContent = inputs.pitch.value || "0";
    }

    // Update footer Min/Max/Spacing from current inputs (e.g. when +/- used without regenerating)
    function updateFooterSpecsFromInputs() {
        const footerMinHole = document.getElementById('footerMinHole');
        const footerMaxHole = document.getElementById('footerMaxHole');
        const footerSpacing = document.getElementById('footerSpacing');
        if (footerMinHole) footerMinHole.textContent = inputs.min.value || "0";
        if (footerMaxHole) footerMaxHole.textContent = inputs.max.value || "0";
        if (footerSpacing) footerSpacing.textContent = inputs.pitch.value || "0";
    }
    
    // Helper function to get footer statistics
    function getFooterStatistics() {
        const w = parseFloat(inputs.w.value);
        const h = parseFloat(inputs.h.value);
        const panels = sheetDefinitions.length;
        const holes = generatedHoles.length;
        // Calculate total hole area
        let totalHoleArea = 0;
        generatedHoles.forEach(h => {
            totalHoleArea += Math.PI * Math.pow(h.r, 2);
        });
        const opening = ((totalHoleArea / (w * h)) * 100).toFixed(2) + "%";
        const minHole = inputs.min.value || "0";
        const maxHole = inputs.max.value || "0";
        const spacing = inputs.pitch.value || "0";
        return { panels, holes, opening, minHole, maxHole, spacing };
    }

    function downloadDXF() {
        if (generatedHoles.length === 0) return;
        const filename = getDownloadFilename();
        const totalH = parseFloat(inputs.h.value);
        const totalW = parseFloat(inputs.w.value);

        // Minimal DXF R12 format - simplest possible for maximum compatibility
        let dxf = "";
        
        // Header - minimal required
        dxf += "0\nSECTION\n2\nHEADER\n";
        dxf += "9\n$ACADVER\n1\nAC1009\n";
        dxf += "0\nENDSEC\n";
        
        // Tables - minimal required
        dxf += "0\nSECTION\n2\nTABLES\n";
        
        // Layer table - only layer 0 required
        dxf += "0\nTABLE\n2\nLAYER\n70\n1\n";
        dxf += "0\nLAYER\n2\n0\n70\n0\n62\n7\n6\nCONTINUOUS\n";
        dxf += "0\nENDTAB\n";
        
        dxf += "0\nENDSEC\n";

        // Entities section
        dxf += "0\nSECTION\n2\nENTITIES\n";

        // Draw panel boundaries as simple POLYLINE
        sheetDefinitions.forEach(s => {
            dxf += "0\nPOLYLINE\n8\n0\n66\n1\n70\n1\n";
            dxf += "0\nVERTEX\n8\n0\n10\n" + s.x.toFixed(3) + "\n20\n" + (totalH - s.y).toFixed(3) + "\n";
            dxf += "0\nVERTEX\n8\n0\n10\n" + (s.x + s.w).toFixed(3) + "\n20\n" + (totalH - s.y).toFixed(3) + "\n";
            dxf += "0\nVERTEX\n8\n0\n10\n" + (s.x + s.w).toFixed(3) + "\n20\n" + (totalH - (s.y + s.h)).toFixed(3) + "\n";
            dxf += "0\nVERTEX\n8\n0\n10\n" + s.x.toFixed(3) + "\n20\n" + (totalH - (s.y + s.h)).toFixed(3) + "\n";
            dxf += "0\nSEQEND\n8\n0\n";
        });
        
        // Draw holes as circles
        generatedHoles.forEach(h => {
            const dxfY = totalH - h.y;
            dxf += "0\nCIRCLE\n8\n0\n";
            dxf += "10\n" + h.x.toFixed(3) + "\n";
            dxf += "20\n" + dxfY.toFixed(3) + "\n";
            dxf += "30\n0.0\n";
            dxf += "40\n" + h.r.toFixed(3) + "\n";
        });
        
        // Draw percentage text if enabled
        if (showPercentage && panelStats.length > 0) {
            panelStats.forEach((stat, idx) => {
                if (idx < sheetDefinitions.length && stat.panelArea > 0) {
                    const sheet = sheetDefinitions[idx];
                    const percentage = stat.panelArea > 0 ? ((stat.openArea / stat.panelArea) * 100).toFixed(1) : "0.0";
                    const textX = sheet.x + sheet.w / 2;
                    const textY = totalH - (sheet.y + sheet.h / 2);
                    
                    dxf += "0\nTEXT\n8\n0\n";
                    dxf += "10\n" + textX.toFixed(3) + "\n";
                    dxf += "20\n" + textY.toFixed(3) + "\n";
                    dxf += "30\n0.0\n";
                    dxf += "40\n10.0\n";
                    dxf += "1\n" + percentage + "%\n";
                    dxf += "50\n0.0\n";
                }
            });
        }
        
        // Add footer statistics if enabled
        if (includeFooterStatsInDownload) {
            const stats = getFooterStatistics();
            const footerY = totalH + 20; // Position below the design
            const fontSize = 8.0;
            const startX = totalW / 2 - 100; // Center the text
            
            dxf += "0\nTEXT\n8\n0\n";
            dxf += "10\n" + startX.toFixed(3) + "\n";
            dxf += "20\n" + footerY.toFixed(3) + "\n";
            dxf += "30\n0.0\n";
            dxf += "40\n" + fontSize.toFixed(1) + "\n";
            dxf += "1\nPanels: " + stats.panels + " | Holes: " + stats.holes.toLocaleString() + " | Opening: " + stats.opening + " | Min Hole: " + stats.minHole + "mm | Max Hole: " + stats.maxHole + "mm | Spacing: " + stats.spacing + "mm\n";
            dxf += "50\n0.0\n";
        }

        dxf += "0\nENDSEC\n";
        dxf += "0\nEOF\n";

        const blob = new Blob([dxf], {type: "application/dxf"});
        const link = document.createElement('a');
        link.download = `${filename}.dxf`;
        link.href = URL.createObjectURL(blob);
        link.click();
    }

    // Helper function to draw percentage overlay
    function drawPercentageOverlay(ctx, pixelScale, shouldDraw) {
        if (!shouldDraw || panelStats.length === 0) return;
        
        ctx.save();
        const baseFontSize = Math.max(14, Math.min(24, pixelScale * 1.5));
        const fontSize = baseFontSize * (percentageSize / 100);
        ctx.font = `bold ${fontSize}px sans-serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        
        panelStats.forEach((stat, idx) => {
            if (idx < sheetDefinitions.length && stat.panelArea > 0) {
                const sheet = sheetDefinitions[idx];
                const percentage = stat.panelArea > 0 ? ((stat.openArea / stat.panelArea) * 100).toFixed(1) : "0.0";
                
                const centerX = (sheet.x + sheet.w / 2) * pixelScale;
                const centerY = (sheet.y + sheet.h / 2) * pixelScale;
                
                // Draw background rectangle
                const text = `${percentage}%`;
                const metrics = ctx.measureText(text);
                const textWidth = metrics.width;
                const textHeight = fontSize;
                const padding = 6;
                
                // Background
                ctx.fillStyle = "rgba(0, 0, 0, 0.75)";
                ctx.fillRect(
                    centerX - textWidth / 2 - padding,
                    centerY - textHeight / 2 - padding,
                    textWidth + padding * 2,
                    textHeight + padding * 2
                );
                
                // Border
                ctx.strokeStyle = "white";
                ctx.lineWidth = 1;
                ctx.strokeRect(
                    centerX - textWidth / 2 - padding,
                    centerY - textHeight / 2 - padding,
                    textWidth + padding * 2,
                    textHeight + padding * 2
                );
                
                // Text
                ctx.fillStyle = "white";
                ctx.fillText(text, centerX, centerY);
            }
        });
        ctx.restore();
    }

    function downloadImage() {
        if (!sourceImage) return;
        const filename = getDownloadFilename();
        const colors = getEffectiveColors(swapHolePanelColors);
        
        // Calculate footer height if needed
        const footerHeight = includeFooterStatsInDownload ? 50 : 0;
        
        // Create a temporary canvas to render with/without percentage
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height + footerHeight;
        const tempCtx = tempCanvas.getContext('2d');
        
        // Fill background
        tempCtx.fillStyle = colors.panelColor;
        tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
        
        // Copy the main canvas
        tempCtx.drawImage(canvas, 0, 0);
        
        // Add percentage if "Show Opening % on Panels" is enabled
        if (showPercentage) {
            const pixelScale = canvas.width / parseFloat(inputs.w.value);
            drawPercentageOverlay(tempCtx, pixelScale, true);
        }
        
        // Add footer statistics if enabled
        if (includeFooterStatsInDownload) {
            const stats = getFooterStatistics();
            tempCtx.save();
            tempCtx.fillStyle = '#000000';
            tempCtx.font = '14px sans-serif';
            tempCtx.textAlign = 'center';
            tempCtx.textBaseline = 'top';
            const footerText = `Panels: ${stats.panels} | Holes: ${stats.holes.toLocaleString()} | Opening: ${stats.opening} | Min Hole: ${stats.minHole}mm | Max Hole: ${stats.maxHole}mm | Spacing: ${stats.spacing}mm`;
            tempCtx.fillText(footerText, tempCanvas.width / 2, canvas.height + 10);
            tempCtx.restore();
        }
        
        const imgLink = document.createElement('a');
        imgLink.download = `${filename}.png`;
        imgLink.href = tempCanvas.toDataURL('image/png');
        imgLink.click();
    }

    function downloadSVG() {
        if (generatedHoles.length === 0) return;
        const filename = getDownloadFilename();
        const totalH = parseFloat(inputs.h.value);
        const totalW = parseFloat(inputs.w.value);
        const footerHeight = includeFooterStatsInDownload ? 20 : 0;
        const svgHeight = totalH + footerHeight;
        const colors = getEffectiveColors(swapHolePanelColors);

        let svg = '<?xml version="1.0" encoding="UTF-8"?>\n';
        svg += '<svg xmlns="http://www.w3.org/2000/svg" ';
        svg += `width="${totalW}mm" height="${svgHeight}mm" `;
        svg += `viewBox="0 0 ${totalW} ${svgHeight}">\n`;
        // Panel background (unflipped, in drawing coordinates)
        svg += `<rect width="${totalW}" height="${totalH}" fill="${colors.panelColor}"/>\n`;
        svg += '<g transform="translate(0,' + totalH + ') scale(1,-1)">\n'; // Flip Y axis

        // Draw panel boundaries
        svg += '<g id="panels" stroke="#0000FF" stroke-width="0.5" fill="none">\n';
        sheetDefinitions.forEach(s => {
            svg += `<rect x="${s.x}" y="${s.y}" width="${s.w}" height="${s.h}"/>\n`;
        });
        svg += '</g>\n';

        // Draw holes
        svg += `<g id="holes" fill="${colors.holeColor}">\n`;
        generatedHoles.forEach(h => {
            svg += `<circle cx="${h.x.toFixed(3)}" cy="${h.y.toFixed(3)}" r="${h.r.toFixed(3)}"/>\n`;
        });
        svg += '</g>\n';

        // Draw percentage text if enabled
        if (showPercentage && panelStats.length > 0) {
            svg += '<g id="text" fill="#000000" font-family="Arial" font-size="10" text-anchor="middle">\n';
            panelStats.forEach((stat, idx) => {
                if (idx < sheetDefinitions.length && stat.panelArea > 0) {
                    const sheet = sheetDefinitions[idx];
                    const percentage = stat.panelArea > 0 ? ((stat.openArea / stat.panelArea) * 100).toFixed(1) : "0.0";
                    const textX = sheet.x + sheet.w / 2;
                    const textY = sheet.y + sheet.h / 2;
                    svg += `<text x="${textX.toFixed(3)}" y="${textY.toFixed(3)}">${percentage}%</text>\n`;
                }
            });
            svg += '</g>\n';
        }

        svg += '</g>\n';

        // Add footer statistics if enabled
        if (includeFooterStatsInDownload) {
            const stats = getFooterStatistics();
            const footerY = totalH + 20; // Position below the design
            svg += `<text x="${totalW / 2}" y="${footerY}" fill="#000000" font-family="Arial" font-size="8" text-anchor="middle">Panels: ${stats.panels} | Holes: ${stats.holes.toLocaleString()} | Opening: ${stats.opening} | Min Hole: ${stats.minHole}mm | Max Hole: ${stats.maxHole}mm | Spacing: ${stats.spacing}mm</text>\n`;
        }

        svg += '</svg>';

        const blob = new Blob([svg], { type: 'image/svg+xml' });
        const link = document.createElement('a');
        link.download = `${filename}.svg`;
        link.href = URL.createObjectURL(blob);
        link.click();
    }

    function downloadSpecs() {
        const filename = getDownloadFilename();
        const now = new Date();
        
        // Structured Text Content
        const content = 
`Perforated panel Designer Specification File
-----------------------------
Generated: ${now.toLocaleString()}
FileID: ${filename}

[Global Config]
TotalWidth: ${inputs.w.value}
TotalHeight: ${inputs.h.value}
Pitch: ${inputs.pitch.value}
Gap: ${inputs.edge.value}
MinHole: ${inputs.min.value}
MaxHole: ${inputs.max.value}
Invert: ${inputs.invert.checked}

[Layout]
SplitMode: ${splitMode.value}
SplitsW: ${inputs.splitW.value}
SplitsH: ${inputs.splitH.value}

[Margins]
MarginTop: ${inputs.mT.value}
MarginBottom: ${inputs.mB.value}
MarginLeft: ${inputs.mL.value}
MarginRight: ${inputs.mR.value}

[Image Settings]
ImageFit: ${imgFitMode.value}
ImageScale: ${inputs.imgScale.value}
ImagePanX: ${inputs.imgPanX.value}
ImagePanY: ${inputs.imgPanY.value}

[Stats]
TotalHoles: ${document.getElementById('statCount').innerText}
OpenArea: ${document.getElementById('statArea').innerText}
`;
        const blob = new Blob([content], { type: 'text/plain' });
        const textLink = document.createElement('a');
        textLink.download = `${filename}.txt`;
        textLink.href = URL.createObjectURL(blob);
        textLink.click();
    }
    
    // Helper function to get PNG as data URL
    function getPNGDataURL() {
        if (!sourceImage) return null;
        const colors = getEffectiveColors(swapHolePanelColors);
        
        // Calculate footer height if needed
        const footerHeight = includeFooterStatsInDownload ? 50 : 0;
        
        // Create a temporary canvas to render with/without percentage
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height + footerHeight;
        const tempCtx = tempCanvas.getContext('2d');
        
        // Fill background
        tempCtx.fillStyle = colors.panelColor;
        tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
        
        // Copy the main canvas
        tempCtx.drawImage(canvas, 0, 0);
        
        // Add percentage if "Show Opening % on Panels" is enabled
        if (showPercentage) {
            const pixelScale = canvas.width / parseFloat(inputs.w.value);
            drawPercentageOverlay(tempCtx, pixelScale, true);
        }
        
        // Add footer statistics if enabled
        if (includeFooterStatsInDownload) {
            const stats = getFooterStatistics();
            tempCtx.save();
            tempCtx.fillStyle = '#000000';
            tempCtx.font = '14px sans-serif';
            tempCtx.textAlign = 'center';
            tempCtx.textBaseline = 'top';
            const footerText = `Panels: ${stats.panels} | Holes: ${stats.holes.toLocaleString()} | Opening: ${stats.opening} | Min Hole: ${stats.minHole}mm | Max Hole: ${stats.maxHole}mm | Spacing: ${stats.spacing}mm`;
            tempCtx.fillText(footerText, tempCanvas.width / 2, canvas.height + 10);
            tempCtx.restore();
        }
        
        return tempCanvas.toDataURL('image/png');
    }
    
    // Helper function to get TXT content as string
    function getTXTContent() {
        const filename = getDownloadFilename();
        const now = new Date();
        
        return `Perforated panel Designer Specification File
-----------------------------
Generated: ${now.toLocaleString()}
FileID: ${filename}

[Global Config]
TotalWidth: ${inputs.w.value}
TotalHeight: ${inputs.h.value}
Pitch: ${inputs.pitch.value}
Gap: ${inputs.edge.value}
MinHole: ${inputs.min.value}
MaxHole: ${inputs.max.value}
Invert: ${inputs.invert.checked}

[Layout]
SplitMode: ${splitMode.value}
SplitsW: ${inputs.splitW.value}
SplitsH: ${inputs.splitH.value}

[Margins]
MarginTop: ${inputs.mT.value}
MarginBottom: ${inputs.mB.value}
MarginLeft: ${inputs.mL.value}
MarginRight: ${inputs.mR.value}

[Image Settings]
ImageFit: ${imgFitMode.value}
ImageScale: ${inputs.imgScale.value}
ImagePanX: ${inputs.imgPanX.value}
ImagePanY: ${inputs.imgPanY.value}

[Stats]
TotalHoles: ${document.getElementById('statCount').innerText}
OpenArea: ${document.getElementById('statArea').innerText}
`;
    }
    
    // Helper function to get DXF content as string
    function getDXFContent() {
        if (generatedHoles.length === 0) return null;
        const totalH = parseFloat(inputs.h.value);
        const totalW = parseFloat(inputs.w.value);

        // Minimal DXF R12 format - simplest possible for maximum compatibility
        let dxf = "";
        
        // Header - minimal required
        dxf += "0\nSECTION\n2\nHEADER\n";
        dxf += "9\n$ACADVER\n1\nAC1009\n";
        dxf += "0\nENDSEC\n";
        
        // Tables - minimal required
        dxf += "0\nSECTION\n2\nTABLES\n";
        
        // Layer table - only layer 0 required
        dxf += "0\nTABLE\n2\nLAYER\n70\n1\n";
        dxf += "0\nLAYER\n2\n0\n70\n0\n62\n7\n6\nCONTINUOUS\n";
        dxf += "0\nENDTAB\n";
        
        dxf += "0\nENDSEC\n";

        // Entities section
        dxf += "0\nSECTION\n2\nENTITIES\n";

        // Draw panel boundaries as simple POLYLINE
        sheetDefinitions.forEach(s => {
            dxf += "0\nPOLYLINE\n8\n0\n66\n1\n70\n1\n";
            dxf += "0\nVERTEX\n8\n0\n10\n" + s.x.toFixed(3) + "\n20\n" + (totalH - s.y).toFixed(3) + "\n";
            dxf += "0\nVERTEX\n8\n0\n10\n" + (s.x + s.w).toFixed(3) + "\n20\n" + (totalH - s.y).toFixed(3) + "\n";
            dxf += "0\nVERTEX\n8\n0\n10\n" + (s.x + s.w).toFixed(3) + "\n20\n" + (totalH - (s.y + s.h)).toFixed(3) + "\n";
            dxf += "0\nVERTEX\n8\n0\n10\n" + s.x.toFixed(3) + "\n20\n" + (totalH - (s.y + s.h)).toFixed(3) + "\n";
            dxf += "0\nSEQEND\n8\n0\n";
        });
        
        // Draw holes as circles
        generatedHoles.forEach(h => {
            const dxfY = totalH - h.y;
            dxf += "0\nCIRCLE\n8\n0\n";
            dxf += "10\n" + h.x.toFixed(3) + "\n";
            dxf += "20\n" + dxfY.toFixed(3) + "\n";
            dxf += "30\n0.0\n";
            dxf += "40\n" + h.r.toFixed(3) + "\n";
        });
        
        // Draw percentage text if enabled
        if (showPercentage && panelStats.length > 0) {
            panelStats.forEach((stat, idx) => {
                if (idx < sheetDefinitions.length && stat.panelArea > 0) {
                    const sheet = sheetDefinitions[idx];
                    const percentage = stat.panelArea > 0 ? ((stat.openArea / stat.panelArea) * 100).toFixed(1) : "0.0";
                    const textX = sheet.x + sheet.w / 2;
                    const textY = totalH - (sheet.y + sheet.h / 2);
                    
                    dxf += "0\nTEXT\n8\n0\n";
                    dxf += "10\n" + textX.toFixed(3) + "\n";
                    dxf += "20\n" + textY.toFixed(3) + "\n";
                    dxf += "30\n0.0\n";
                    dxf += "40\n10.0\n";
                    dxf += "1\n" + percentage + "%\n";
                    dxf += "50\n0.0\n";
                }
            });
        }
        
        // Add footer statistics if enabled
        if (includeFooterStatsInDownload) {
            const stats = getFooterStatistics();
            const footerY = totalH + 20; // Position below the design
            const fontSize = 8.0;
            const startX = totalW / 2 - 100; // Center the text
            
            dxf += "0\nTEXT\n8\n0\n";
            dxf += "10\n" + startX.toFixed(3) + "\n";
            dxf += "20\n" + footerY.toFixed(3) + "\n";
            dxf += "30\n0.0\n";
            dxf += "40\n" + fontSize.toFixed(1) + "\n";
            dxf += "1\nPanels: " + stats.panels + " | Holes: " + stats.holes.toLocaleString() + " | Opening: " + stats.opening + " | Min Hole: " + stats.minHole + "mm | Max Hole: " + stats.maxHole + "mm | Spacing: " + stats.spacing + "mm\n";
            dxf += "50\n0.0\n";
        }

        dxf += "0\nENDSEC\n";
        dxf += "0\nEOF\n";
        
        return dxf;
    }
    
    // Helper function to get SVG content as string
    function getSVGContent() {
        if (generatedHoles.length === 0) return null;
        const totalH = parseFloat(inputs.h.value);
        const totalW = parseFloat(inputs.w.value);
        const footerHeight = includeFooterStatsInDownload ? 20 : 0;
        const svgHeight = totalH + footerHeight;
        const colors = getEffectiveColors(swapHolePanelColors);
        
        let svg = '<?xml version="1.0" encoding="UTF-8"?>\n';
        svg += '<svg xmlns="http://www.w3.org/2000/svg" ';
        svg += `width="${totalW}mm" height="${svgHeight}mm" `;
        svg += `viewBox="0 0 ${totalW} ${svgHeight}">\n`;
        // Panel background (unflipped, in drawing coordinates)
        svg += `<rect width="${totalW}" height="${totalH}" fill="${colors.panelColor}"/>\n`;
        svg += '<g transform="translate(0,' + totalH + ') scale(1,-1)">\n'; // Flip Y axis
        
        // Draw panel boundaries
        svg += '<g id="panels" stroke="#0000FF" stroke-width="0.5" fill="none">\n';
        sheetDefinitions.forEach(s => {
            svg += `<rect x="${s.x}" y="${s.y}" width="${s.w}" height="${s.h}"/>\n`;
        });
        svg += '</g>\n';
        
        // Draw holes
        svg += `<g id="holes" fill="${colors.holeColor}">\n`;
        generatedHoles.forEach(h => {
            svg += `<circle cx="${h.x.toFixed(3)}" cy="${h.y.toFixed(3)}" r="${h.r.toFixed(3)}"/>\n`;
        });
        svg += '</g>\n';
        
        // Draw percentage text if enabled
        if (showPercentage && panelStats.length > 0) {
            svg += '<g id="text" fill="#000000" font-family="Arial" font-size="10" text-anchor="middle">\n';
            panelStats.forEach((stat, idx) => {
                if (idx < sheetDefinitions.length && stat.panelArea > 0) {
                    const sheet = sheetDefinitions[idx];
                    const percentage = stat.panelArea > 0 ? ((stat.openArea / stat.panelArea) * 100).toFixed(1) : "0.0";
                    const textX = sheet.x + sheet.w / 2;
                    const textY = sheet.y + sheet.h / 2;
                    svg += `<text x="${textX.toFixed(3)}" y="${textY.toFixed(3)}">${percentage}%</text>\n`;
                }
            });
            svg += '</g>\n';
        }
        
        svg += '</g>\n';
        
        // Add footer statistics if enabled
        if (includeFooterStatsInDownload) {
            const stats = getFooterStatistics();
            const footerY = totalH + 20; // Position below the design
            svg += `<text x="${totalW / 2}" y="${footerY}" fill="#000000" font-family="Arial" font-size="8" text-anchor="middle">Panels: ${stats.panels} | Holes: ${stats.holes.toLocaleString()} | Opening: ${stats.opening} | Min Hole: ${stats.minHole}mm | Max Hole: ${stats.maxHole}mm | Spacing: ${stats.spacing}mm</text>\n`;
        }
        
        svg += '</svg>';
        
        return svg;
    }
    
    async function downloadZIP() {
        if (!sourceImage || generatedHoles.length === 0) {
            if (typeof showNotification === 'function') showNotification('Please generate a pattern first.', 'info');
            return;
        }
        
        if (typeof JSZip === 'undefined') {
            if (typeof showNotification === 'function') showNotification('ZIP library not loaded. Please refresh the page.', 'error');
            return;
        }
        
        const filename = getDownloadFilename();
        const zip = new JSZip();
        
        try {
            // Add PNG file
            const pngDataURL = getPNGDataURL();
            if (pngDataURL) {
                const pngBase64 = pngDataURL.split(',')[1];
                zip.file(`${filename}.png`, pngBase64, { base64: true });
            }
            
            // Add TXT file
            const txtContent = getTXTContent();
            zip.file(`${filename}.txt`, txtContent);
            
            // Add DXF file
            const dxfContent = getDXFContent();
            if (dxfContent) {
                zip.file(`${filename}.dxf`, dxfContent);
            }
            
            // Add SVG file
            const svgContent = getSVGContent();
            if (svgContent) {
                zip.file(`${filename}.svg`, svgContent);
            }
            
            // Generate zip file
            const zipBlob = await zip.generateAsync({ type: 'blob' });
            
            // Download
        const link = document.createElement('a');
            link.download = `${filename}.zip`;
            link.href = URL.createObjectURL(zipBlob);
        link.click();
            
            // Clean up
            URL.revokeObjectURL(link.href);
        } catch (error) {
            console.error('Error creating ZIP file:', error);
            if (typeof showNotification === 'function') showNotification('Error creating ZIP file. Please try again.', 'error');
        }
    }
    
    // ========== AUTHENTICATION SYSTEM ==========
    
    // Firebase Configuration - REPLACE WITH YOUR FIREBASE CONFIG
    const firebaseConfig = {
        apiKey: "AIzaSyDyaAtK5YBWpMedGCICayR-VJq2111SpgU",
        authDomain: "perforated-panel-designer.firebaseapp.com",
        projectId: "perforated-panel-designer",
        storageBucket: "perforated-panel-designer.firebasestorage.app",
        messagingSenderId: "203709637797",
        appId: "1:203709637797:web:544190529c7c874aaf994c"
    };
    
    // Initialize Firebase
    if (typeof firebase !== 'undefined') {
        try {
            firebase.initializeApp(firebaseConfig);
            console.log('Firebase initialized successfully');
        } catch (error) {
            console.error('Firebase initialization error:', error);
        }
    } else {
        console.error('Firebase SDK not loaded');
    }
    
    // Auth Manager
    const authManager = {
        auth: null,
        db: null,
        currentUser: null,
        isAdmin: false,
        adminUsername: 'admin', // Will be set from environment
        adminPassword: 'admin123', // Will be set from environment
        
        init() {
            if (typeof firebase === 'undefined') {
                console.warn('Firebase not loaded. Auth features disabled.');
                return;
            }
            
            this.auth = firebase.auth();
            this.db = firebase.firestore();
            
            // Check admin credentials from environment (Cloudflare Pages)
            // For now, using defaults - will be overridden by env vars in production
            if (window.ADMIN_USERNAME) this.adminUsername = window.ADMIN_USERNAME;
            if (window.ADMIN_PASSWORD) this.adminPassword = window.ADMIN_PASSWORD;
            
            // Listen for auth state changes
            this.auth.onAuthStateChanged((user) => {
                this.currentUser = user;
                this.checkAdminStatus();
                updateAuthUI();
            });
            
            // Check admin session
            this.checkAdminSession();
        },
        
        async checkAdminStatus() {
            if (!this.currentUser) {
                this.isAdmin = false;
                return;
            }
            try {
                const userDoc = await this.db.collection('users').doc(this.currentUser.uid).get();
                this.isAdmin = userDoc.exists && userDoc.data().isAdmin === true;
            } catch (e) {
                this.isAdmin = false;
            }
        },
        
        checkAdminSession() {
            const adminSession = sessionStorage.getItem('adminSession');
            if (adminSession === 'true') {
                this.isAdmin = true;
            }
        },
        
        async signInWithEmail(email, password) {
            try {
                const userCredential = await this.auth.signInWithEmailAndPassword(email, password);
                
                // Update user document with lastLogin
                if (this.db) {
                    try {
                        const userDoc = await this.db.collection('users').doc(userCredential.user.uid).get();
                        if (userDoc.exists) {
                            // Update lastLogin
                            await this.db.collection('users').doc(userCredential.user.uid).update({
                                lastLogin: firebase.firestore.FieldValue.serverTimestamp()
                            });
                        } else {
                            // Create user document if it doesn't exist
                            await this.db.collection('users').doc(userCredential.user.uid).set({
                                email: userCredential.user.email,
                                displayName: userCredential.user.displayName || '',
                                photoURL: userCredential.user.photoURL || '',
                                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                                lastLogin: firebase.firestore.FieldValue.serverTimestamp(),
                                isAdmin: false,
                                downloadCount: 0
                            });
                        }
                    } catch (dbError) {
                        console.warn('Failed to update user document (non-critical):', dbError);
                    }
                }
                
                await this.trackLogin();
                return { success: true };
            } catch (error) {
                return { success: false, error: error.message };
            }
        },
        
        async signUpWithEmail(email, password) {
            try {
                const userCredential = await this.auth.createUserWithEmailAndPassword(email, password);
                await this.db.collection('users').doc(userCredential.user.uid).set({
                    email: email,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    isAdmin: false,
                    downloadCount: 0
                });
                await this.trackLogin();
                return { success: true };
            } catch (error) {
                return { success: false, error: error.message };
            }
        },
        
        async signInWithGoogle() {
            try {
                if (!this.auth) {
                    return { success: false, error: 'Firebase not initialized. Please refresh the page.' };
                }
                
                const provider = new firebase.auth.GoogleAuthProvider();
                // Add scopes if needed
                provider.addScope('profile');
                provider.addScope('email');
                
                // Set custom parameters
                provider.setCustomParameters({
                    prompt: 'select_account'
                });
                
                const userCredential = await this.auth.signInWithPopup(provider);
                
                // Try to update Firestore, but don't fail login if it doesn't work
                try {
                    if (this.db) {
                        // Check if user document exists, create if not
                        const userDoc = await this.db.collection('users').doc(userCredential.user.uid).get();
                        if (!userDoc.exists) {
                            await this.db.collection('users').doc(userCredential.user.uid).set({
                                email: userCredential.user.email,
                                displayName: userCredential.user.displayName || '',
                                photoURL: userCredential.user.photoURL || '',
                                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                                isAdmin: false,
                                downloadCount: 0
                            });
                        } else {
                            // Update last login
                            await this.db.collection('users').doc(userCredential.user.uid).update({
                                lastLogin: firebase.firestore.FieldValue.serverTimestamp()
                            });
                        }
                        
                        // Track login (non-blocking)
                        this.trackLogin().catch(err => {
                            console.warn('Failed to track login:', err);
                        });
                    }
                } catch (dbError) {
                    // Log but don't fail - authentication succeeded
                    console.warn('Firestore operation failed, but login succeeded:', dbError);
                    
                    // Provide helpful error message if it's a permissions issue
                    if (dbError.code === 'permission-denied' || dbError.message.includes('permission')) {
                        console.error('Firestore permission denied. Please check your Firestore security rules.');
                        // Don't show alert to user - login still succeeded
                    }
                    
                    // Try to track login in background
                    this.trackLogin().catch(err => {
                        console.warn('Failed to track login:', err);
                    });
                }
                
                return { success: true };
            } catch (error) {
                console.error('Google sign-in error:', error);
                let errorMessage = error.message;
                
                // Provide more helpful error messages
                if (error.code === 'auth/popup-blocked') {
                    errorMessage = 'Popup was blocked by your browser. Please allow popups for this site and try again.';
                } else if (error.code === 'auth/popup-closed-by-user') {
                    errorMessage = 'Sign-in popup was closed. Please try again.';
                } else if (error.code === 'auth/unauthorized-domain') {
                    errorMessage = 'This domain is not authorized for Google sign-in. Please contact support.';
                } else if (error.code === 'auth/operation-not-allowed') {
                    errorMessage = 'Google sign-in is not enabled. Please enable it in Firebase Console.';
                }
                
                return { success: false, error: errorMessage };
            }
        },
        
        async resetPassword(email) {
            try {
                await this.auth.sendPasswordResetEmail(email);
                return { success: true };
            } catch (error) {
                return { success: false, error: error.message };
            }
        },
        
        async signOut() {
            try {
                await this.auth.signOut();
                sessionStorage.removeItem('adminSession');
                this.currentUser = null;
                this.isAdmin = false;
                updateAuthUI();
                return { success: true };
            } catch (error) {
                return { success: false, error: error.message };
            }
        },
        
        async trackLogin() {
            if (!this.currentUser || !this.db) return;
            try {
                await this.db.collection('loginLogs').add({
                    userId: this.currentUser.uid,
                    email: this.currentUser.email,
                    timestamp: firebase.firestore.FieldValue.serverTimestamp()
                });
            } catch (e) {
                // Silently fail - don't block login if Firestore is unavailable
                console.warn('Failed to track login (non-critical):', e.message);
            }
        },
        
        async trackDownload(fileType) {
            if (!this.currentUser || !this.db) return;
            try {
                // Ensure user document exists
                const userDoc = await this.db.collection('users').doc(this.currentUser.uid).get();
                if (!userDoc.exists) {
                    await this.db.collection('users').doc(this.currentUser.uid).set({
                        email: this.currentUser.email,
                        displayName: this.currentUser.displayName || '',
                        photoURL: this.currentUser.photoURL || '',
                        createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                        lastLogin: firebase.firestore.FieldValue.serverTimestamp(),
                        isAdmin: false,
                        downloadCount: 0
                    });
                }
                
                // Track download
                await this.db.collection('downloads').add({
                    userId: this.currentUser.uid,
                    email: this.currentUser.email,
                    fileType: fileType,
                    timestamp: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                // Increment download count
                await this.db.collection('users').doc(this.currentUser.uid).update({
                    downloadCount: firebase.firestore.FieldValue.increment(1)
                });
            } catch (e) {
                // Silently fail - don't block downloads if Firestore is unavailable
                console.warn('Failed to track download (non-critical):', e.message);
            }
        },
        
        async adminLogin(username, password) {
            if (username === this.adminUsername && password === this.adminPassword) {
                sessionStorage.setItem('adminSession', 'true');
                this.isAdmin = true;
                updateAuthUI();
                return { success: true };
            }
            return { success: false, error: 'Invalid admin credentials' };
        },
        
        canDownload(fileType) {
            if (!this.currentUser) {
                return fileType === 'png' || fileType === 'txt';
            }
            return true;
        }
    };
    
    // Get superadmin email from config
    function getSuperAdminEmail() {
        // First try environment variable (set by Cloudflare Pages build process)
        if (window.SUPERADMIN_EMAIL) {
            return window.SUPERADMIN_EMAIL;
        }
        // Then try config file
        if (window.ADMIN_CONFIG && window.ADMIN_CONFIG.SUPERADMIN_EMAIL) {
            return window.ADMIN_CONFIG.SUPERADMIN_EMAIL;
        }
        return null;
    }
    
    // Auth UI Functions
    function updateAuthUI() {
        const userInfo = document.getElementById('userInfo');
        const guestInfo = document.getElementById('guestInfo');
        const userEmail = document.getElementById('userEmail');
        const adminBtn = document.getElementById('adminBtn');
        const adminPanelLink = document.getElementById('adminPanelLink');
        
        if (authManager.currentUser) {
            userInfo.classList.remove('hidden');
            userInfo.classList.add('flex');
            guestInfo.classList.add('hidden');
            guestInfo.classList.remove('flex');
            userEmail.textContent = authManager.currentUser.email;
            
            // Check if user is superadmin
            const superAdminEmail = getSuperAdminEmail();
            const isSuperAdmin = superAdminEmail && 
                authManager.currentUser.email.toLowerCase() === superAdminEmail.toLowerCase();
            
            // Show admin panel link in user menu if superadmin
            if (adminPanelLink) {
                if (isSuperAdmin) {
                    adminPanelLink.classList.remove('hidden');
                } else {
                    adminPanelLink.classList.add('hidden');
                }
            }
            
            // Show admin button in navbar if admin (legacy support)
            if (authManager.isAdmin) {
                adminBtn.classList.remove('hidden');
            } else {
                adminBtn.classList.add('hidden');
            }
        } else {
            userInfo.classList.add('hidden');
            userInfo.classList.remove('flex');
            guestInfo.classList.remove('hidden');
            guestInfo.classList.add('flex');
            adminBtn.classList.add('hidden');
            if (adminPanelLink) {
                adminPanelLink.classList.add('hidden');
            }
        }
        
        // Update download button visibility
        updateDownloadButtons();
    }
    
    // User Menu Toggle
    function toggleUserMenu() {
        const dropdown = document.getElementById('userMenuDropdown');
        dropdown.classList.toggle('hidden');
    }
    
    // Close user menu when clicking outside
    document.addEventListener('click', (e) => {
        const menuContainer = document.getElementById('userMenuContainer');
        const dropdown = document.getElementById('userMenuDropdown');
        if (menuContainer && !menuContainer.contains(e.target)) {
            dropdown.classList.add('hidden');
        }
    });
    
    // Check if user signed in with Google
    function isGoogleUser() {
        if (!authManager.currentUser) return false;
        const providers = authManager.currentUser.providerData || [];
        return providers.some(provider => provider.providerId === 'google.com');
    }
    
    // Change Password Functions
    function showChangePasswordModal() {
        document.getElementById('changePasswordModal').classList.add('active');
        document.getElementById('userMenuDropdown').classList.add('hidden');
        
        // Check if user is Google-authenticated
        const isGoogle = isGoogleUser();
        const currentPasswordGroup = document.getElementById('currentPasswordGroup');
        const currentPasswordLabel = document.getElementById('currentPasswordLabel');
        
        if (isGoogle) {
            // Hide current password field for Google users
            if (currentPasswordGroup) {
                currentPasswordGroup.style.display = 'none';
            }
            if (currentPasswordLabel) {
                currentPasswordLabel.textContent = 'Set Password (Google users can set a password)';
            }
        } else {
            // Show current password field for email/password users
            if (currentPasswordGroup) {
                currentPasswordGroup.style.display = 'block';
            }
            if (currentPasswordLabel) {
                currentPasswordLabel.textContent = 'Current Password';
            }
        }
        
        // Clear form
        document.getElementById('currentPassword').value = '';
        document.getElementById('newPassword').value = '';
        document.getElementById('confirmPassword').value = '';
        document.getElementById('changePasswordError').classList.remove('show');
        document.getElementById('changePasswordSuccess').classList.remove('show');
    }
    
    function closeChangePasswordModal() {
        document.getElementById('changePasswordModal').classList.remove('active');
    }
    
    async function handleChangePassword() {
        const currentPassword = document.getElementById('currentPassword').value;
        const newPassword = document.getElementById('newPassword').value;
        const confirmPassword = document.getElementById('confirmPassword').value;
        const errorEl = document.getElementById('changePasswordError');
        const successEl = document.getElementById('changePasswordSuccess');
        
        // Clear previous messages
        errorEl.classList.remove('show');
        successEl.classList.remove('show');
        
        // Check if user is Google-authenticated
        const isGoogle = isGoogleUser();
        
        // Validation - skip current password for Google users
        if (!isGoogle && !currentPassword) {
            errorEl.textContent = 'Current password is required';
            errorEl.classList.add('show');
            return;
        }
        
        if (!newPassword || !confirmPassword) {
            errorEl.textContent = 'New password fields are required';
            errorEl.classList.add('show');
            return;
        }
        
        if (newPassword.length < 6) {
            errorEl.textContent = 'New password must be at least 6 characters';
            errorEl.classList.add('show');
            return;
        }
        
        if (newPassword !== confirmPassword) {
            errorEl.textContent = 'New passwords do not match';
            errorEl.classList.add('show');
            return;
        }
        
        try {
            const user = authManager.currentUser;
            
            if (isGoogle) {
                // For Google users, we need to link email/password provider first
                // But Firebase requires re-authentication for security
                // For Google users setting password for the first time, we'll use updatePassword
                // which should work if the account has email/password linked, or we'll get an error
                try {
                    await user.updatePassword(newPassword);
                    successEl.textContent = 'Password set successfully! You can now use email/password to login.';
                } catch (updateError) {
                    if (updateError.code === 'auth/requires-recent-login') {
                        errorEl.textContent = 'For security, please sign out and sign in again, then set your password.';
                        errorEl.classList.add('show');
                        return;
                    } else {
                        // Try to link email/password provider
                        // This requires the user to have a password already set
                        errorEl.textContent = 'Unable to set password. Please contact support or try signing in with Google again.';
                        errorEl.classList.add('show');
                        return;
                    }
                }
            } else {
                // For email/password users, re-authenticate first
                const credential = firebase.auth.EmailAuthProvider.credential(
                    user.email,
                    currentPassword
                );
                await user.reauthenticateWithCredential(credential);
                await user.updatePassword(newPassword);
                successEl.textContent = 'Password changed successfully!';
            }
            
            successEl.classList.add('show');
            
            // Clear form
            document.getElementById('currentPassword').value = '';
            document.getElementById('newPassword').value = '';
            document.getElementById('confirmPassword').value = '';
            
            // Close modal after 2 seconds
            setTimeout(() => {
                closeChangePasswordModal();
            }, 2000);
            
        } catch (error) {
            errorEl.textContent = error.message || 'Failed to change password';
            errorEl.classList.add('show');
        }
    }
    
    function updateDownloadButtons() {
        // Update button styling and lock icons based on user permissions
        const dxfBtn = document.getElementById('downloadDxfBtn');
        const svgBtn = document.getElementById('downloadSvgBtn');
        const dxfLockIcon = document.getElementById('dxfLockIcon');
        const svgLockIcon = document.getElementById('svgLockIcon');
        const zipLockIcon = document.getElementById('zipLockIcon');
        
        // DXF Button - always visible, show lock for guests
        if (dxfBtn) {
            dxfBtn.style.display = 'flex';
            const canDownload = authManager.canDownload('dxf');
            if (dxfLockIcon) {
                dxfLockIcon.style.display = canDownload ? 'none' : 'block';
            }
            // Update button styling for locked state
            if (canDownload) {
                dxfBtn.classList.remove('opacity-60', 'cursor-not-allowed');
                dxfBtn.classList.add('cursor-pointer');
            } else {
                dxfBtn.classList.add('opacity-60', 'cursor-not-allowed');
                dxfBtn.classList.remove('cursor-pointer');
            }
        }
        
        // SVG Button - always visible, show lock for guests
        if (svgBtn) {
            svgBtn.style.display = 'flex';
            const canDownload = authManager.canDownload('svg');
            if (svgLockIcon) {
                svgLockIcon.style.display = canDownload ? 'none' : 'block';
            }
            // Update button styling for locked state
            if (canDownload) {
                svgBtn.classList.remove('opacity-60', 'cursor-not-allowed');
                svgBtn.classList.add('cursor-pointer');
            } else {
                svgBtn.classList.add('opacity-60', 'cursor-not-allowed');
                svgBtn.classList.remove('cursor-pointer');
            }
        }
        
        // ZIP Button - always visible, show lock for guests
        const zipBtn = document.getElementById('downloadZipBtn');
        if (zipBtn) {
            zipBtn.style.display = 'flex';
            const canDownloadZip = authManager.canDownload('zip');
            if (zipLockIcon) {
                zipLockIcon.style.display = canDownloadZip ? 'none' : 'block';
            }
            // Update button styling for locked state
            if (canDownloadZip) {
                zipBtn.classList.remove('opacity-60', 'cursor-not-allowed');
                zipBtn.classList.add('cursor-pointer');
            } else {
                zipBtn.classList.add('opacity-60', 'cursor-not-allowed');
                zipBtn.classList.remove('cursor-pointer');
            }
        }
        
    }
    
    // Handle download button clicks with permission check
    function handleDownloadClick(type) {
        if (!authManager.canDownload(type)) {
            if (typeof showNotification === 'function') showNotification('Please register or login to download ' + type.toUpperCase() + ' files.', 'info');
            showAuthModal();
            toggleDownloadsMenu(); // Close the dropdown
            return;
        }
        
        // User has permission, proceed with download using window functions for tracking
        if (type === 'dxf') {
            window.downloadDXF();
        } else if (type === 'svg') {
            window.downloadSVG();
        } else if (type === 'zip') {
            window.downloadZIP();
        }
        toggleDownloadsMenu(); // Close the dropdown after download
    }
    
    // Downloads Menu Toggle
    function toggleDownloadsMenu() {
        const dropdown = document.getElementById('downloadsMenuDropdown');
        dropdown.classList.toggle('hidden');
    }
    
    // Close downloads menu when clicking outside
    document.addEventListener('click', (e) => {
        const menuContainer = document.getElementById('downloadsMenuContainer');
        const dropdown = document.getElementById('downloadsMenuDropdown');
        if (menuContainer && !menuContainer.contains(e.target)) {
            dropdown.classList.add('hidden');
        }
    });
    
    function showAuthModal() {
        document.getElementById('authModal').classList.add('active');
        switchAuthTab('login');
    }
    
    function closeAuthModal() {
        document.getElementById('authModal').classList.remove('active');
    }
    
    function switchAuthTab(tab) {
        document.querySelectorAll('.auth-tab').forEach(t => t.classList.remove('active'));
        document.getElementById('loginForm').style.display = tab === 'login' ? 'block' : 'none';
        document.getElementById('registerForm').style.display = tab === 'register' ? 'block' : 'none';
        document.getElementById('forgotForm').style.display = tab === 'forgot' ? 'block' : 'none';
        
        if (tab === 'login') document.querySelectorAll('.auth-tab')[0].classList.add('active');
        if (tab === 'register') document.querySelectorAll('.auth-tab')[1].classList.add('active');
        
        // Clear errors
        document.querySelectorAll('.error-message').forEach(e => {
            e.classList.remove('show');
            e.textContent = '';
        });
    }
    
    async function handleLogin() {
        const email = document.getElementById('loginEmail').value;
        const password = document.getElementById('loginPassword').value;
        const errorEl = document.getElementById('loginError');
        
        const result = await authManager.signInWithEmail(email, password);
        if (result.success) {
            closeAuthModal();
        } else {
            errorEl.textContent = result.error;
            errorEl.classList.add('show');
        }
    }
    
    async function handleRegister() {
        const email = document.getElementById('registerEmail').value;
        const password = document.getElementById('registerPassword').value;
        const errorEl = document.getElementById('registerError');
        
        if (password.length < 6) {
            errorEl.textContent = 'Password must be at least 6 characters';
            errorEl.classList.add('show');
            return;
        }
        
        const result = await authManager.signUpWithEmail(email, password);
        if (result.success) {
            closeAuthModal();
        } else {
            errorEl.textContent = result.error;
            errorEl.classList.add('show');
        }
    }
    
    async function handleGoogleLogin() {
        const result = await authManager.signInWithGoogle();
        if (result.success) {
            closeAuthModal();
        } else {
            if (typeof showNotification === 'function') showNotification('Google login failed: ' + result.error, 'error');
        }
    }
    
    async function handleForgotPassword() {
        const email = document.getElementById('forgotEmail').value;
        const errorEl = document.getElementById('forgotError');
        const successEl = document.getElementById('forgotSuccess');
        
        const result = await authManager.resetPassword(email);
        if (result.success) {
            successEl.textContent = 'Password reset email sent!';
            successEl.classList.add('show');
            errorEl.classList.remove('show');
        } else {
            errorEl.textContent = result.error;
            errorEl.classList.add('show');
            successEl.classList.remove('show');
        }
    }
    
    // Admin Panel Functions
    function showAdminPanel() {
        document.getElementById('adminModal').classList.add('active');
        if (!authManager.isAdmin) {
            document.getElementById('adminLoginForm').style.display = 'block';
            document.getElementById('adminPanelContent').style.display = 'none';
        } else {
            loadAdminData();
        }
    }
    
    function closeAdminPanel() {
        document.getElementById('adminModal').classList.remove('active');
    }
    
    async function handleAdminLogin() {
        const username = document.getElementById('adminUsername').value;
        const password = document.getElementById('adminPassword').value;
        const errorEl = document.getElementById('adminLoginError');
        
        const result = await authManager.adminLogin(username, password);
        if (result.success) {
            document.getElementById('adminLoginForm').style.display = 'none';
            document.getElementById('adminPanelContent').style.display = 'block';
            loadAdminData();
        } else {
            errorEl.textContent = result.error;
            errorEl.classList.add('show');
        }
    }
    
    async function loadAdminData() {
        if (!authManager.isAdmin || !authManager.db) return;
        
        try {
            // Get total users
            const usersSnapshot = await authManager.db.collection('users').get();
            document.getElementById('totalUsers').textContent = usersSnapshot.size;
            
            // Get total downloads
            const downloadsSnapshot = await authManager.db.collection('downloads').get();
            document.getElementById('totalDownloads').textContent = downloadsSnapshot.size;
            
            // Get downloads today
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const todayDownloads = downloadsSnapshot.docs.filter(doc => {
                const timestamp = doc.data().timestamp;
                if (timestamp && timestamp.toDate) {
                    return timestamp.toDate() >= today;
                }
                return false;
            });
            document.getElementById('downloadsToday').textContent = todayDownloads.length;
            
            // Populate users table
            const tbody = document.getElementById('usersTableBody');
            tbody.innerHTML = '';
            usersSnapshot.forEach(doc => {
                const user = doc.data();
                const row = tbody.insertRow();
                row.insertCell(0).textContent = user.email || 'N/A';
                row.insertCell(1).textContent = user.downloadCount || 0;
                row.insertCell(2).textContent = user.lastLogin ? 
                    new Date(user.lastLogin.toDate()).toLocaleDateString() : 'Never';
            });
        } catch (e) {
            console.error('Failed to load admin data:', e);
        }
    }
    
    // Wrap download functions to check permissions and track downloads
    const originalDownloadImage = downloadImage;
    window.downloadImage = async function() {
        if (!authManager.canDownload('png')) {
            if (typeof showNotification === 'function') showNotification('Please login to download PNG files.', 'info');
            showAuthModal();
            return;
        }
        if (authManager.currentUser) {
            await authManager.trackDownload('png');
        }
        // Check if there's content to download
        if (typeof originalDownloadImage === 'function') {
            originalDownloadImage();
        } else {
            if (typeof showNotification === 'function') showNotification('No image to download. Upload an image and generate the pattern first.', 'info');
        }
    };
    
    const originalDownloadSpecs = downloadSpecs;
    window.downloadSpecs = async function() {
        if (!authManager.canDownload('txt')) {
            if (typeof showNotification === 'function') showNotification('Please login to download settings files.', 'info');
            showAuthModal();
            return;
        }
        if (authManager.currentUser) {
            await authManager.trackDownload('txt');
        }
        // Check if there's content to download
        if (typeof originalDownloadSpecs === 'function') {
            originalDownloadSpecs();
        } else {
            if (typeof showNotification === 'function') showNotification('No settings to download. Configure and generate a pattern first.', 'info');
        }
    };
    
    const originalDownloadDXF = downloadDXF;
    window.downloadDXF = async function() {
        if (!authManager.canDownload('dxf')) {
            if (typeof showNotification === 'function') showNotification('Please register or login to download DXF files.', 'info');
            showAuthModal();
            return;
        }
        await authManager.trackDownload('dxf');
        // Check if there's content to download
        if (typeof originalDownloadDXF === 'function') {
            originalDownloadDXF();
        } else {
            if (typeof showNotification === 'function') showNotification('No pattern to download. Generate a pattern first.', 'info');
        }
    };
    
    const originalDownloadSVG = downloadSVG;
    window.downloadSVG = async function() {
        if (!authManager.canDownload('svg')) {
            if (typeof showNotification === 'function') showNotification('Please register or login to download SVG files.', 'info');
            showAuthModal();
            return;
        }
        await authManager.trackDownload('svg');
        // Check if there's content to download
        if (typeof originalDownloadSVG === 'function') {
            originalDownloadSVG();
        } else {
            if (typeof showNotification === 'function') showNotification('No pattern to download. Generate a pattern first.', 'info');
        }
    };
    
    const originalDownloadZIP = downloadZIP;
    window.downloadZIP = async function() {
        if (!authManager.canDownload('zip')) {
            if (typeof showNotification === 'function') showNotification('Please register or login to download ZIP files.', 'info');
            showAuthModal();
            return;
        }
        await authManager.trackDownload('zip');
        // Check if there's content to download
        if (typeof originalDownloadZIP === 'function') {
            await originalDownloadZIP();
        } else {
            if (typeof showNotification === 'function') showNotification('No pattern to download. Generate a pattern first.', 'info');
        }
    };
    
    // Initialize auth on page load
    if (typeof firebase !== 'undefined') {
        authManager.init();
    } else {
        // Wait for Firebase to load
        window.addEventListener('load', () => {
            if (typeof firebase !== 'undefined') {
                authManager.init();
            }
        });
    }
    
    // Make authManager globally available
    window.authManager = authManager;
    window.updateAuthUI = updateAuthUI;
    window.showAuthModal = showAuthModal;
    window.closeAuthModal = closeAuthModal;
    window.switchAuthTab = switchAuthTab;
    window.handleLogin = handleLogin;
    window.handleRegister = handleRegister;
    window.handleGoogleLogin = handleGoogleLogin;
    window.handleForgotPassword = handleForgotPassword;
    window.showAdminPanel = showAdminPanel;
    window.closeAdminPanel = closeAdminPanel;
    window.handleAdminLogin = handleAdminLogin;
    window.toggleUserMenu = toggleUserMenu;
    window.showChangePasswordModal = showChangePasswordModal;
    window.closeChangePasswordModal = closeChangePasswordModal;
    window.handleChangePassword = handleChangePassword;
    window.toggleDownloadsMenu = toggleDownloadsMenu;
    window.openRawPhotoModal = openRawPhotoModal;
    window.closeRawPhotoModal = closeRawPhotoModal;
    window.showNotification = showNotification;
    window.handleDownloadClick = handleDownloadClick;

    // --- Resizable Footer Logic (run after DOM so footer and buttons exist) ---
    function initResizableFooter() {
        const footerEl = document.querySelector('footer');
        if (!footerEl) return;

        // Prepare footer styles for resizing
        footerEl.style.position = 'relative';
        footerEl.style.minHeight = '44px';
        footerEl.style.overflow = 'visible';
        
        // Create resize handle
        const handle = document.createElement('div');
        Object.assign(handle.style, {
            position: 'absolute',
            top: '-5px',
            left: '0',
            right: '0',
            height: '10px',
            cursor: 'ns-resize',
            zIndex: '1000',
            backgroundColor: 'transparent' 
        });
        handle.title = 'Drag to resize footer';
        
        handle.addEventListener('mouseenter', () => {
            handle.style.backgroundColor = 'rgba(0,0,0,0.05)';
            handle.style.borderTop = '2px solid #cbd5e1';
        });
        handle.addEventListener('mouseleave', () => {
            handle.style.backgroundColor = 'transparent';
            handle.style.borderTop = 'none';
        });
        
        footerEl.prepend(handle);

        let isResizing = false;
        let startY = 0;
        let startHeight = 0;

        function updateFooterHeight(h) {
            const newHeight = Math.max(44, Math.min(400, h));
            footerEl.style.height = newHeight + 'px';
            
            const fontSize = Math.max(12, newHeight * 0.34);
            const content = footerEl.querySelector('.footer-one-line');
            if (content) {
                content.style.fontSize = fontSize + 'px';
                content.style.gap = (fontSize * 1.5) + 'px';
                const stats = content.querySelector('.footer-stats-left');
                if (stats) stats.style.gap = (fontSize * 1.5) + 'px';
                const progBar = document.getElementById('footerProgressBar');
                if (progBar) {
                    progBar.style.width = (110 * (fontSize / 13.6)) + 'px';
                    progBar.style.height = (5 * (fontSize / 13.6)) + 'px';
                }
            }
            try { localStorage.setItem('footerHeight', newHeight + 'px'); } catch(e) {}
        }

        handle.addEventListener('mousedown', (e) => {
            isResizing = true;
            startY = e.clientY;
            startHeight = footerEl.offsetHeight;
            document.body.style.cursor = 'ns-resize';
            e.preventDefault();
        });

        document.addEventListener('mousemove', (e) => {
            if (!isResizing) return;
            const diff = startY - e.clientY;
            updateFooterHeight(startHeight + diff);
        });

        document.addEventListener('mouseup', () => {
            if (isResizing) {
                isResizing = false;
                document.body.style.cursor = '';
            }
        });
        
        try {
            const savedHeight = localStorage.getItem('footerHeight');
            if (savedHeight) updateFooterHeight(parseFloat(savedHeight));
        } catch(e) {}
    }
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initResizableFooter);
    } else {
        initResizableFooter();
    }
</script>

</div> <!-- End main-wrapper -->

<footer class="bg-white border-t border-gray-200 py-2 text-center text-sm text-gray-600">
    <div class="footer-one-line">
        <div class="footer-stats-left">
            <span><strong>Panels:</strong> <span id="footerPanels">0</span></span>
            <span><strong>Holes:</strong> <span id="footerHoles">0</span></span>
            <span><strong>Opening:</strong> <span id="footerOpening">0%</span></span>
            <span><strong>Min Hole:</strong> <span id="footerMinHole">0</span>mm</span>
            <span><strong>Max Hole:</strong> <span id="footerMaxHole">0</span>mm</span>
            <span><strong>Spacing:</strong> <span id="footerSpacing">0</span>mm</span>
        </div>
        <span class="footer-progress-inline" id="footerProgressWrap" style="display: none;">
            <span id="footerProgressStatus">Ready</span> <span id="footerProgressTime"></span>
            <span class="footer-progress-bar footer-progress-bar-inline" id="footerProgressBar" style="display: inline-block; vertical-align: middle; margin-left: 4px;">
                <span class="footer-progress-fill" id="footerProgressFill" style="display: inline-block; border-radius: 2px; vertical-align: middle;"></span>
            </span>
        </span>
        <span class="footer-credit">Designed by Ehsan Mokhtary</span>
    </div>
</footer>

</body></html>